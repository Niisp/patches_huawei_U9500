diff --git a/core/java/android/bluetooth/AtCommandHandler.java b/core/java/android/bluetooth/AtCommandHandler.java
new file mode 100644
index 0000000..6deab34
--- /dev/null
+++ b/core/java/android/bluetooth/AtCommandHandler.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.bluetooth.AtCommandResult;
+
+/**
+ * Handler Interface for {@link AtParser}.<p>
+ * @hide
+ */
+public abstract class AtCommandHandler {
+
+    /**
+     * Handle Basic commands "ATA".<p>
+     * These are single letter commands such as ATA and ATD. Anything following
+     * the single letter command ('A' and 'D' respectively) will be passed as
+     * 'arg'.<p>
+     * For example, "ATDT1234" would result in the call
+     * handleBasicCommand("T1234").<p>
+     * @param arg Everything following the basic command character.
+     * @return    The result of this command.
+     */
+    public AtCommandResult handleBasicCommand(String arg) {
+        return new AtCommandResult(AtCommandResult.ERROR);
+    }
+
+    /**
+     * Handle Actions command "AT+FOO".<p>
+     * Action commands are part of the Extended command syntax, and are
+     * typically used to signal an action on "FOO".<p>
+     * @return The result of this command.
+     */
+    public AtCommandResult handleActionCommand() {
+        return new AtCommandResult(AtCommandResult.ERROR);
+    }
+
+    /**
+     * Handle Read command "AT+FOO?".<p>
+     * Read commands are part of the Extended command syntax, and are
+     * typically used to read the value of "FOO".<p>
+     * @return The result of this command.
+     */
+    public AtCommandResult handleReadCommand() {
+        return new AtCommandResult(AtCommandResult.ERROR);
+    }
+
+    /**
+     * Handle Set command "AT+FOO=...".<p>
+     * Set commands are part of the Extended command syntax, and are
+     * typically used to set the value of "FOO". Multiple arguments can be
+     * sent.<p>
+     * AT+FOO=[<arg1>[,<arg2>[,...]]]<p>
+     * Each argument will be either numeric (Integer) or String.
+     * handleSetCommand is passed a generic Object[] array in which each
+     * element will be an Integer (if it can be parsed with parseInt()) or
+     * String.<p>
+     * Missing arguments ",," are set to empty Strings.<p>
+     * @param args Array of String and/or Integer's. There will always be at
+     *             least one element in this array.
+     * @return     The result of this command.
+     */
+    // Typically used to set this parameter
+    public AtCommandResult handleSetCommand(Object[] args) {
+        return new AtCommandResult(AtCommandResult.ERROR);
+    }
+
+    /**
+     * Handle Test command "AT+FOO=?".<p>
+     * Test commands are part of the Extended command syntax, and are typically
+     * used to request an indication of the range of legal values that "FOO"
+     * can take.<p>
+     * By default we return an OK result, to indicate that this command is at
+     * least recognized.<p>
+     * @return The result of this command.
+     */
+    public AtCommandResult handleTestCommand() {
+        return new AtCommandResult(AtCommandResult.OK);
+    }
+
+}
diff --git a/core/java/android/bluetooth/AtCommandResult.java b/core/java/android/bluetooth/AtCommandResult.java
new file mode 100644
index 0000000..9675234
--- /dev/null
+++ b/core/java/android/bluetooth/AtCommandResult.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+/**
+ * The result of execution of a single AT command.<p>
+ *
+ *
+ * This class can represent the final response to an AT command line, and also
+ * intermediate responses to a single command within a chained AT command
+ * line.<p>
+ *
+ * The actual responses that are intended to be send in reply to the AT command
+ * line are stored in a string array. The final response is stored as an
+ * int enum, converted to a string when toString() is called. Only a single
+ * final response is sent from multiple commands chained into a single command
+ * line.<p>
+ * @hide
+ */
+public class AtCommandResult {
+    // Result code enumerations
+    public static final int OK = 0;
+    public static final int ERROR = 1;
+    public static final int UNSOLICITED = 2;
+
+    private static final String OK_STRING = "OK";
+    private static final String ERROR_STRING = "ERROR";
+
+    private int mResultCode;  // Result code
+    private StringBuilder mResponse; // Response with CRLF line breaks
+
+    /**
+     * Construct a new AtCommandResult with given result code, and an empty
+     * response array.
+     * @param resultCode One of OK, ERROR or UNSOLICITED.
+     */
+    public AtCommandResult(int resultCode) {
+        mResultCode = resultCode;
+        mResponse = new StringBuilder();
+    }
+
+    /**
+     * Construct a new AtCommandResult with result code OK, and the specified
+     * single line response.
+     * @param response The single line response.
+     */
+    public AtCommandResult(String response) {
+        this(OK);
+        addResponse(response);
+    }
+
+    public int getResultCode() {
+        return mResultCode;
+    }
+
+    /**
+     * Add another line to the response.
+     */
+    public void addResponse(String response) {
+        appendWithCrlf(mResponse, response);
+    }
+
+    /**
+     * Add the given result into this AtCommandResult object.<p>
+     * Used to combine results from multiple commands in a single command line
+     * (command chaining).
+     * @param result The AtCommandResult to add to this result.
+     */
+    public void addResult(AtCommandResult result) {
+        if (result != null) {
+            appendWithCrlf(mResponse, result.mResponse.toString());
+            mResultCode = result.mResultCode;
+        }
+    }
+
+    /**
+     * Generate the string response ready to send
+     */
+    public String toString() {
+        StringBuilder result = new StringBuilder(mResponse.toString());
+        switch (mResultCode) {
+        case OK:
+            appendWithCrlf(result, OK_STRING);
+            break;
+        case ERROR:
+            appendWithCrlf(result, ERROR_STRING);
+            break;
+        }
+        return result.toString();
+    }
+
+    /** Append a string to a string builder, joining with a double
+     * CRLF. Used to create multi-line AT command replies
+     */
+    public static void appendWithCrlf(StringBuilder str1, String str2) {
+        if (str1.length() > 0 && str2.length() > 0) {
+            str1.append("\r\n\r\n");
+        }
+        str1.append(str2);
+    }
+};
diff --git a/core/java/android/bluetooth/AtParser.java b/core/java/android/bluetooth/AtParser.java
new file mode 100644
index 0000000..328fb2b
--- /dev/null
+++ b/core/java/android/bluetooth/AtParser.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import java.util.*;
+
+/**
+ * An AT (Hayes command) Parser based on (a subset of) the ITU-T V.250 standard.
+ * <p>
+ *
+ * Conformant with the subset of V.250 required for implementation of the
+ * Bluetooth Headset and Handsfree Profiles, as per Bluetooth SIP
+ * specifications. Also implements some V.250 features not required by
+ * Bluetooth - such as chained commands.<p>
+ *
+ * Command handlers are registered with an AtParser object. These handlers are
+ * invoked when command lines are processed by AtParser's process() method.<p>
+ *
+ * The AtParser object accepts a new command line to parse via its process()
+ * method. It breaks each command line into one or more commands. Each command
+ * is parsed for name, type, and (optional) arguments, and an appropriate
+ * external handler method is called through the AtCommandHandler interface.
+ *
+ * The command types are<ul>
+ * <li>Basic Command. For example "ATDT1234567890". Basic command names are a
+ * single character (e.g. "D"), and everything following this character is
+ * passed to the handler as a string argument (e.g. "T1234567890").
+ * <li>Action Command. For example "AT+CIMI". The command name is "CIMI", and
+ * there are no arguments for action commands.
+ * <li>Read Command. For example "AT+VGM?". The command name is "VGM", and there
+ * are no arguments for get commands.
+ * <li>Set Command. For example "AT+VGM=14". The command name is "VGM", and
+ * there is a single integer argument in this case. In the general case then
+ * can be zero or more arguments (comma delimited) each of integer or string
+ * form.
+ * <li>Test Command. For example "AT+VGM=?. No arguments.
+ * </ul>
+ *
+ * In V.250 the last four command types are known as Extended Commands, and
+ * they are used heavily in Bluetooth.<p>
+ *
+ * Basic commands cannot be chained in this implementation. For Bluetooth
+ * headset/handsfree use this is acceptable, because they only use the basic
+ * commands ATA and ATD, which are not allowed to be chained. For general V.250
+ * use we would need to improve this class to allow Basic command chaining -
+ * however it's tricky to get right because there is no delimiter for Basic
+ * command chaining.<p>
+ *
+ * Extended commands can be chained. For example:<p>
+ * AT+VGM?;+VGM=14;+CIMI<p>
+ * This is equivalent to:<p>
+ * AT+VGM?
+ * AT+VGM=14
+ * AT+CIMI
+ * Except that only one final result code is return (although several
+ * intermediate responses may be returned), and as soon as one command in the
+ * chain fails the rest are abandoned.<p>
+ *
+ * Handlers are registered by there command name via register(Char c, ...) or
+ * register(String s, ...). Handlers for Basic command should be registered by
+ * the basic command character, and handlers for Extended commands should be
+ * registered by String.<p>
+ *
+ * Refer to:<ul>
+ * <li>ITU-T Recommendation V.250
+ * <li>ETSI TS 127.007  (AT Command set for User Equipment, 3GPP TS 27.007)
+ * <li>Bluetooth Headset Profile Spec (K6)
+ * <li>Bluetooth Handsfree Profile Spec (HFP 1.5)
+ * </ul>
+ * @hide
+ */
+public class AtParser {
+
+    // Extended command type enumeration, only used internally
+    private static final int TYPE_ACTION = 0;   // AT+FOO
+    private static final int TYPE_READ = 1;     // AT+FOO?
+    private static final int TYPE_SET = 2;      // AT+FOO=
+    private static final int TYPE_TEST = 3;     // AT+FOO=?
+
+    private HashMap<String, AtCommandHandler> mExtHandlers;
+    private HashMap<Character, AtCommandHandler> mBasicHandlers;
+
+    private String mLastInput;  // for "A/" (repeat last command) support
+
+    /**
+     * Create a new AtParser.<p>
+     * No handlers are registered.
+     */
+    public AtParser() {
+        mBasicHandlers = new HashMap<Character, AtCommandHandler>();
+        mExtHandlers = new HashMap<String, AtCommandHandler>();
+        mLastInput = "";
+    }
+
+    /**
+     * Register a Basic command handler.<p>
+     * Basic command handlers are later called via their
+     * <code>handleBasicCommand(String args)</code> method.
+     * @param  command Command name - a single character
+     * @param  handler Handler to register
+     */
+    public void register(Character command, AtCommandHandler handler) {
+        mBasicHandlers.put(command, handler);
+    }
+
+    /**
+     * Register an Extended command handler.<p>
+     * Extended command handlers are later called via:<ul>
+     * <li><code>handleActionCommand()</code>
+     * <li><code>handleGetCommand()</code>
+     * <li><code>handleSetCommand()</code>
+     * <li><code>handleTestCommand()</code>
+     * </ul>
+     * Only one method will be called for each command processed.
+     * @param  command Command name - can be multiple characters
+     * @param  handler Handler to register
+     */
+    public void register(String command, AtCommandHandler handler) {
+        mExtHandlers.put(command, handler);
+    }
+
+
+    /**
+     * Strip input of whitespace and force Uppercase - except sections inside
+     * quotes. Also fixes unmatched quotes (by appending a quote). Double
+     * quotes " are the only quotes allowed by V.250
+     */
+    static private String clean(String input) {
+        StringBuilder out = new StringBuilder(input.length());
+
+        for (int i = 0; i < input.length(); i++) {
+            char c = input.charAt(i);
+            if (c == '"') {
+                int j = input.indexOf('"', i + 1 );  // search for closing "
+                if (j == -1) {  // unmatched ", insert one.
+                    out.append(input.substring(i, input.length()));
+                    out.append('"');
+                    break;
+                }
+                out.append(input.substring(i, j + 1));
+                i = j;
+            } else if (c != ' ') {
+                out.append(Character.toUpperCase(c));
+            }
+        }
+
+        return out.toString();
+    }
+
+    static private boolean isAtoZ(char c) {
+        return (c >= 'A' && c <= 'Z');
+    }
+
+    /**
+     * Find a character ch, ignoring quoted sections.
+     * Return input.length() if not found.
+     */
+    static private int findChar(char ch, String input, int fromIndex) {
+        for (int i = fromIndex; i < input.length(); i++) {
+            char c = input.charAt(i);
+            if (c == '"') {
+                i = input.indexOf('"', i + 1);
+                if (i == -1) {
+                    return input.length();
+                }
+            } else if (c == ch) {
+                return i;
+            }
+        }
+        return input.length();
+    }
+
+    /**
+     * Break an argument string into individual arguments (comma delimited).
+     * Integer arguments are turned into Integer objects. Otherwise a String
+     * object is used.
+     */
+    static private Object[] generateArgs(String input) {
+        int i = 0;
+        int j;
+        ArrayList<Object> out = new ArrayList<Object>();
+        while (i <= input.length()) {
+            j = findChar(',', input, i);
+
+            String arg = input.substring(i, j);
+            try {
+                out.add(new Integer(arg));
+            } catch (NumberFormatException e) {
+                out.add(arg);
+            }
+
+            i = j + 1; // move past comma
+        }
+        return out.toArray();
+    }
+
+    /**
+     * Return the index of the end of character after the last character in
+     * the extended command name. Uses the V.250 spec for allowed command
+     * names.
+     */
+    static private int findEndExtendedName(String input, int index) {
+        for (int i = index; i < input.length(); i++) {
+            char c = input.charAt(i);
+
+            // V.250 defines the following chars as legal extended command
+            // names
+            if (isAtoZ(c)) continue;
+            if (c >= '0' && c <= '9') continue;
+            switch (c) {
+            case '!':
+            case '%':
+            case '-':
+            case '.':
+            case '/':
+            case ':':
+            case '_':
+                continue;
+            default:
+                return i;
+            }
+        }
+        return input.length();
+    }
+
+    /**
+     * Processes an incoming AT command line.<p>
+     * This method will invoke zero or one command handler methods for each
+     * command in the command line.<p>
+     * @param raw_input The AT input, without EOL delimiter (e.g. <CR>).
+     * @return          Result object for this command line. This can be
+     *                  converted to a String[] response with toStrings().
+     */
+    public AtCommandResult process(String raw_input) {
+        String input = clean(raw_input);
+
+        // Handle "A/" (repeat previous line)
+        if (input.regionMatches(0, "A/", 0, 2)) {
+            input = new String(mLastInput);
+        } else {
+            mLastInput = new String(input);
+        }
+
+        // Handle empty line - no response necessary
+        if (input.equals("")) {
+            // Return []
+            return new AtCommandResult(AtCommandResult.UNSOLICITED);
+        }
+
+        // Anything else deserves an error
+        if (!input.regionMatches(0, "AT", 0, 2)) {
+            // Return ["ERROR"]
+            return new AtCommandResult(AtCommandResult.ERROR);
+        }
+
+        // Ok we have a command that starts with AT. Process it
+        int index = 2;
+        AtCommandResult result =
+                new AtCommandResult(AtCommandResult.UNSOLICITED);
+        while (index < input.length()) {
+            char c = input.charAt(index);
+
+            if (isAtoZ(c)) {
+                // Option 1: Basic Command
+                // Pass the rest of the line as is to the handler. Do not
+                // look for any more commands on this line.
+                String args = input.substring(index + 1);
+                if (mBasicHandlers.containsKey((Character)c)) {
+                    result.addResult(mBasicHandlers.get(
+                            (Character)c).handleBasicCommand(args));
+                    return result;
+                } else {
+                    // no handler
+                    result.addResult(
+                            new AtCommandResult(AtCommandResult.ERROR));
+                    return result;
+                }
+                // control never reaches here
+            }
+
+            if (c == '+') {
+                // Option 2: Extended Command
+                // Search for first non-name character. Short-circuit if
+                // we don't handle this command name.
+                int i = findEndExtendedName(input, index + 1);
+                String commandName = input.substring(index, i);
+                if (!mExtHandlers.containsKey(commandName)) {
+                    // no handler
+                    result.addResult(
+                            new AtCommandResult(AtCommandResult.ERROR));
+                    return result;
+                }
+                AtCommandHandler handler = mExtHandlers.get(commandName);
+
+                // Search for end of this command - this is usually the end of
+                // line
+                int endIndex = findChar(';', input, index);
+
+                // Determine what type of command this is.
+                // Default to TYPE_ACTION if we can't find anything else
+                // obvious.
+                int type;
+
+                if (i >= endIndex) {
+                    type = TYPE_ACTION;
+                } else if (input.charAt(i) == '?') {
+                    type = TYPE_READ;
+                } else if (input.charAt(i) == '=') {
+                    if (i + 1 < endIndex) {
+                        if (input.charAt(i + 1) == '?') {
+                            type = TYPE_TEST;
+                        } else {
+                            type = TYPE_SET;
+                        }
+                    } else {
+                        type = TYPE_SET;
+                    }
+                } else {
+                    type = TYPE_ACTION;
+                }
+
+                // Call this command. Short-circuit as soon as a command fails
+                switch (type) {
+                case TYPE_ACTION:
+                    result.addResult(handler.handleActionCommand());
+                    break;
+                case TYPE_READ:
+                    result.addResult(handler.handleReadCommand());
+                    break;
+                case TYPE_TEST:
+                    result.addResult(handler.handleTestCommand());
+                    break;
+                case TYPE_SET:
+                    Object[] args =
+                            generateArgs(input.substring(i + 1, endIndex));
+                    result.addResult(handler.handleSetCommand(args));
+                    break;
+                }
+                if (result.getResultCode() != AtCommandResult.OK) {
+                    return result;   // short-circuit
+                }
+
+                index = endIndex;
+            } else {
+                // Can't tell if this is a basic or extended command.
+                // Push forwards and hope we hit something.
+                index++;
+            }
+        }
+        // Finished processing (and all results were ok)
+        return result;
+    }
+}
diff --git a/core/java/android/bluetooth/BluetoothA2dp.java b/core/java/android/bluetooth/BluetoothA2dp.java
index 6fdf3b4..ceac826 100644
--- a/core/java/android/bluetooth/BluetoothA2dp.java
+++ b/core/java/android/bluetooth/BluetoothA2dp.java
@@ -18,13 +18,12 @@ package android.bluetooth;
 
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
-import android.content.ComponentName;
 import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
 import android.os.IBinder;
 import android.os.ParcelUuid;
 import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.server.BluetoothA2dpService;
 import android.util.Log;
 
 import java.util.ArrayList;
@@ -104,90 +103,37 @@ public final class BluetoothA2dp implements BluetoothProfile {
      */
     public static final int STATE_NOT_PLAYING   =  11;
 
-    private Context mContext;
     private ServiceListener mServiceListener;
     private IBluetoothA2dp mService;
     private BluetoothAdapter mAdapter;
 
-    final private IBluetoothStateChangeCallback mBluetoothStateChangeCallback =
-            new IBluetoothStateChangeCallback.Stub() {
-                public void onBluetoothStateChange(boolean up) {
-                    if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up);
-                    if (!up) {
-                        if (VDBG) Log.d(TAG,"Unbinding service...");
-                        synchronized (mConnection) {
-                            try {
-                                mService = null;
-                                mContext.unbindService(mConnection);
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    } else {
-                        synchronized (mConnection) {
-                            try {
-                                if (mService == null) {
-                                    if (VDBG) Log.d(TAG,"Binding service...");
-                                    if (!mContext.bindService(new Intent(IBluetoothA2dp.class.getName()), mConnection, 0)) {
-                                        Log.e(TAG, "Could not bind to Bluetooth A2DP Service");
-                                    }
-                                }
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    }
-                }
-        };
     /**
      * Create a BluetoothA2dp proxy object for interacting with the local
      * Bluetooth A2DP service.
      *
      */
     /*package*/ BluetoothA2dp(Context context, ServiceListener l) {
-        mContext = context;
+        IBinder b = ServiceManager.getService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE);
         mServiceListener = l;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.registerStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (RemoteException e) {
-                Log.e(TAG,"",e);
+        if (b != null) {
+            mService = IBluetoothA2dp.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.A2DP, this);
             }
-        }
+        } else {
+            Log.w(TAG, "Bluetooth A2DP service not available!");
 
-        if (!context.bindService(new Intent(IBluetoothA2dp.class.getName()), mConnection, 0)) {
-            Log.e(TAG, "Could not bind to Bluetooth A2DP Service");
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mService = null;
         }
     }
 
     /*package*/ void close() {
         mServiceListener = null;
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (Exception e) {
-                Log.e(TAG,"",e);
-            }
-        }
-
-        synchronized (mConnection) {
-            if (mService != null) {
-                try {
-                    mService = null;
-                    mContext.unbindService(mConnection);
-                } catch (Exception re) {
-                    Log.e(TAG,"",re);
-                }
-            }
-        }
     }
 
-    public void finalize() {
-        close();
-    }
     /**
      * Initiate connection to a profile of the remote bluetooth device.
      *
@@ -402,6 +348,67 @@ public final class BluetoothA2dp implements BluetoothProfile {
     }
 
     /**
+     * Initiate suspend from an A2DP sink.
+     *
+     * <p> This API will return false in scenarios like the A2DP
+     * device is not in connected state etc. When this API returns,
+     * true, it is guaranteed that {@link #ACTION_CONNECTION_STATE_CHANGED}
+     * intent will be broadcasted with the state. Users can get the
+     * state of the A2DP device from this intent.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     * permission.
+     *
+     * @param device Remote A2DP sink
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean suspendSink(BluetoothDevice device) {
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.suspendSink(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
+     * Initiate resume from a suspended A2DP sink.
+     *
+     * <p> This API will return false in scenarios like the A2DP
+     * device is not in suspended state etc. When this API returns,
+     * true, it is guaranteed that {@link #ACTION_SINK_STATE_CHANGED}
+     * intent will be broadcasted with the state. Users can get the
+     * state of the A2DP device from this intent.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
+     *
+     * @param device Remote A2DP sink
+     * @return false on immediate error,
+     *               true otherwise
+     * @hide
+     */
+    public boolean resumeSink(BluetoothDevice device) {
+        if (mService != null && isEnabled()
+            && isValidDevice(device)) {
+            try {
+                return mService.resumeSink(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
+                return false;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return false;
+    }
+
+    /**
      * This function checks if the remote device is an AVCRP
      * target and thus whether we should send volume keys
      * changes or not.
@@ -422,6 +429,23 @@ public final class BluetoothA2dp implements BluetoothProfile {
     }
 
     /**
+     * Allow or disallow incoming connection
+     * @param device Sink
+     * @param value True / False
+     * @return Success or Failure of the binder call.
+     * @hide
+     */
+    public boolean allowIncomingConnect(BluetoothDevice device, boolean value) {
+        if (DBG) log("allowIncomingConnect(" + device + ":" + value + ")");
+        try {
+            return mService.allowIncomingConnect(device, value);
+        } catch (RemoteException e) {
+            Log.e(TAG, "", e);
+            return false;
+        }
+    }
+
+    /**
      * Helper for converting a state to a string.
      *
      * For debug use only - strings are not internationalized.
@@ -446,24 +470,6 @@ public final class BluetoothA2dp implements BluetoothProfile {
         }
     }
 
-    private ServiceConnection mConnection = new ServiceConnection() {
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            if (DBG) Log.d(TAG, "Proxy object connected");
-            mService = IBluetoothA2dp.Stub.asInterface(service);
-
-            if (mServiceListener != null) {
-                mServiceListener.onServiceConnected(BluetoothProfile.A2DP, BluetoothA2dp.this);
-            }
-        }
-        public void onServiceDisconnected(ComponentName className) {
-            if (DBG) Log.d(TAG, "Proxy object disconnected");
-            mService = null;
-            if (mServiceListener != null) {
-                mServiceListener.onServiceDisconnected(BluetoothProfile.A2DP);
-            }
-        }
-    };
-
     private boolean isEnabled() {
        if (mAdapter.getState() == BluetoothAdapter.STATE_ON) return true;
        return false;
diff --git a/core/java/android/bluetooth/BluetoothAdapter.java b/core/java/android/bluetooth/BluetoothAdapter.java
index 64cc2d8..f9e1fb3 100644
--- a/core/java/android/bluetooth/BluetoothAdapter.java
+++ b/core/java/android/bluetooth/BluetoothAdapter.java
@@ -31,7 +31,6 @@ import android.util.Log;
 import android.util.Pair;
 
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
@@ -345,7 +344,7 @@ public final class BluetoothAdapter {
     public static final int STATE_DISCONNECTING = 3;
 
     /** @hide */
-    public static final String BLUETOOTH_MANAGER_SERVICE = "bluetooth_manager";
+    public static final String BLUETOOTH_SERVICE = "bluetooth";
 
     private static final int ADDRESS_LENGTH = 17;
 
@@ -355,7 +354,6 @@ public final class BluetoothAdapter {
      */
     private static BluetoothAdapter sAdapter;
 
-    private final IBluetoothManager mManagerService;
     private IBluetooth mService;
 
     private Handler mServiceRecordHandler;
@@ -370,12 +368,10 @@ public final class BluetoothAdapter {
      */
     public static synchronized BluetoothAdapter getDefaultAdapter() {
         if (sAdapter == null) {
-            IBinder b = ServiceManager.getService(BLUETOOTH_MANAGER_SERVICE);
+            IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
             if (b != null) {
-                IBluetoothManager managerService = IBluetoothManager.Stub.asInterface(b);
-                sAdapter = new BluetoothAdapter(managerService);
-            } else {
-                Log.e(TAG, "Bluetooth binder is null");
+                IBluetooth service = IBluetooth.Stub.asInterface(b);
+                sAdapter = new BluetoothAdapter(service);
             }
         }
         return sAdapter;
@@ -383,16 +379,13 @@ public final class BluetoothAdapter {
 
     /**
      * Use {@link #getDefaultAdapter} to get the BluetoothAdapter instance.
+     * @hide
      */
-    BluetoothAdapter(IBluetoothManager managerService) {
-
-        if (managerService == null) {
-            throw new IllegalArgumentException("bluetooth manager service is null");
+    public BluetoothAdapter(IBluetooth service) {
+        if (service == null) {
+            throw new IllegalArgumentException("service is null");
         }
-        try {
-            mService = managerService.registerAdapter(mManagerCallback);
-        } catch (RemoteException e) {Log.e(TAG, "", e);}
-        mManagerService = managerService;
+        mService = service;
         mServiceRecordHandler = null;
     }
 
@@ -442,9 +435,7 @@ public final class BluetoothAdapter {
     public boolean isEnabled() {
 
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.isEnabled();
-            }
+            return mService.isEnabled();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -462,18 +453,8 @@ public final class BluetoothAdapter {
      */
     public int getState() {
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null)
-                {
-                    int state=  mService.getState();
-                    if (VDBG) Log.d(TAG, "" + hashCode() + ": getState(). Returning " + state);
-                    return state;
-                }
-                // TODO(BT) there might be a small gap during STATE_TURNING_ON that
-                //          mService is null, handle that case
-            }
+            return mService.getBluetoothState();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
-        if (DBG) Log.d(TAG, "" + hashCode() + ": getState() :  mService = null. Returning STATE_OFF");
         return STATE_OFF;
     }
 
@@ -505,12 +486,8 @@ public final class BluetoothAdapter {
      *         immediate error
      */
     public boolean enable() {
-        if (isEnabled() == true){
-            if (DBG) Log.d(TAG, "enable(): BT is already enabled..!");
-            return true;
-        }
         try {
-            return mManagerService.enable();
+            return mService.enable();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -541,25 +518,7 @@ public final class BluetoothAdapter {
      */
     public boolean disable() {
         try {
-            return mManagerService.disable(true);
-        } catch (RemoteException e) {Log.e(TAG, "", e);}
-        return false;
-    }
-
-    /**
-     * Turn off the local Bluetooth adapter and don't persist the setting.
-     *
-     * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
-     * permission
-     *
-     * @return true to indicate adapter shutdown has begun, or false on
-     *         immediate error
-     * @hide
-     */
-    public boolean disable(boolean persist) {
-
-        try {
-            return mManagerService.disable(persist);
+            return mService.disable(true);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -573,7 +532,7 @@ public final class BluetoothAdapter {
      */
     public String getAddress() {
         try {
-            return mManagerService.getAddress();
+            return mService.getAddress();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
@@ -587,7 +546,7 @@ public final class BluetoothAdapter {
      */
     public String getName() {
         try {
-            return mManagerService.getName();
+            return mService.getName();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
@@ -603,9 +562,7 @@ public final class BluetoothAdapter {
     public ParcelUuid[] getUuids() {
         if (getState() != STATE_ON) return null;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.getUuids();
-            }
+            return mService.getUuids();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
@@ -628,9 +585,7 @@ public final class BluetoothAdapter {
     public boolean setName(String name) {
         if (getState() != STATE_ON) return false;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.setName(name);
-            }
+            return mService.setName(name);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -654,9 +609,7 @@ public final class BluetoothAdapter {
     public int getScanMode() {
         if (getState() != STATE_ON) return SCAN_MODE_NONE;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.getScanMode();
-            }
+            return mService.getScanMode();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return SCAN_MODE_NONE;
     }
@@ -692,9 +645,7 @@ public final class BluetoothAdapter {
     public boolean setScanMode(int mode, int duration) {
         if (getState() != STATE_ON) return false;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.setScanMode(mode, duration);
-            }
+            return mService.setScanMode(mode, duration);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -710,9 +661,7 @@ public final class BluetoothAdapter {
     public int getDiscoverableTimeout() {
         if (getState() != STATE_ON) return -1;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.getDiscoverableTimeout();
-            }
+            return mService.getDiscoverableTimeout();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return -1;
     }
@@ -721,9 +670,7 @@ public final class BluetoothAdapter {
     public void setDiscoverableTimeout(int timeout) {
         if (getState() != STATE_ON) return;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) mService.setDiscoverableTimeout(timeout);
-            }
+            mService.setDiscoverableTimeout(timeout);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
     }
 
@@ -760,9 +707,7 @@ public final class BluetoothAdapter {
     public boolean startDiscovery() {
         if (getState() != STATE_ON) return false;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.startDiscovery();
-            }
+            return mService.startDiscovery();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -787,9 +732,7 @@ public final class BluetoothAdapter {
     public boolean cancelDiscovery() {
         if (getState() != STATE_ON) return false;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.cancelDiscovery();
-            }
+            return mService.cancelDiscovery();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -816,9 +759,7 @@ public final class BluetoothAdapter {
     public boolean isDiscovering() {
         if (getState() != STATE_ON) return false;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null ) return mService.isDiscovering();
-            }
+            return mService.isDiscovering();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -836,13 +777,10 @@ public final class BluetoothAdapter {
      */
     public Set<BluetoothDevice> getBondedDevices() {
         if (getState() != STATE_ON) {
-            return toDeviceSet(new BluetoothDevice[0]);
+            return toDeviceSet(new String[0]);
         }
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return toDeviceSet(mService.getBondedDevices());
-            }
-            return toDeviceSet(new BluetoothDevice[0]);
+            return toDeviceSet(mService.listBonds());
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
@@ -863,9 +801,7 @@ public final class BluetoothAdapter {
     public int getConnectionState() {
         if (getState() != STATE_ON) return BluetoothAdapter.STATE_DISCONNECTED;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.getAdapterConnectionState();
-            }
+            return mService.getAdapterConnectionState();
         } catch (RemoteException e) {Log.e(TAG, "getConnectionState:", e);}
         return BluetoothAdapter.STATE_DISCONNECTED;
     }
@@ -888,9 +824,7 @@ public final class BluetoothAdapter {
     public int getProfileConnectionState(int profile) {
         if (getState() != STATE_ON) return BluetoothProfile.STATE_DISCONNECTED;
         try {
-            synchronized(mManagerCallback) {
-                if (mService != null) return mService.getProfileConnectionState(profile);
-            }
+            return mService.getProfileConnectionState(profile);
         } catch (RemoteException e) {
             Log.e(TAG, "getProfileConnectionState:", e);
         }
@@ -898,6 +832,51 @@ public final class BluetoothAdapter {
     }
 
     /**
+    /**
+     * Picks RFCOMM channels until none are left.
+     * Avoids reserved channels.
+     */
+    private static class RfcommChannelPicker {
+        private static final int[] RESERVED_RFCOMM_CHANNELS =  new int[] {
+            10,  // HFAG
+            11,  // HSAG
+            12,  // OPUSH
+            19,  // PBAP
+        };
+        private static LinkedList<Integer> sChannels;  // master list of non-reserved channels
+        private static Random sRandom;
+
+        private final LinkedList<Integer> mChannels;  // local list of channels left to try
+
+        private final UUID mUuid;
+
+        public RfcommChannelPicker(UUID uuid) {
+            synchronized (RfcommChannelPicker.class) {
+                if (sChannels == null) {
+                    // lazy initialization of non-reserved rfcomm channels
+                    sChannels = new LinkedList<Integer>();
+                    for (int i = 1; i <= BluetoothSocket.MAX_RFCOMM_CHANNEL; i++) {
+                        sChannels.addLast(new Integer(i));
+                    }
+                    for (int reserved : RESERVED_RFCOMM_CHANNELS) {
+                        sChannels.remove(new Integer(reserved));
+                    }
+                    sRandom = new Random();
+                }
+                mChannels = (LinkedList<Integer>)sChannels.clone();
+            }
+            mUuid = uuid;
+        }
+        /* Returns next random channel, or -1 if we're out */
+        public int nextChannel() {
+            if (mChannels.size() == 0) {
+                return -1;
+            }
+            return mChannels.remove(sRandom.nextInt(mChannels.size()));
+        }
+    }
+
+    /**
      * Create a listening, secure RFCOMM Bluetooth socket.
      * <p>A remote device connecting to this socket will be authenticated and
      * communication on this socket will be encrypted.
@@ -916,10 +895,10 @@ public final class BluetoothAdapter {
                 BluetoothSocket.TYPE_RFCOMM, true, true, channel);
         int errno = socket.mSocket.bindListen();
         if (errno != 0) {
-            //TODO(BT): Throw the same exception error code
-            // that the previous code was using.
-            //socket.mSocket.throwErrnoNative(errno);
-            throw new IOException("Error: " + errno);
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
         }
         return socket;
     }
@@ -948,15 +927,7 @@ public final class BluetoothAdapter {
      */
     public BluetoothServerSocket listenUsingRfcommWithServiceRecord(String name, UUID uuid)
             throws IOException {
-        return createNewRfcommSocketAndRecord(name, -1, uuid, true, true);
-    }
-
-    /**
-     * @hide
-     */
-    public BluetoothServerSocket listenUsingRfcommWithServiceRecordOn(String name, int port, UUID uuid)
-            throws IOException {
-        return createNewRfcommSocketAndRecord(name, port, uuid, true, true);
+        return createNewRfcommSocketAndRecord(name, uuid, true, true);
     }
 
     /**
@@ -987,7 +958,7 @@ public final class BluetoothAdapter {
      */
     public BluetoothServerSocket listenUsingInsecureRfcommWithServiceRecord(String name, UUID uuid)
             throws IOException {
-        return createNewRfcommSocketAndRecord(name, -1, uuid, false, false);
+        return createNewRfcommSocketAndRecord(name, uuid, false, false);
     }
 
      /**
@@ -1025,23 +996,69 @@ public final class BluetoothAdapter {
      */
     public BluetoothServerSocket listenUsingEncryptedRfcommWithServiceRecord(
             String name, UUID uuid) throws IOException {
-        return createNewRfcommSocketAndRecord(name, -1, uuid, false, true);
+        return createNewRfcommSocketAndRecord(name, uuid, false, true);
     }
 
-
-    private BluetoothServerSocket createNewRfcommSocketAndRecord(String name, int port, UUID uuid,
+    private BluetoothServerSocket createNewRfcommSocketAndRecord(String name, UUID uuid,
             boolean auth, boolean encrypt) throws IOException {
+        RfcommChannelPicker picker = new RfcommChannelPicker(uuid);
+
         BluetoothServerSocket socket;
-        socket = new BluetoothServerSocket(BluetoothSocket.TYPE_RFCOMM, auth,
-                        encrypt, port, new ParcelUuid(uuid));
-        socket.setServiceName(name);
-        int errno = socket.mSocket.bindListen();
-        if (errno != 0) {
-            //TODO(BT): Throw the same exception error code
-            // that the previous code was using.
-            //socket.mSocket.throwErrnoNative(errno);
-            throw new IOException("Error: " + errno);
+        int channel;
+        int errno;
+        while (true) {
+            channel = picker.nextChannel();
+
+            if (channel == -1) {
+                throw new IOException("No available channels");
+            }
+
+            socket = new BluetoothServerSocket(
+                    BluetoothSocket.TYPE_RFCOMM, auth, encrypt, channel);
+            errno = socket.mSocket.bindListen();
+            if (errno == 0) {
+                if (DBG) Log.d(TAG, "listening on RFCOMM channel " + channel);
+                break;  // success
+            } else if (errno == BluetoothSocket.EADDRINUSE) {
+                if (DBG) Log.d(TAG, "RFCOMM channel " + channel + " in use");
+                try {
+                    socket.close();
+                } catch (IOException e) {}
+                continue;  // try another channel
+            } else {
+                try {
+                    socket.close();
+                } catch (IOException e) {}
+                socket.mSocket.throwErrnoNative(errno);  // Exception as a result of bindListen()
+            }
         }
+
+        int handle = -1;
+        try {
+            handle = mService.addRfcommServiceRecord(name, new ParcelUuid(uuid), channel,
+                    new Binder());
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
+        if (handle == -1) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            throw new IOException("Not able to register SDP record for " + name);
+        }
+
+        if (mServiceRecordHandler == null) {
+            mServiceRecordHandler = new Handler(Looper.getMainLooper()) {
+                    public void handleMessage(Message msg) {
+                        /* handle socket closing */
+                        int handle = msg.what;
+                        try {
+                            if (DBG) Log.d(TAG, "Removing service record " +
+                                           Integer.toHexString(handle));
+                            mService.removeServiceRecord(handle);
+                        } catch (RemoteException e) {Log.e(TAG, "", e);}
+                    }
+                };
+        }
+        socket.setCloseHandler(mServiceRecordHandler, handle);
         return socket;
     }
 
@@ -1058,10 +1075,10 @@ public final class BluetoothAdapter {
                 BluetoothSocket.TYPE_RFCOMM, false, false, port);
         int errno = socket.mSocket.bindListen();
         if (errno != 0) {
-            //TODO(BT): Throw the same exception error code
-            // that the previous code was using.
-            //socket.mSocket.throwErrnoNative(errno);
-            throw new IOException("Error: " + errno);
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
         }
         return socket;
     }
@@ -1079,11 +1096,11 @@ public final class BluetoothAdapter {
         BluetoothServerSocket socket = new BluetoothServerSocket(
                 BluetoothSocket.TYPE_RFCOMM, false, true, port);
         int errno = socket.mSocket.bindListen();
-        if (errno < 0) {
-            //TODO(BT): Throw the same exception error code
-            // that the previous code was using.
-            //socket.mSocket.throwErrnoNative(errno);
-            throw new IOException("Error: " + errno);
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
         }
         return socket;
     }
@@ -1100,10 +1117,11 @@ public final class BluetoothAdapter {
         BluetoothServerSocket socket = new BluetoothServerSocket(
                 BluetoothSocket.TYPE_SCO, false, false, -1);
         int errno = socket.mSocket.bindListen();
-        if (errno < 0) {
-            //TODO(BT): Throw the same exception error code
-            // that the previous code was using.
-            //socket.mSocket.throwErrnoNative(errno);
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
         }
         return socket;
     }
@@ -1118,8 +1136,6 @@ public final class BluetoothAdapter {
      */
     public Pair<byte[], byte[]> readOutOfBandData() {
         if (getState() != STATE_ON) return null;
-        //TODO(BT
-        /*
         try {
             byte[] hash;
             byte[] randomizer;
@@ -1137,7 +1153,7 @@ public final class BluetoothAdapter {
             }
             return new Pair<byte[], byte[]>(hash, randomizer);
 
-        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
 
@@ -1217,53 +1233,14 @@ public final class BluetoothAdapter {
         }
     }
 
-    final private IBluetoothManagerCallback mManagerCallback =
-        new IBluetoothManagerCallback.Stub() {
-            public void onBluetoothServiceUp(IBluetooth bluetoothService) {
-                if (VDBG) Log.d(TAG, "onBluetoothServiceUp: " + bluetoothService);
-                synchronized (mManagerCallback) {
-                    mService = bluetoothService;
-                    for (IBluetoothManagerCallback cb : mProxyServiceStateCallbacks ){
-                        try {
-                            if (cb != null) {
-                                cb.onBluetoothServiceUp(bluetoothService);
-                            } else {
-                                Log.d(TAG, "onBluetoothServiceUp: cb is null!!!");
-                            }
-                        } catch (Exception e)  { Log.e(TAG,"",e);}
-                    }
-                }
-            }
-
-            public void onBluetoothServiceDown() {
-                if (VDBG) Log.d(TAG, "onBluetoothServiceDown: " + mService);
-                synchronized (mManagerCallback) {
-                    mService = null;
-                    for (IBluetoothManagerCallback cb : mProxyServiceStateCallbacks ){
-                        try {
-                            if (cb != null) {
-                                cb.onBluetoothServiceDown();
-                            } else {
-                                Log.d(TAG, "onBluetoothServiceDown: cb is null!!!");
-                            }
-                        } catch (Exception e)  { Log.e(TAG,"",e);}
-                    }
-                }
-            }
-    };
-
     /**
      * Enable the Bluetooth Adapter, but don't auto-connect devices
      * and don't persist state. Only for use by system applications.
      * @hide
      */
     public boolean enableNoAutoConnect() {
-        if (isEnabled() == true){
-            if (DBG) Log.d(TAG, "enableNoAutoConnect(): BT is already enabled..!");
-            return true;
-        }
         try {
-            return mManagerService.enableNoAutoConnect();
+            return mService.enableNoAutoConnect();
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -1301,14 +1278,12 @@ public final class BluetoothAdapter {
                                                    BluetoothStateChangeCallback callback) {
         if (callback == null) return false;
 
-        //TODO(BT)
-        /*
         try {
             return mService.changeApplicationBluetoothState(on, new
                     StateChangeCallbackWrapper(callback), new Binder());
         } catch (RemoteException e) {
             Log.e(TAG, "changeBluetoothState", e);
-        }*/
+        }
         return false;
     }
 
@@ -1336,19 +1311,12 @@ public final class BluetoothAdapter {
         }
     }
 
-    private Set<BluetoothDevice> toDeviceSet(BluetoothDevice[] devices) {
-        Set<BluetoothDevice> deviceSet = new HashSet<BluetoothDevice>(Arrays.asList(devices));
-        return Collections.unmodifiableSet(deviceSet);
-    }
-
-    protected void finalize() throws Throwable {
-        try {
-            mManagerService.unregisterAdapter(mManagerCallback);
-        } catch (RemoteException e) {
-            Log.e(TAG, "", e);
-        } finally {
-            super.finalize();
+    private Set<BluetoothDevice> toDeviceSet(String[] addresses) {
+        Set<BluetoothDevice> devices = new HashSet<BluetoothDevice>(addresses.length);
+        for (int i = 0; i < addresses.length; i++) {
+            devices.add(getRemoteDevice(addresses[i]));
         }
+        return Collections.unmodifiableSet(devices);
     }
 
 
@@ -1382,27 +1350,4 @@ public final class BluetoothAdapter {
         }
         return true;
     }
-
-    /*package*/ IBluetoothManager getBluetoothManager() {
-            return mManagerService;
-    }
-
-    private ArrayList<IBluetoothManagerCallback> mProxyServiceStateCallbacks = new ArrayList<IBluetoothManagerCallback>();
-
-    /*package*/ IBluetooth getBluetoothService(IBluetoothManagerCallback cb) {
-        synchronized (mManagerCallback) {
-            if (cb == null) {
-                Log.w(TAG, "getBluetoothService() called with no BluetoothManagerCallback");
-            } else if (!mProxyServiceStateCallbacks.contains(cb)) {
-                mProxyServiceStateCallbacks.add(cb);
-            }
-        }
-        return mService;
-    }
-
-    /*package*/ void removeServiceStateCallback(IBluetoothManagerCallback cb) {
-        synchronized (mManagerCallback) {
-            mProxyServiceStateCallbacks.remove(cb);
-        }
-    }
 }
diff --git a/core/java/android/bluetooth/BluetoothAudioGateway.java b/core/java/android/bluetooth/BluetoothAudioGateway.java
new file mode 100644
index 0000000..9351393
--- /dev/null
+++ b/core/java/android/bluetooth/BluetoothAudioGateway.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import java.lang.Thread;
+
+import android.os.Message;
+import android.os.Handler;
+import android.util.Log;
+
+/**
+ * Listens for incoming RFCOMM connection for the headset / handsfree service.
+ *
+ * TODO: Use the new generic BluetoothSocket class instead of this legacy code
+ *
+ * @hide
+ */
+public final class BluetoothAudioGateway {
+    private static final String TAG = "BT Audio Gateway";
+    private static final boolean DBG = false;
+
+    private int mNativeData;
+    static { classInitNative(); }
+
+    /* in */
+    private int mHandsfreeAgRfcommChannel = -1;
+    private int mHeadsetAgRfcommChannel   = -1;
+
+    /* out - written by native code */
+    private String mConnectingHeadsetAddress;
+    private int mConnectingHeadsetRfcommChannel; /* -1 when not connected */
+    private int mConnectingHeadsetSocketFd;
+    private String mConnectingHandsfreeAddress;
+    private int mConnectingHandsfreeRfcommChannel; /* -1 when not connected */
+    private int mConnectingHandsfreeSocketFd;
+    private int mTimeoutRemainingMs; /* in/out */
+
+    private final BluetoothAdapter mAdapter;
+
+    public static final int DEFAULT_HF_AG_CHANNEL = 10;
+    public static final int DEFAULT_HS_AG_CHANNEL = 11;
+
+    public BluetoothAudioGateway(BluetoothAdapter adapter) {
+        this(adapter, DEFAULT_HF_AG_CHANNEL, DEFAULT_HS_AG_CHANNEL);
+    }
+
+    public BluetoothAudioGateway(BluetoothAdapter adapter, int handsfreeAgRfcommChannel,
+                int headsetAgRfcommChannel) {
+        mAdapter = adapter;
+        mHandsfreeAgRfcommChannel = handsfreeAgRfcommChannel;
+        mHeadsetAgRfcommChannel = headsetAgRfcommChannel;
+        initializeNativeDataNative();
+    }
+
+    private Thread mConnectThead;
+    private volatile boolean mInterrupted;
+    private static final int SELECT_WAIT_TIMEOUT = 1000;
+
+    private Handler mCallback;
+
+    public class IncomingConnectionInfo {
+        public BluetoothAdapter mAdapter;
+        public BluetoothDevice mRemoteDevice;
+        public int mSocketFd;
+        public int mRfcommChan;
+        IncomingConnectionInfo(BluetoothAdapter adapter, BluetoothDevice remoteDevice,
+                int socketFd, int rfcommChan) {
+            mAdapter = adapter;
+            mRemoteDevice = remoteDevice;
+            mSocketFd = socketFd;
+            mRfcommChan = rfcommChan;
+        }
+    }
+
+    public static final int MSG_INCOMING_HEADSET_CONNECTION   = 100;
+    public static final int MSG_INCOMING_HANDSFREE_CONNECTION = 101;
+
+    public synchronized boolean start(Handler callback) {
+
+        if (mConnectThead == null) {
+            mCallback = callback;
+            mConnectThead = new Thread(TAG) {
+                    public void run() {
+                        if (DBG) log("Connect Thread starting");
+                        while (!mInterrupted) {
+                            //Log.i(TAG, "waiting for connect");
+                            mConnectingHeadsetRfcommChannel = -1;
+                            mConnectingHandsfreeRfcommChannel = -1;
+                            if (waitForHandsfreeConnectNative(SELECT_WAIT_TIMEOUT) == false) {
+                                if (mTimeoutRemainingMs > 0) {
+                                    try {
+                                        Log.i(TAG, "select thread timed out, but " + 
+                                              mTimeoutRemainingMs + "ms of waiting remain.");
+                                        Thread.sleep(mTimeoutRemainingMs);
+                                    } catch (InterruptedException e) {
+                                        Log.i(TAG, "select thread was interrupted (2), exiting");
+                                        mInterrupted = true;
+                                    }
+                                }
+                            }
+                            else {
+                                Log.i(TAG, "connect notification!");
+                                /* A device connected (most likely just one, but 
+                                   it is possible for two separate devices, one 
+                                   a headset and one a handsfree, to connect
+                                   simultaneously. 
+                                */
+                                if (mConnectingHeadsetRfcommChannel >= 0) {
+                                    Log.i(TAG, "Incoming connection from headset " + 
+                                          mConnectingHeadsetAddress + " on channel " + 
+                                          mConnectingHeadsetRfcommChannel);
+                                    Message msg = Message.obtain(mCallback);
+                                    msg.what = MSG_INCOMING_HEADSET_CONNECTION;
+                                    msg.obj = new IncomingConnectionInfo(
+                                        mAdapter,
+                                        mAdapter.getRemoteDevice(mConnectingHeadsetAddress),
+                                        mConnectingHeadsetSocketFd,
+                                        mConnectingHeadsetRfcommChannel);
+                                    msg.sendToTarget();
+                                }
+                                if (mConnectingHandsfreeRfcommChannel >= 0) {
+                                    Log.i(TAG, "Incoming connection from handsfree " + 
+                                          mConnectingHandsfreeAddress + " on channel " + 
+                                          mConnectingHandsfreeRfcommChannel);
+                                    Message msg = Message.obtain();
+                                    msg.setTarget(mCallback);
+                                    msg.what = MSG_INCOMING_HANDSFREE_CONNECTION;
+                                    msg.obj = new IncomingConnectionInfo(
+                                        mAdapter,
+                                        mAdapter.getRemoteDevice(mConnectingHandsfreeAddress),
+                                        mConnectingHandsfreeSocketFd,
+                                        mConnectingHandsfreeRfcommChannel);
+                                    msg.sendToTarget();
+                                }
+                            }
+                        }
+                        if (DBG) log("Connect Thread finished");
+                    }
+                };
+
+            if (setUpListeningSocketsNative() == false) {
+                Log.e(TAG, "Could not set up listening socket, exiting");
+                return false;
+            }
+
+            mInterrupted = false;
+            mConnectThead.start();
+        }
+
+        return true;
+    }
+
+    public synchronized void stop() {
+        if (mConnectThead != null) {
+            if (DBG) log("stopping Connect Thread");
+            mInterrupted = true;
+            try {
+                mConnectThead.interrupt();
+                if (DBG) log("waiting for thread to terminate");
+                mConnectThead.join();
+                mConnectThead = null;
+                mCallback = null;
+                tearDownListeningSocketsNative();
+            } catch (InterruptedException e) {
+                Log.w(TAG, "Interrupted waiting for Connect Thread to join");
+            }
+        }
+    }
+
+    protected void finalize() throws Throwable {
+        try {
+            cleanupNativeDataNative();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private static native void classInitNative();
+    private native void initializeNativeDataNative();
+    private native void cleanupNativeDataNative();
+    private native boolean waitForHandsfreeConnectNative(int timeoutMs);
+    private native boolean setUpListeningSocketsNative();
+    private native void tearDownListeningSocketsNative();
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/core/java/android/bluetooth/BluetoothDevice.java b/core/java/android/bluetooth/BluetoothDevice.java
index 74d50f1..4f8d53a 100644
--- a/core/java/android/bluetooth/BluetoothDevice.java
+++ b/core/java/android/bluetooth/BluetoothDevice.java
@@ -487,29 +487,16 @@ public final class BluetoothDevice implements Parcelable {
     /*package*/ static IBluetooth getService() {
         synchronized (BluetoothDevice.class) {
             if (sService == null) {
-                BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-                sService = adapter.getBluetoothService(mStateChangeCallback);
+                IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+                if (b == null) {
+                    throw new RuntimeException("Bluetooth service not available");
+                }
+                sService = IBluetooth.Stub.asInterface(b);
             }
         }
         return sService;
     }
 
-    static IBluetoothManagerCallback mStateChangeCallback = new IBluetoothManagerCallback.Stub() {
-
-        public void onBluetoothServiceUp(IBluetooth bluetoothService)
-                throws RemoteException {
-            synchronized (BluetoothDevice.class) {
-                sService = bluetoothService;
-            }
-        }
-
-        public void onBluetoothServiceDown()
-            throws RemoteException {
-            synchronized (BluetoothDevice.class) {
-                sService = null;
-            }
-        }
-    };
     /**
      * Create a new BluetoothDevice
      * Bluetooth MAC address must be upper case, such as "00:11:22:33:AA:BB",
@@ -598,7 +585,7 @@ public final class BluetoothDevice implements Parcelable {
             return null;
         }
         try {
-            return sService.getRemoteName(this);
+            return sService.getRemoteName(mAddress);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
@@ -616,7 +603,7 @@ public final class BluetoothDevice implements Parcelable {
             return null;
         }
         try {
-            return sService.getRemoteAlias(this);
+            return sService.getRemoteAlias(mAddress);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
@@ -637,7 +624,7 @@ public final class BluetoothDevice implements Parcelable {
             return false;
         }
         try {
-            return sService.setRemoteAlias(this, alias);
+            return sService.setRemoteAlias(mAddress, alias);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -677,7 +664,7 @@ public final class BluetoothDevice implements Parcelable {
             return false;
         }
         try {
-            return sService.createBond(this);
+            return sService.createBond(mAddress);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -702,11 +689,9 @@ public final class BluetoothDevice implements Parcelable {
      * @hide
      */
     public boolean createBondOutOfBand(byte[] hash, byte[] randomizer) {
-        //TODO(BT)
-        /*
         try {
-            return sService.createBondOutOfBand(this, hash, randomizer);
-        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
+            return sService.createBondOutOfBand(mAddress, hash, randomizer);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
 
@@ -724,11 +709,9 @@ public final class BluetoothDevice implements Parcelable {
      * @hide
      */
     public boolean setDeviceOutOfBandData(byte[] hash, byte[] randomizer) {
-      //TODO(BT)
-      /*
       try {
-        return sService.setDeviceOutOfBandData(this, hash, randomizer);
-      } catch (RemoteException e) {Log.e(TAG, "", e);} */
+        return sService.setDeviceOutOfBandData(mAddress, hash, randomizer);
+      } catch (RemoteException e) {Log.e(TAG, "", e);}
       return false;
     }
 
@@ -745,7 +728,7 @@ public final class BluetoothDevice implements Parcelable {
             return false;
         }
         try {
-            return sService.cancelBondProcess(this);
+            return sService.cancelBondProcess(mAddress);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -766,7 +749,7 @@ public final class BluetoothDevice implements Parcelable {
             return false;
         }
         try {
-            return sService.removeBond(this);
+            return sService.removeBond(mAddress);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
@@ -787,7 +770,7 @@ public final class BluetoothDevice implements Parcelable {
             return BOND_NONE;
         }
         try {
-            return sService.getBondState(this);
+            return sService.getBondState(mAddress);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         catch (NullPointerException npe) {
             // Handle case where bluetooth service proxy
@@ -810,7 +793,7 @@ public final class BluetoothDevice implements Parcelable {
             return null;
         }
         try {
-            int classInt = sService.getRemoteClass(this);
+            int classInt = sService.getRemoteClass(mAddress);
             if (classInt == BluetoothClass.ERROR) return null;
             return new BluetoothClass(classInt);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
@@ -823,13 +806,11 @@ public final class BluetoothDevice implements Parcelable {
      * @hide
      */
     public boolean getTrustState() {
-        //TODO(BT)
-        /*
         try {
-            return sService.getTrustState(this);
+            return sService.getTrustState(mAddress);
         } catch (RemoteException e) {
             Log.e(TAG, "", e);
-        }*/
+        }
         return false;
     }
 
@@ -840,13 +821,11 @@ public final class BluetoothDevice implements Parcelable {
      * @hide
      */
     public boolean setTrust(boolean value) {
-        //TODO(BT)
-        /*
         try {
-            return sService.setTrust(this, value);
+            return sService.setTrust(mAddress, value);
         } catch (RemoteException e) {
             Log.e(TAG, "", e);
-        }*/
+        }
         return false;
     }
 
@@ -868,7 +847,7 @@ public final class BluetoothDevice implements Parcelable {
              return null;
          }
         try {
-            return sService.getRemoteUuids(this);
+            return sService.getRemoteUuids(mAddress);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return null;
     }
@@ -890,18 +869,16 @@ public final class BluetoothDevice implements Parcelable {
       */
      public boolean fetchUuidsWithSdp() {
         try {
-            return sService.fetchRemoteUuids(this);
+            return sService.fetchRemoteUuids(mAddress, null, null);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
             return false;
     }
 
     /** @hide */
     public int getServiceChannel(ParcelUuid uuid) {
-        //TODO(BT)
-        /*
          try {
-             return sService.getRemoteServiceChannel(this, uuid);
-         } catch (RemoteException e) {Log.e(TAG, "", e);}*/
+             return sService.getRemoteServiceChannel(mAddress, uuid);
+         } catch (RemoteException e) {Log.e(TAG, "", e);}
          return BluetoothDevice.ERROR;
     }
 
@@ -912,18 +889,16 @@ public final class BluetoothDevice implements Parcelable {
             return false;
         }
         try {
-            return sService.setPin(this, true, pin.length, pin);
+            return sService.setPin(mAddress, pin);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
 
     /** @hide */
     public boolean setPasskey(int passkey) {
-        //TODO(BT)
-        /*
         try {
-            return sService.setPasskey(this, true, 4, passkey);
-        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
+            return sService.setPasskey(mAddress, passkey);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
 
@@ -934,18 +909,16 @@ public final class BluetoothDevice implements Parcelable {
             return false;
         }
         try {
-            return sService.setPairingConfirmation(this, confirm);
+            return sService.setPairingConfirmation(mAddress, confirm);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
 
     /** @hide */
     public boolean setRemoteOutOfBandData() {
-        // TODO(BT)
-        /*
         try {
-          return sService.setRemoteOutOfBandData(this);
-      } catch (RemoteException e) {Log.e(TAG, "", e);}*/
+          return sService.setRemoteOutOfBandData(mAddress);
+      } catch (RemoteException e) {Log.e(TAG, "", e);}
       return false;
     }
 
@@ -956,18 +929,16 @@ public final class BluetoothDevice implements Parcelable {
             return false;
         }
         try {
-            return sService.cancelBondProcess(this);
+            return sService.cancelPairingUserInput(mAddress);
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
 
     /** @hide */
     public boolean isBluetoothDock() {
-        // TODO(BT)
-        /*
         try {
-            return sService.isBluetoothDock(this);
-        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
+            return sService.isBluetoothDock(mAddress);
+        } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
 
diff --git a/core/java/android/bluetooth/BluetoothDeviceProfileState.java b/core/java/android/bluetooth/BluetoothDeviceProfileState.java
new file mode 100644
index 0000000..8763893
--- /dev/null
+++ b/core/java/android/bluetooth/BluetoothDeviceProfileState.java
@@ -0,0 +1,1349 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Message;
+import android.bluetooth.BluetoothAdapter;
+import android.os.PowerManager;
+import android.server.BluetoothA2dpService;
+import android.server.BluetoothService;
+import android.util.Log;
+import android.util.Pair;
+
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+import java.util.Set;
+
+/**
+ * This class is the Profile connection state machine associated with a remote
+ * device. When the device bonds an instance of this class is created.
+ * This tracks incoming and outgoing connections of all the profiles. Incoming
+ * connections are preferred over outgoing connections and HFP preferred over
+ * A2DP. When the device is unbonded, the instance is removed.
+ *
+ * States:
+ * {@link BondedDevice}: This state represents a bonded device. When in this
+ * state none of the profiles are in transition states.
+ *
+ * {@link OutgoingHandsfree}: Handsfree profile connection is in a transition
+ * state because of a outgoing Connect or Disconnect.
+ *
+ * {@link IncomingHandsfree}: Handsfree profile connection is in a transition
+ * state because of a incoming Connect or Disconnect.
+ *
+ * {@link IncomingA2dp}: A2dp profile connection is in a transition
+ * state because of a incoming Connect or Disconnect.
+ *
+ * {@link OutgoingA2dp}: A2dp profile connection is in a transition
+ * state because of a outgoing Connect or Disconnect.
+ *
+ * Todo(): Write tests for this class, when the Android Mock support is completed.
+ * @hide
+ */
+public final class BluetoothDeviceProfileState extends StateMachine {
+    private static final String TAG = "BluetoothDeviceProfileState";
+    private static final boolean DBG = false;
+
+    // TODO(): Restructure the state machine to make it scalable with regard to profiles.
+    public static final int CONNECT_HFP_OUTGOING = 1;
+    public static final int CONNECT_HFP_INCOMING = 2;
+    public static final int CONNECT_A2DP_OUTGOING = 3;
+    public static final int CONNECT_A2DP_INCOMING = 4;
+    public static final int CONNECT_HID_OUTGOING = 5;
+    public static final int CONNECT_HID_INCOMING = 6;
+
+    public static final int DISCONNECT_HFP_OUTGOING = 50;
+    private static final int DISCONNECT_HFP_INCOMING = 51;
+    public static final int DISCONNECT_A2DP_OUTGOING = 52;
+    public static final int DISCONNECT_A2DP_INCOMING = 53;
+    public static final int DISCONNECT_HID_OUTGOING = 54;
+    public static final int DISCONNECT_HID_INCOMING = 55;
+    public static final int DISCONNECT_PBAP_OUTGOING = 56;
+
+    public static final int UNPAIR = 100;
+    public static final int AUTO_CONNECT_PROFILES = 101;
+    public static final int TRANSITION_TO_STABLE = 102;
+    public static final int CONNECT_OTHER_PROFILES = 103;
+    private static final int CONNECTION_ACCESS_REQUEST_REPLY = 104;
+    private static final int CONNECTION_ACCESS_REQUEST_EXPIRY = 105;
+
+    public static final int CONNECT_OTHER_PROFILES_DELAY = 4000; // 4 secs
+    private static final int CONNECTION_ACCESS_REQUEST_EXPIRY_TIMEOUT = 7000; // 7 secs
+    private static final int CONNECTION_ACCESS_UNDEFINED = -1;
+    private static final long INIT_INCOMING_REJECT_TIMER = 1000; // 1 sec
+    private static final long MAX_INCOMING_REJECT_TIMER = 3600 * 1000 * 4; // 4 hours
+
+    private static final String ACCESS_AUTHORITY_PACKAGE = "com.android.settings";
+    private static final String ACCESS_AUTHORITY_CLASS =
+        "com.android.settings.bluetooth.BluetoothPermissionRequest";
+
+    private BondedDevice mBondedDevice = new BondedDevice();
+    private OutgoingHandsfree mOutgoingHandsfree = new OutgoingHandsfree();
+    private IncomingHandsfree mIncomingHandsfree = new IncomingHandsfree();
+    private IncomingA2dp mIncomingA2dp = new IncomingA2dp();
+    private OutgoingA2dp mOutgoingA2dp = new OutgoingA2dp();
+    private OutgoingHid mOutgoingHid = new OutgoingHid();
+    private IncomingHid mIncomingHid = new IncomingHid();
+
+    private Context mContext;
+    private BluetoothService mService;
+    private BluetoothA2dpService mA2dpService;
+    private BluetoothHeadset  mHeadsetService;
+    private BluetoothPbap     mPbapService;
+    private PbapServiceListener mPbap;
+    private BluetoothAdapter mAdapter;
+    private boolean mPbapServiceConnected;
+    private boolean mAutoConnectionPending;
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+
+    private BluetoothDevice mDevice;
+    private int mHeadsetState = BluetoothProfile.STATE_DISCONNECTED;
+    private int mA2dpState = BluetoothProfile.STATE_DISCONNECTED;
+    private long mIncomingRejectTimer;
+    private boolean mConnectionAccessReplyReceived = false;
+    private Pair<Integer, String> mIncomingConnections;
+    private PowerManager.WakeLock mWakeLock;
+    private PowerManager mPowerManager;
+    private boolean mPairingRequestRcvd = false;
+
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (device == null || !device.equals(mDevice)) return;
+
+            if (action.equals(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                int oldState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                // We trust this device now
+                if (newState == BluetoothHeadset.STATE_CONNECTED) {
+                    setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+                }
+                mA2dpState = newState;
+                if (oldState == BluetoothA2dp.STATE_CONNECTED &&
+                    newState == BluetoothA2dp.STATE_DISCONNECTED) {
+                    sendMessage(DISCONNECT_A2DP_INCOMING);
+                }
+                if (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                int oldState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                // We trust this device now
+                if (newState == BluetoothHeadset.STATE_CONNECTED) {
+                    setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+                }
+                mHeadsetState = newState;
+                if (oldState == BluetoothHeadset.STATE_CONNECTED &&
+                    newState == BluetoothHeadset.STATE_DISCONNECTED) {
+                    sendMessage(DISCONNECT_HFP_INCOMING);
+                }
+                if (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                int oldState =
+                    intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                // We trust this device now
+                if (newState == BluetoothHeadset.STATE_CONNECTED) {
+                    setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+                }
+                if (oldState == BluetoothProfile.STATE_CONNECTED &&
+                    newState == BluetoothProfile.STATE_DISCONNECTED) {
+                    sendMessage(DISCONNECT_HID_INCOMING);
+                }
+                if (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED)) {
+                // This is technically not needed, but we can get stuck sometimes.
+                // For example, if incoming A2DP fails, we are not informed by Bluez
+                sendMessage(TRANSITION_TO_STABLE);
+            } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
+                mWakeLock.release();
+                int val = intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT,
+                                             BluetoothDevice.CONNECTION_ACCESS_NO);
+                Message msg = obtainMessage(CONNECTION_ACCESS_REQUEST_REPLY);
+                msg.arg1 = val;
+                sendMessage(msg);
+            } else if (action.equals(BluetoothDevice.ACTION_PAIRING_REQUEST)) {
+                mPairingRequestRcvd = true;
+            } else if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
+                int state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,
+                        BluetoothDevice.ERROR);
+                if (state == BluetoothDevice.BOND_BONDED && mPairingRequestRcvd) {
+                    setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+                    mPairingRequestRcvd = false;
+                } else if (state == BluetoothDevice.BOND_NONE) {
+                    mPairingRequestRcvd = false;
+                }
+            }
+        }
+    };
+
+    private boolean isPhoneDocked(BluetoothDevice autoConnectDevice) {
+        // This works only because these broadcast intents are "sticky"
+        Intent i = mContext.registerReceiver(null, new IntentFilter(Intent.ACTION_DOCK_EVENT));
+        if (i != null) {
+            int state = i.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
+            if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                BluetoothDevice device = i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (device != null && autoConnectDevice.equals(device)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public BluetoothDeviceProfileState(Context context, String address,
+          BluetoothService service, BluetoothA2dpService a2dpService, boolean setTrust) {
+        super(address);
+        mContext = context;
+        mDevice = new BluetoothDevice(address);
+        mService = service;
+        mA2dpService = a2dpService;
+
+        addState(mBondedDevice);
+        addState(mOutgoingHandsfree);
+        addState(mIncomingHandsfree);
+        addState(mIncomingA2dp);
+        addState(mOutgoingA2dp);
+        addState(mOutgoingHid);
+        addState(mIncomingHid);
+        setInitialState(mBondedDevice);
+
+        IntentFilter filter = new IntentFilter();
+        // Fine-grained state broadcasts
+        filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
+        filter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+        filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
+        filter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+
+        mContext.registerReceiver(mBroadcastReceiver, filter);
+
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
+                                BluetoothProfile.HEADSET);
+        // TODO(): Convert PBAP to the new Profile APIs.
+        mPbap = new PbapServiceListener();
+
+        mIncomingConnections = mService.getIncomingState(address);
+        mIncomingRejectTimer = readTimerValue();
+        mPowerManager = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = mPowerManager.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK |
+                                              PowerManager.ACQUIRE_CAUSES_WAKEUP |
+                                              PowerManager.ON_AFTER_RELEASE, TAG);
+        mWakeLock.setReferenceCounted(false);
+
+        if (setTrust) {
+            setTrust(BluetoothDevice.CONNECTION_ACCESS_YES);
+        }
+    }
+
+    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            synchronized(BluetoothDeviceProfileState.this) {
+                mHeadsetService = (BluetoothHeadset) proxy;
+                if (mAutoConnectionPending) {
+                    sendMessage(AUTO_CONNECT_PROFILES);
+                    mAutoConnectionPending = false;
+                }
+            }
+        }
+        public void onServiceDisconnected(int profile) {
+            synchronized(BluetoothDeviceProfileState.this) {
+                mHeadsetService = null;
+            }
+        }
+    };
+
+    private class PbapServiceListener implements BluetoothPbap.ServiceListener {
+        public PbapServiceListener() {
+            mPbapService = new BluetoothPbap(mContext, this);
+        }
+        public void onServiceConnected(BluetoothPbap proxy) {
+            synchronized(BluetoothDeviceProfileState.this) {
+                mPbapServiceConnected = true;
+            }
+        }
+        public void onServiceDisconnected() {
+            synchronized(BluetoothDeviceProfileState.this) {
+                mPbapServiceConnected = false;
+            }
+        }
+    }
+
+    private class BondedDevice extends State {
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering ACL Connected state with: " + getCurrentMessage().what);
+            Message m = new Message();
+            m.copyFrom(getCurrentMessage());
+            sendMessageAtFrontOfQueue(m);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            log("ACL Connected State -> Processing Message: " + message.what);
+            switch(message.what) {
+                case CONNECT_HFP_OUTGOING:
+                case DISCONNECT_HFP_OUTGOING:
+                    transitionTo(mOutgoingHandsfree);
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    transitionTo(mIncomingHandsfree);
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    transitionTo(mIncomingHandsfree);
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                case DISCONNECT_A2DP_OUTGOING:
+                    transitionTo(mOutgoingA2dp);
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                case DISCONNECT_A2DP_INCOMING:
+                    transitionTo(mIncomingA2dp);
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    transitionTo(mOutgoingHid);
+                    break;
+                case CONNECT_HID_INCOMING:
+                case DISCONNECT_HID_INCOMING:
+                    transitionTo(mIncomingHid);
+                    break;
+                case DISCONNECT_PBAP_OUTGOING:
+                    processCommand(DISCONNECT_PBAP_OUTGOING);
+                    break;
+                case UNPAIR:
+                    if (mHeadsetState != BluetoothHeadset.STATE_DISCONNECTED) {
+                        sendMessage(DISCONNECT_HFP_OUTGOING);
+                        deferMessage(message);
+                        break;
+                    } else if (mA2dpState != BluetoothA2dp.STATE_DISCONNECTED) {
+                        sendMessage(DISCONNECT_A2DP_OUTGOING);
+                        deferMessage(message);
+                        break;
+                    } else if (mService.getInputDeviceConnectionState(mDevice) !=
+                            BluetoothInputDevice.STATE_DISCONNECTED) {
+                        sendMessage(DISCONNECT_HID_OUTGOING);
+                        deferMessage(message);
+                        break;
+                    }
+                    processCommand(UNPAIR);
+                    break;
+                case AUTO_CONNECT_PROFILES:
+                    if (isPhoneDocked(mDevice)) {
+                        // Don't auto connect to docks.
+                        break;
+                    } else {
+                        if (mHeadsetService == null) {
+                              mAutoConnectionPending = true;
+                        } else if (mHeadsetService.getPriority(mDevice) ==
+                              BluetoothHeadset.PRIORITY_AUTO_CONNECT &&
+                              mHeadsetService.getDevicesMatchingConnectionStates(
+                                  new int[] {BluetoothProfile.STATE_CONNECTED,
+                                             BluetoothProfile.STATE_CONNECTING,
+                                             BluetoothProfile.STATE_DISCONNECTING}).size() == 0) {
+                            mHeadsetService.connect(mDevice);
+                        }
+                        if (mA2dpService != null &&
+                              mA2dpService.getPriority(mDevice) ==
+                              BluetoothA2dp.PRIORITY_AUTO_CONNECT &&
+                              mA2dpService.getDevicesMatchingConnectionStates(
+                                  new int[] {BluetoothA2dp.STATE_CONNECTED,
+                                             BluetoothProfile.STATE_CONNECTING,
+                                             BluetoothProfile.STATE_DISCONNECTING}).size() == 0) {
+                            mA2dpService.connect(mDevice);
+                        }
+                        if (mService.getInputDevicePriority(mDevice) ==
+                              BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
+                            mService.connectInputDevice(mDevice);
+                        }
+                    }
+                    break;
+                case CONNECT_OTHER_PROFILES:
+                    if (isPhoneDocked(mDevice)) {
+                       break;
+                    }
+                    if (message.arg1 == CONNECT_A2DP_OUTGOING) {
+                        if (mA2dpService != null &&
+                            mA2dpService.getConnectedDevices().size() == 0) {
+                            Log.i(TAG, "A2dp:Connect Other Profiles");
+                            mA2dpService.connect(mDevice);
+                        }
+                    } else if (message.arg1 == CONNECT_HFP_OUTGOING) {
+                        if (mHeadsetService == null) {
+                            deferMessage(message);
+                        } else {
+                            if (mHeadsetService.getConnectedDevices().size() == 0) {
+                                Log.i(TAG, "Headset:Connect Other Profiles");
+                                mHeadsetService.connect(mDevice);
+                            }
+                        }
+                    }
+                    break;
+                case TRANSITION_TO_STABLE:
+                    // ignore.
+                    break;
+                case SM_QUIT_CMD:
+                    mContext.unregisterReceiver(mBroadcastReceiver);
+                    mBroadcastReceiver = null;
+                    mAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mHeadsetService);
+                    mBluetoothProfileServiceListener = null;
+                    mOutgoingHandsfree = null;
+                    mPbap = null;
+                    mPbapService.close();
+                    mPbapService = null;
+                    mIncomingHid = null;
+                    mOutgoingHid = null;
+                    mIncomingHandsfree = null;
+                    mOutgoingHandsfree = null;
+                    mIncomingA2dp = null;
+                    mOutgoingA2dp = null;
+                    mBondedDevice = null;
+                    // There is a problem in the State Machine code
+                    // where things are not cleaned up properly, when quit message
+                    // is handled so return NOT_HANDLED as a workaround.
+                    return NOT_HANDLED;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private class OutgoingHandsfree extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering OutgoingHandsfree state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_HFP_OUTGOING &&
+                mCommand != DISCONNECT_HFP_OUTGOING) {
+                Log.e(TAG, "Error: OutgoingHandsfree state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) {
+                sendMessage(TRANSITION_TO_STABLE);
+                mService.sendProfileStateMessage(BluetoothProfileState.HFP,
+                                                 BluetoothProfileState.TRANSITION_TO_STABLE);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("OutgoingHandsfree State -> Processing Message: " + message.what);
+            Message deferMsg = new Message();
+            int command = message.what;
+            switch(command) {
+                case CONNECT_HFP_OUTGOING:
+                    if (command != mCommand) {
+                        // Disconnect followed by a connect - defer
+                        deferMessage(message);
+                    }
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    if (mCommand == CONNECT_HFP_OUTGOING) {
+                        // Cancel outgoing connect, accept incoming
+                        cancelCommand(CONNECT_HFP_OUTGOING);
+                        transitionTo(mIncomingHandsfree);
+                    } else {
+                        // We have done the disconnect but we are not
+                        // sure which state we are in at this point.
+                        deferMessage(message);
+                    }
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    // accept incoming A2DP, retry HFP_OUTGOING
+                    transitionTo(mIncomingA2dp);
+
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    if (mCommand == CONNECT_HFP_OUTGOING) {
+                        // Cancel outgoing connect
+                        cancelCommand(CONNECT_HFP_OUTGOING);
+                        processCommand(DISCONNECT_HFP_OUTGOING);
+                    }
+                    // else ignore
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    // When this happens the socket would be closed and the headset
+                    // state moved to DISCONNECTED, cancel the outgoing thread.
+                    // if it still is in CONNECTING state
+                    cancelCommand(CONNECT_HFP_OUTGOING);
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    // Bluez will handle the disconnect. If because of this the outgoing
+                    // handsfree connection has failed, then retry.
+                    if (mStatus) {
+                       deferMsg.what = mCommand;
+                       deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HID_INCOMING:
+                    transitionTo(mIncomingHid);
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case DISCONNECT_HID_INCOMING:
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break; // ignore
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case AUTO_CONNECT_PROFILES:
+                case CONNECT_OTHER_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private class IncomingHandsfree extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering IncomingHandsfree state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_HFP_INCOMING &&
+                mCommand != DISCONNECT_HFP_INCOMING) {
+                Log.e(TAG, "Error: IncomingHandsfree state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) {
+                sendMessage(TRANSITION_TO_STABLE);
+                mService.sendProfileStateMessage(BluetoothProfileState.HFP,
+                                                 BluetoothProfileState.TRANSITION_TO_STABLE);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("IncomingHandsfree State -> Processing Message: " + message.what);
+            switch(message.what) {
+                case CONNECT_HFP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    // Ignore
+                    Log.e(TAG, "Error: Incoming connection with a pending incoming connection");
+                    break;
+                case CONNECTION_ACCESS_REQUEST_REPLY:
+                    int val = message.arg1;
+                    mConnectionAccessReplyReceived = true;
+                    boolean value = false;
+                    if (val == BluetoothDevice.CONNECTION_ACCESS_YES) {
+                        value = true;
+                    }
+                    setTrust(val);
+
+                    handleIncomingConnection(CONNECT_HFP_INCOMING, value);
+                    break;
+                case CONNECTION_ACCESS_REQUEST_EXPIRY:
+                    if (!mConnectionAccessReplyReceived) {
+                        handleIncomingConnection(CONNECT_HFP_INCOMING, false);
+                        sendConnectionAccessRemovalIntent();
+                        sendMessage(TRANSITION_TO_STABLE);
+                    }
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    // Serialize the commands.
+                    deferMessage(message);
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    // We don't know at what state we are in the incoming HFP connection state.
+                    // We can be changing from DISCONNECTED to CONNECTING, or
+                    // from CONNECTING to CONNECTED, so serializing this command is
+                    // the safest option.
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    // Nothing to do here, we will already be DISCONNECTED
+                    // by this point.
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    // Bluez handles incoming A2DP disconnect.
+                    // If this causes incoming HFP to fail, it is more of a headset problem
+                    // since both connections are incoming ones.
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HID_INCOMING:
+                case DISCONNECT_HID_INCOMING:
+                     break; // ignore
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case AUTO_CONNECT_PROFILES:
+                case CONNECT_OTHER_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private class OutgoingA2dp extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering OutgoingA2dp state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_A2DP_OUTGOING &&
+                mCommand != DISCONNECT_A2DP_OUTGOING) {
+                Log.e(TAG, "Error: OutgoingA2DP state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) {
+                sendMessage(TRANSITION_TO_STABLE);
+                mService.sendProfileStateMessage(BluetoothProfileState.A2DP,
+                                                 BluetoothProfileState.TRANSITION_TO_STABLE);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("OutgoingA2dp State->Processing Message: " + message.what);
+            Message deferMsg = new Message();
+            switch(message.what) {
+                case CONNECT_HFP_OUTGOING:
+                    processCommand(CONNECT_HFP_OUTGOING);
+
+                    // Don't cancel A2DP outgoing as there is no guarantee it
+                    // will get canceled.
+                    // It might already be connected but we might not have got the
+                    // A2DP_SINK_STATE_CHANGE. Hence, no point disconnecting here.
+                    // The worst case, the connection will fail, retry.
+                    // The same applies to Disconnecting an A2DP connection.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    processCommand(CONNECT_HFP_INCOMING);
+
+                    // Don't cancel A2DP outgoing as there is no guarantee
+                    // it will get canceled.
+                    // The worst case, the connection will fail, retry.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    // Bluez will take care of conflicts between incoming and outgoing
+                    // connections.
+                    transitionTo(mIncomingA2dp);
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    // Ignore
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    // At this point, we are already disconnected
+                    // with HFP. Sometimes A2DP connection can
+                    // fail due to the disconnection of HFP. So add a retry
+                    // for the A2DP.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    // Ignore, will be handled by Bluez
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HID_INCOMING:
+                    transitionTo(mIncomingHid);
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case DISCONNECT_HID_INCOMING:
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break; // ignore
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case AUTO_CONNECT_PROFILES:
+                case CONNECT_OTHER_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private class IncomingA2dp extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            Log.i(TAG, "Entering IncomingA2dp state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_A2DP_INCOMING &&
+                mCommand != DISCONNECT_A2DP_INCOMING) {
+                Log.e(TAG, "Error: IncomingA2DP state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) {
+                sendMessage(TRANSITION_TO_STABLE);
+                mService.sendProfileStateMessage(BluetoothProfileState.A2DP,
+                                                 BluetoothProfileState.TRANSITION_TO_STABLE);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("IncomingA2dp State->Processing Message: " + message.what);
+            switch(message.what) {
+                case CONNECT_HFP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HFP_INCOMING:
+                    // Shouldn't happen, but serialize the commands.
+                    deferMessage(message);
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    // ignore
+                    break;
+                case CONNECTION_ACCESS_REQUEST_REPLY:
+                    int val = message.arg1;
+                    mConnectionAccessReplyReceived = true;
+                    boolean value = false;
+                    if (val == BluetoothDevice.CONNECTION_ACCESS_YES) {
+                        value = true;
+                    }
+                    setTrust(val);
+                    handleIncomingConnection(CONNECT_A2DP_INCOMING, value);
+                    break;
+                case CONNECTION_ACCESS_REQUEST_EXPIRY:
+                    // The check protects the race condition between REQUEST_REPLY
+                    // and the timer expiry.
+                    if (!mConnectionAccessReplyReceived) {
+                        handleIncomingConnection(CONNECT_A2DP_INCOMING, false);
+                        sendConnectionAccessRemovalIntent();
+                        sendMessage(TRANSITION_TO_STABLE);
+                    }
+                    break;
+                case CONNECT_A2DP_OUTGOING:
+                    // Defer message and retry
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_HFP_INCOMING:
+                    // Shouldn't happen but if does, we can handle it.
+                    // Depends if the headset can handle it.
+                    // Incoming A2DP will be handled by Bluez, Disconnect HFP
+                    // the socket would have already been closed.
+                    // ignore
+                    break;
+                case DISCONNECT_A2DP_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case DISCONNECT_A2DP_INCOMING:
+                    // Ignore, will be handled by Bluez
+                    break;
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+                case CONNECT_HID_INCOMING:
+                case DISCONNECT_HID_INCOMING:
+                     break; // ignore
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case AUTO_CONNECT_PROFILES:
+                case CONNECT_OTHER_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+
+    private class OutgoingHid extends State {
+        private boolean mStatus = false;
+        private int mCommand;
+
+        @Override
+        public void enter() {
+            log("Entering OutgoingHid state with: " + getCurrentMessage().what);
+            mCommand = getCurrentMessage().what;
+            if (mCommand != CONNECT_HID_OUTGOING &&
+                mCommand != DISCONNECT_HID_OUTGOING) {
+                Log.e(TAG, "Error: OutgoingHid state with command:" + mCommand);
+            }
+            mStatus = processCommand(mCommand);
+            if (!mStatus) sendMessage(TRANSITION_TO_STABLE);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("OutgoingHid State->Processing Message: " + message.what);
+            Message deferMsg = new Message();
+            switch(message.what) {
+                // defer all outgoing messages
+                case CONNECT_HFP_OUTGOING:
+                case CONNECT_A2DP_OUTGOING:
+                case CONNECT_HID_OUTGOING:
+                case DISCONNECT_HFP_OUTGOING:
+                case DISCONNECT_A2DP_OUTGOING:
+                case DISCONNECT_HID_OUTGOING:
+                    deferMessage(message);
+                    break;
+
+                case CONNECT_HFP_INCOMING:
+                    transitionTo(mIncomingHandsfree);
+                    break;
+                case CONNECT_A2DP_INCOMING:
+                    transitionTo(mIncomingA2dp);
+
+                    // Don't cancel HID outgoing as there is no guarantee it
+                    // will get canceled.
+                    // It might already be connected but we might not have got the
+                    // INPUT_DEVICE_STATE_CHANGE. Hence, no point disconnecting here.
+                    // The worst case, the connection will fail, retry.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case CONNECT_HID_INCOMING:
+                  // Bluez will take care of the conflicts
+                    transitionTo(mIncomingHid);
+                    break;
+
+                case DISCONNECT_HFP_INCOMING:
+                case DISCONNECT_A2DP_INCOMING:
+                    // At this point, we are already disconnected
+                    // with HFP. Sometimes HID connection can
+                    // fail due to the disconnection of HFP. So add a retry
+                    // for the HID.
+                    if (mStatus) {
+                        deferMsg.what = mCommand;
+                        deferMessage(deferMsg);
+                    }
+                    break;
+                case DISCONNECT_HID_INCOMING:
+                    // Ignore, will be handled by Bluez
+                    break;
+                case DISCONNECT_PBAP_OUTGOING:
+                case UNPAIR:
+                case AUTO_CONNECT_PROFILES:
+                    deferMessage(message);
+                    break;
+                case TRANSITION_TO_STABLE:
+                    transitionTo(mBondedDevice);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+  private class IncomingHid extends State {
+      private boolean mStatus = false;
+      private int mCommand;
+
+      @Override
+    public void enter() {
+          log("Entering IncomingHid state with: " + getCurrentMessage().what);
+          mCommand = getCurrentMessage().what;
+          if (mCommand != CONNECT_HID_INCOMING &&
+              mCommand != DISCONNECT_HID_INCOMING) {
+              Log.e(TAG, "Error: IncomingHid state with command:" + mCommand);
+          }
+          mStatus = processCommand(mCommand);
+          if (!mStatus) sendMessage(TRANSITION_TO_STABLE);
+      }
+
+      @Override
+    public boolean processMessage(Message message) {
+          log("IncomingHid State->Processing Message: " + message.what);
+          Message deferMsg = new Message();
+          switch(message.what) {
+              case CONNECT_HFP_OUTGOING:
+              case CONNECT_HFP_INCOMING:
+              case DISCONNECT_HFP_OUTGOING:
+              case CONNECT_A2DP_INCOMING:
+              case CONNECT_A2DP_OUTGOING:
+              case DISCONNECT_A2DP_OUTGOING:
+              case CONNECT_HID_OUTGOING:
+              case CONNECT_HID_INCOMING:
+              case DISCONNECT_HID_OUTGOING:
+                  deferMessage(message);
+                  break;
+              case CONNECTION_ACCESS_REQUEST_REPLY:
+                  mConnectionAccessReplyReceived = true;
+                  int val = message.arg1;
+                  setTrust(val);
+                  handleIncomingConnection(CONNECT_HID_INCOMING,
+                      val == BluetoothDevice.CONNECTION_ACCESS_YES);
+                  break;
+              case CONNECTION_ACCESS_REQUEST_EXPIRY:
+                  if (!mConnectionAccessReplyReceived) {
+                      handleIncomingConnection(CONNECT_HID_INCOMING, false);
+                      sendConnectionAccessRemovalIntent();
+                      sendMessage(TRANSITION_TO_STABLE);
+                  }
+                  break;
+              case DISCONNECT_HFP_INCOMING:
+                  // Shouldn't happen but if does, we can handle it.
+                  // Depends if the headset can handle it.
+                  // Incoming HID will be handled by Bluez, Disconnect HFP
+                  // the socket would have already been closed.
+                  // ignore
+                  break;
+              case DISCONNECT_HID_INCOMING:
+              case DISCONNECT_A2DP_INCOMING:
+                  // Ignore, will be handled by Bluez
+                  break;
+              case DISCONNECT_PBAP_OUTGOING:
+              case UNPAIR:
+              case AUTO_CONNECT_PROFILES:
+                  deferMessage(message);
+                  break;
+              case TRANSITION_TO_STABLE:
+                  transitionTo(mBondedDevice);
+                  break;
+              default:
+                  return NOT_HANDLED;
+          }
+          return HANDLED;
+      }
+  }
+
+
+    synchronized void cancelCommand(int command) {
+        if (command == CONNECT_HFP_OUTGOING ) {
+            // Cancel the outgoing thread.
+            if (mHeadsetService != null) {
+                mHeadsetService.cancelConnectThread();
+            }
+            // HeadsetService is down. Phone process most likely crashed.
+            // The thread would have got killed.
+        }
+    }
+
+    synchronized void deferProfileServiceMessage(int command) {
+        Message msg = new Message();
+        msg.what = command;
+        deferMessage(msg);
+    }
+
+    private void updateIncomingAllowedTimer() {
+        // Not doing a perfect exponential backoff because
+        // we want two different rates. For all practical
+        // purposes, this is good enough.
+        if (mIncomingRejectTimer == 0) mIncomingRejectTimer = INIT_INCOMING_REJECT_TIMER;
+
+        mIncomingRejectTimer *= 5;
+        if (mIncomingRejectTimer > MAX_INCOMING_REJECT_TIMER) {
+            mIncomingRejectTimer = MAX_INCOMING_REJECT_TIMER;
+        }
+        writeTimerValue(mIncomingRejectTimer);
+    }
+
+    private boolean handleIncomingConnection(int command, boolean accept) {
+        boolean ret = false;
+        Log.i(TAG, "handleIncomingConnection:" + command + ":" + accept);
+        switch (command) {
+            case CONNECT_HFP_INCOMING:
+                if (!accept) {
+                    ret = mHeadsetService.rejectIncomingConnect(mDevice);
+                    sendMessage(TRANSITION_TO_STABLE);
+                    updateIncomingAllowedTimer();
+                } else if (mHeadsetState == BluetoothHeadset.STATE_CONNECTING) {
+                    writeTimerValue(0);
+                    ret =  mHeadsetService.acceptIncomingConnect(mDevice);
+                } else if (mHeadsetState == BluetoothHeadset.STATE_DISCONNECTED) {
+                    writeTimerValue(0);
+                    handleConnectionOfOtherProfiles(command);
+                    ret = mHeadsetService.createIncomingConnect(mDevice);
+                }
+                break;
+            case CONNECT_A2DP_INCOMING:
+                if (!accept) {
+                    ret = mA2dpService.allowIncomingConnect(mDevice, false);
+                    sendMessage(TRANSITION_TO_STABLE);
+                    updateIncomingAllowedTimer();
+                } else {
+                    writeTimerValue(0);
+                    ret = mA2dpService.allowIncomingConnect(mDevice, true);
+                    handleConnectionOfOtherProfiles(command);
+                }
+                break;
+            case CONNECT_HID_INCOMING:
+                if (!accept) {
+                    ret = mService.allowIncomingProfileConnect(mDevice, false);
+                    sendMessage(TRANSITION_TO_STABLE);
+                    updateIncomingAllowedTimer();
+                } else {
+                    writeTimerValue(0);
+                    ret = mService.allowIncomingProfileConnect(mDevice, true);
+                }
+                break;
+            default:
+                Log.e(TAG, "Waiting for incoming connection but state changed to:" + command);
+                break;
+       }
+       return ret;
+    }
+
+    private void sendConnectionAccessIntent() {
+        mConnectionAccessReplyReceived = false;
+
+        if (!mPowerManager.isScreenOn()) mWakeLock.acquire();
+
+        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
+        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
+        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                        BluetoothDevice.REQUEST_TYPE_PROFILE_CONNECTION);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+    }
+
+    private void sendConnectionAccessRemovalIntent() {
+        mWakeLock.release();
+        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+    }
+
+    private int getTrust() {
+        String address = mDevice.getAddress();
+        if (mIncomingConnections != null) return mIncomingConnections.first;
+        return CONNECTION_ACCESS_UNDEFINED;
+    }
+
+
+    private String getStringValue(long value) {
+        StringBuilder sbr = new StringBuilder();
+        sbr.append(Long.toString(System.currentTimeMillis()));
+        sbr.append("-");
+        sbr.append(Long.toString(value));
+        return sbr.toString();
+    }
+
+    private void setTrust(int value) {
+        String second;
+        if (mIncomingConnections == null) {
+            second = getStringValue(INIT_INCOMING_REJECT_TIMER);
+        } else {
+            second = mIncomingConnections.second;
+        }
+
+        mIncomingConnections = new Pair(value, second);
+        mService.writeIncomingConnectionState(mDevice.getAddress(), mIncomingConnections);
+    }
+
+    private void writeTimerValue(long value) {
+        Integer first;
+        if (mIncomingConnections == null) {
+            first = CONNECTION_ACCESS_UNDEFINED;
+        } else {
+            first = mIncomingConnections.first;
+        }
+        mIncomingConnections = new Pair(first, getStringValue(value));
+        mService.writeIncomingConnectionState(mDevice.getAddress(), mIncomingConnections);
+    }
+
+    private long readTimerValue() {
+        if (mIncomingConnections == null)
+            return 0;
+        String value = mIncomingConnections.second;
+        String[] splits = value.split("-");
+        if (splits != null && splits.length == 2) {
+            return Long.parseLong(splits[1]);
+        }
+        return 0;
+    }
+
+    private boolean readIncomingAllowedValue() {
+        if (readTimerValue() == 0) return true;
+        String value = mIncomingConnections.second;
+        String[] splits = value.split("-");
+        if (splits != null && splits.length == 2) {
+            long val1 = Long.parseLong(splits[0]);
+            long val2 = Long.parseLong(splits[1]);
+            if (val1 + val2 <= System.currentTimeMillis()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    synchronized boolean processCommand(int command) {
+        log("Processing command:" + command);
+        switch(command) {
+            case  CONNECT_HFP_OUTGOING:
+                if (mHeadsetService == null) {
+                    deferProfileServiceMessage(command);
+                } else {
+                    return mHeadsetService.connectHeadsetInternal(mDevice);
+                }
+                break;
+            case CONNECT_HFP_INCOMING:
+                if (mHeadsetService == null) {
+                    deferProfileServiceMessage(command);
+                } else {
+                    processIncomingConnectCommand(command);
+                    return true;
+                }
+                break;
+            case CONNECT_A2DP_OUTGOING:
+                if (mA2dpService != null) {
+                    return mA2dpService.connectSinkInternal(mDevice);
+                }
+                break;
+            case CONNECT_A2DP_INCOMING:
+                processIncomingConnectCommand(command);
+                return true;
+            case CONNECT_HID_OUTGOING:
+                return mService.connectInputDeviceInternal(mDevice);
+            case CONNECT_HID_INCOMING:
+                processIncomingConnectCommand(command);
+                return true;
+            case DISCONNECT_HFP_OUTGOING:
+                if (mHeadsetService == null) {
+                    deferProfileServiceMessage(command);
+                } else {
+                    // Disconnect PBAP
+                    // TODO(): Add PBAP to the state machine.
+                    Message m = new Message();
+                    m.what = DISCONNECT_PBAP_OUTGOING;
+                    deferMessage(m);
+                    if (mHeadsetService.getPriority(mDevice) ==
+                        BluetoothHeadset.PRIORITY_AUTO_CONNECT) {
+                        mHeadsetService.setPriority(mDevice, BluetoothHeadset.PRIORITY_ON);
+                    }
+                    return mHeadsetService.disconnectHeadsetInternal(mDevice);
+                }
+                break;
+            case DISCONNECT_HFP_INCOMING:
+                // ignore
+                return true;
+            case DISCONNECT_A2DP_INCOMING:
+                // ignore
+                return true;
+            case DISCONNECT_A2DP_OUTGOING:
+                if (mA2dpService != null) {
+                    if (mA2dpService.getPriority(mDevice) ==
+                        BluetoothA2dp.PRIORITY_AUTO_CONNECT) {
+                        mA2dpService.setPriority(mDevice, BluetoothHeadset.PRIORITY_ON);
+                    }
+                    return mA2dpService.disconnectSinkInternal(mDevice);
+                }
+                break;
+            case DISCONNECT_HID_INCOMING:
+                // ignore
+                return true;
+            case DISCONNECT_HID_OUTGOING:
+                if (mService.getInputDevicePriority(mDevice) ==
+                    BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
+                    mService.setInputDevicePriority(mDevice, BluetoothInputDevice.PRIORITY_ON);
+                }
+                return mService.disconnectInputDeviceInternal(mDevice);
+            case DISCONNECT_PBAP_OUTGOING:
+                if (!mPbapServiceConnected) {
+                    deferProfileServiceMessage(command);
+                } else {
+                    return mPbapService.disconnect();
+                }
+                break;
+            case UNPAIR:
+                writeTimerValue(INIT_INCOMING_REJECT_TIMER);
+                setTrust(CONNECTION_ACCESS_UNDEFINED);
+                return mService.removeBondInternal(mDevice.getAddress());
+            default:
+                Log.e(TAG, "Error: Unknown Command");
+        }
+        return false;
+    }
+
+    private void processIncomingConnectCommand(int command) {
+        // Check if device is already trusted
+        int access = getTrust();
+        if (access == BluetoothDevice.CONNECTION_ACCESS_YES) {
+            handleIncomingConnection(command, true);
+        } else if (access == BluetoothDevice.CONNECTION_ACCESS_NO &&
+                   !readIncomingAllowedValue()) {
+            handleIncomingConnection(command, false);
+        } else {
+            sendConnectionAccessIntent();
+            Message msg = obtainMessage(CONNECTION_ACCESS_REQUEST_EXPIRY);
+            sendMessageDelayed(msg,
+                               CONNECTION_ACCESS_REQUEST_EXPIRY_TIMEOUT);
+        }
+    }
+
+    private void handleConnectionOfOtherProfiles(int command) {
+        // The white paper recommendations mentions that when there is a
+        // link loss, it is the responsibility of the remote device to connect.
+        // Many connect only 1 profile - and they connect the second profile on
+        // some user action (like play being pressed) and so we need this code.
+        // Auto Connect code only connects to the last connected device - which
+        // is useful in cases like when the phone reboots. But consider the
+        // following case:
+        // User is connected to the car's phone and  A2DP profile.
+        // User comes to the desk  and places the phone in the dock
+        // (or any speaker or music system or even another headset) and thus
+        // gets connected to the A2DP profile.  User goes back to the car.
+        // Ideally the car's system is supposed to send incoming connections
+        // from both Handsfree and A2DP profile. But they don't. The Auto
+        // connect code, will not work here because we only auto connect to the
+        // last connected device for that profile which in this case is the dock.
+        // Now suppose a user is using 2 headsets simultaneously, one for the
+        // phone profile one for the A2DP profile. If this is the use case, we
+        // expect the user to use the preference to turn off the A2DP profile in
+        // the Settings screen for the first headset. Else, after link loss,
+        // there can be an incoming connection from the first headset which
+        // might result in the connection of the A2DP profile (if the second
+        // headset is slower) and thus the A2DP profile on the second headset
+        // will never get connected.
+        //
+        // TODO(): Handle other profiles here.
+        switch (command) {
+            case CONNECT_HFP_INCOMING:
+                // Connect A2DP if there is no incoming connection
+                // If the priority is OFF - don't auto connect.
+                if (mA2dpService.getPriority(mDevice) == BluetoothProfile.PRIORITY_ON ||
+                        mA2dpService.getPriority(mDevice) ==
+                            BluetoothProfile.PRIORITY_AUTO_CONNECT) {
+                    Message msg = new Message();
+                    msg.what = CONNECT_OTHER_PROFILES;
+                    msg.arg1 = CONNECT_A2DP_OUTGOING;
+                    sendMessageDelayed(msg, CONNECT_OTHER_PROFILES_DELAY);
+                }
+                break;
+            case CONNECT_A2DP_INCOMING:
+                // This is again against spec. HFP incoming connections should be made
+                // before A2DP, so we should not hit this case. But many devices
+                // don't follow this.
+                if (mHeadsetService != null &&
+                    (mHeadsetService.getPriority(mDevice) == BluetoothProfile.PRIORITY_ON ||
+                        mHeadsetService.getPriority(mDevice) ==
+                            BluetoothProfile.PRIORITY_AUTO_CONNECT)) {
+                    Message msg = new Message();
+                    msg.what = CONNECT_OTHER_PROFILES;
+                    msg.arg1 = CONNECT_HFP_OUTGOING;
+                    sendMessageDelayed(msg, CONNECT_OTHER_PROFILES_DELAY);
+                }
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    /*package*/ BluetoothDevice getDevice() {
+        return mDevice;
+    }
+
+    private void log(String message) {
+        if (DBG) {
+            Log.i(TAG, "Device:" + mDevice + " Message:" + message);
+        }
+    }
+}
diff --git a/core/java/android/bluetooth/BluetoothHeadset.java b/core/java/android/bluetooth/BluetoothHeadset.java
index 793d798..c790250 100644
--- a/core/java/android/bluetooth/BluetoothHeadset.java
+++ b/core/java/android/bluetooth/BluetoothHeadset.java
@@ -220,38 +220,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
     private Context mContext;
     private ServiceListener mServiceListener;
     private IBluetoothHeadset mService;
-    private BluetoothAdapter mAdapter;
-
-    final private IBluetoothStateChangeCallback mBluetoothStateChangeCallback =
-            new IBluetoothStateChangeCallback.Stub() {
-                public void onBluetoothStateChange(boolean up) {
-                    if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up);
-                    if (!up) {
-                        if (VDBG) Log.d(TAG,"Unbinding service...");
-                        synchronized (mConnection) {
-                            try {
-                                mService = null;
-                                mContext.unbindService(mConnection);
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    } else {
-                        synchronized (mConnection) {
-                            try {
-                                if (mService == null) {
-                                    if (VDBG) Log.d(TAG,"Binding service...");
-                                    if (!mContext.bindService(new Intent(IBluetoothHeadset.class.getName()), mConnection, 0)) {
-                                        Log.e(TAG, "Could not bind to Bluetooth Headset Service");
-                                    }
-                                }
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    }
-                }
-        };
+    BluetoothAdapter mAdapter;
 
     /**
      * Create a BluetoothHeadset proxy object.
@@ -260,16 +229,6 @@ public final class BluetoothHeadset implements BluetoothProfile {
         mContext = context;
         mServiceListener = l;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
-
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.registerStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (RemoteException e) {
-                Log.e(TAG,"",e);
-            }
-        }
-
         if (!context.bindService(new Intent(IBluetoothHeadset.class.getName()), mConnection, 0)) {
             Log.e(TAG, "Could not bind to Bluetooth Headset Service");
         }
@@ -281,27 +240,11 @@ public final class BluetoothHeadset implements BluetoothProfile {
      * results once close() has been called. Multiple invocations of close()
      * are ok.
      */
-    /*package*/ void close() {
-        if (VDBG) log("close()");
-
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (Exception e) {
-                Log.e(TAG,"",e);
-            }
-        }
-
-        synchronized (mConnection) {
-            if (mService != null) {
-                try {
-                    mService = null;
-                    mContext.unbindService(mConnection);
-                } catch (Exception re) {
-                    Log.e(TAG,"",re);
-                }
-            }
+    /*package*/ synchronized void close() {
+        if (DBG) log("close()");
+        if (mConnection != null) {
+            mContext.unbindService(mConnection);
+            mConnection = null;
         }
         mServiceListener = null;
     }
@@ -620,6 +563,25 @@ public final class BluetoothHeadset implements BluetoothProfile {
     }
 
     /**
+     * Cancel the outgoing connection.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean cancelConnectThread() {
+        if (DBG) log("cancelConnectThread");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.cancelConnectThread();
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
      * Accept the incoming connection.
      * Note: This is an internal function and shouldn't be exposed
      *
@@ -639,6 +601,25 @@ public final class BluetoothHeadset implements BluetoothProfile {
     }
 
     /**
+     * Create the connect thread for the incoming connection.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean createIncomingConnect(BluetoothDevice device) {
+        if (DBG) log("createIncomingConnect");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.createIncomingConnect(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
      * Reject the incoming connection.
      * @hide
      */
@@ -661,6 +642,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
      *
      * @hide
      */
+    /**
     public int getAudioState(BluetoothDevice device) {
         if (VDBG) log("getAudioState");
         if (mService != null && !isDisabled()) {
@@ -673,6 +655,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
         }
         return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
     }
+    */
 
     /**
      * Check if Bluetooth SCO audio is connected.
@@ -683,6 +666,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
      *         false otherwise or on error
      * @hide
      */
+    /**
     public boolean isAudioOn() {
         if (VDBG) log("isAudioOn()");
         if (mService != null && isEnabled()) {
@@ -696,6 +680,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
         return false;
 
     }
+    */
 
     /**
      * Initiates a connection of headset audio.
@@ -706,6 +691,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
      *               there is no connected headset
      * @hide
      */
+    /**
     public boolean connectAudio() {
         if (mService != null && isEnabled()) {
             try {
@@ -719,6 +705,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
         }
         return false;
     }
+    */
 
     /**
      * Initiates a disconnection of headset audio.
@@ -729,6 +716,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
      *               there is no connected SCO channel
      * @hide
      */
+    /**
     public boolean disconnectAudio() {
         if (mService != null && isEnabled()) {
             try {
@@ -742,6 +730,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
         }
         return false;
     }
+    */
 
     /**
      * Initiates a SCO channel connection with the headset (if connected).
@@ -792,68 +781,6 @@ public final class BluetoothHeadset implements BluetoothProfile {
         return false;
     }
 
-    /**
-     * Notify Headset of phone state change.
-     * This is a backdoor for phone app to call BluetoothHeadset since
-     * there is currently not a good way to get precise call state change outside
-     * of phone app.
-     *
-     * @hide
-     */
-    public void phoneStateChanged(int numActive, int numHeld, int callState, String number,
-                                  int type) {
-        if (mService != null && isEnabled()) {
-            try {
-                mService.phoneStateChanged(numActive, numHeld, callState, number, type);
-            } catch (RemoteException e) {
-                Log.e(TAG, e.toString());
-            }
-        } else {
-            Log.w(TAG, "Proxy not attached to service");
-            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
-        }
-    }
-
-    /**
-     * Notify Headset of phone roam state change.
-     * This is a backdoor for phone app to call BluetoothHeadset since
-     * there is currently not a good way to get roaming state change outside
-     * of phone app.
-     *
-     * @hide
-     */
-    public void roamChanged(boolean roaming) {
-        if (mService != null && isEnabled()) {
-            try {
-                mService.roamChanged(roaming);
-            } catch (RemoteException e) {
-                Log.e(TAG, e.toString());
-            }
-        } else {
-            Log.w(TAG, "Proxy not attached to service");
-            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
-        }
-    }
-
-    /**
-     * Send Headset of CLCC response
-     *
-     * @hide
-     */
-    public void clccResponse(int index, int direction, int status, int mode, boolean mpty,
-                             String number, int type) {
-        if (mService != null && isEnabled()) {
-            try {
-                mService.clccResponse(index, direction, status, mode, mpty, number, type);
-            } catch (RemoteException e) {
-                Log.e(TAG, e.toString());
-            }
-        } else {
-            Log.w(TAG, "Proxy not attached to service");
-            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
-        }
-    }
-
     private ServiceConnection mConnection = new ServiceConnection() {
         public void onServiceConnected(ComponentName className, IBinder service) {
             if (DBG) Log.d(TAG, "Proxy object connected");
@@ -892,4 +819,80 @@ public final class BluetoothHeadset implements BluetoothProfile {
     private static void log(String msg) {
         Log.d(TAG, msg);
     }
+
+    /**
+     * Connect to a Bluetooth Headset.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean connectHeadsetInternal(BluetoothDevice device) {
+        if (DBG) log("connectHeadsetInternal");
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.connectHeadsetInternal(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Disconnect a Bluetooth Headset.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean disconnectHeadsetInternal(BluetoothDevice device) {
+        if (DBG) log("disconnectHeadsetInternal");
+        if (mService != null && !isDisabled()) {
+            try {
+                 return mService.disconnectHeadsetInternal(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Set the audio state of the Headset.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public boolean setAudioState(BluetoothDevice device, int state) {
+        if (DBG) log("setAudioState");
+        if (mService != null && !isDisabled()) {
+            try {
+                return mService.setAudioState(device, state);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return false;
+    }
+
+    /**
+     * Get the current audio state of the Headset.
+     * Note: This is an internal function and shouldn't be exposed
+     *
+     * @hide
+     */
+    public int getAudioState(BluetoothDevice device) {
+        if (DBG) log("getAudioState");
+        if (mService != null && !isDisabled()) {
+            try {
+                return mService.getAudioState(device);
+            } catch (RemoteException e) {Log.e(TAG, e.toString());}
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+        return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
+    }
 }
diff --git a/core/java/android/bluetooth/BluetoothHealth.java b/core/java/android/bluetooth/BluetoothHealth.java
index cb23662..6aaefd5 100644
--- a/core/java/android/bluetooth/BluetoothHealth.java
+++ b/core/java/android/bluetooth/BluetoothHealth.java
@@ -16,10 +16,7 @@
 
 package android.bluetooth;
 
-import android.content.ComponentName;
 import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
 import android.os.IBinder;
 import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
@@ -98,37 +95,6 @@ public final class BluetoothHealth implements BluetoothProfile {
     /** @hide */
     public static final int HEALTH_OPERATION_NOT_ALLOWED = 6005;
 
-    final private IBluetoothStateChangeCallback mBluetoothStateChangeCallback =
-            new IBluetoothStateChangeCallback.Stub() {
-                public void onBluetoothStateChange(boolean up) {
-                    if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up);
-                    if (!up) {
-                        if (VDBG) Log.d(TAG,"Unbinding service...");
-                        synchronized (mConnection) {
-                            try {
-                                mService = null;
-                                mContext.unbindService(mConnection);
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    } else {
-                        synchronized (mConnection) {
-                            try {
-                                if (mService == null) {
-                                    if (VDBG) Log.d(TAG,"Binding service...");
-                                    if (!mContext.bindService(new Intent(IBluetoothHealth.class.getName()), mConnection, 0)) {
-                                        Log.e(TAG, "Could not bind to Bluetooth Health Service");
-                                    }
-                                }
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    }
-                }
-        };
-
 
     /**
      * Register an application configuration that acts as a Health SINK.
@@ -462,74 +428,35 @@ public final class BluetoothHealth implements BluetoothProfile {
     /** Health App Configuration un-registration failure */
     public static final int APP_CONFIG_UNREGISTRATION_FAILURE = 3;
 
-    private Context mContext;
     private ServiceListener mServiceListener;
-    private IBluetoothHealth mService;
+    private IBluetooth mService;
     BluetoothAdapter mAdapter;
 
     /**
      * Create a BluetoothHealth proxy object.
      */
     /*package*/ BluetoothHealth(Context context, ServiceListener l) {
-        mContext = context;
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
         mServiceListener = l;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.registerStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (RemoteException e) {
-                Log.e(TAG,"",e);
+        if (b != null) {
+            mService = IBluetooth.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.HEALTH, this);
             }
-        }
+        } else {
+            Log.w(TAG, "Bluetooth Service not available!");
 
-        if (!context.bindService(new Intent(IBluetoothHealth.class.getName()), mConnection, 0)) {
-            Log.e(TAG, "Could not bind to Bluetooth Health Service");
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mService = null;
         }
     }
 
     /*package*/ void close() {
-        if (VDBG) log("close()");
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (Exception e) {
-                Log.e(TAG,"",e);
-            }
-        }
-
-        synchronized (mConnection) {
-            if (mService != null) {
-                try {
-                    mService = null;
-                    mContext.unbindService(mConnection);
-                } catch (Exception re) {
-                    Log.e(TAG,"",re);
-                }
-            }
-        }
         mServiceListener = null;
     }
 
-    private ServiceConnection mConnection = new ServiceConnection() {
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            if (DBG) Log.d(TAG, "Proxy object connected");
-            mService = IBluetoothHealth.Stub.asInterface(service);
-
-            if (mServiceListener != null) {
-                mServiceListener.onServiceConnected(BluetoothProfile.HEALTH, BluetoothHealth.this);
-            }
-        }
-        public void onServiceDisconnected(ComponentName className) {
-            if (DBG) Log.d(TAG, "Proxy object disconnected");
-            mService = null;
-            if (mServiceListener != null) {
-                mServiceListener.onServiceDisconnected(BluetoothProfile.HEALTH);
-            }
-        }
-    };
-
     private boolean isEnabled() {
         BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
 
diff --git a/core/java/android/bluetooth/BluetoothInputDevice.java b/core/java/android/bluetooth/BluetoothInputDevice.java
index db7e424..9e4e601 100644
--- a/core/java/android/bluetooth/BluetoothInputDevice.java
+++ b/core/java/android/bluetooth/BluetoothInputDevice.java
@@ -18,10 +18,7 @@ package android.bluetooth;
 
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
-import android.content.ComponentName;
 import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
 import android.os.IBinder;
 import android.os.RemoteException;
 import android.os.ServiceManager;
@@ -70,22 +67,6 @@ public final class BluetoothInputDevice implements BluetoothProfile {
         "android.bluetooth.input.profile.action.CONNECTION_STATE_CHANGED";
 
     /**
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PROTOCOL_MODE_CHANGED =
-        "android.bluetooth.input.profile.action.PROTOCOL_MODE_CHANGED";
-
-
-    /**
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_VIRTUAL_UNPLUG_STATUS =
-        "android.bluetooth.input.profile.action.VIRTUAL_UNPLUG_STATUS";
-
-
-    /**
      * Return codes for the connect and disconnect Bluez / Dbus calls.
      * @hide
      */
@@ -111,112 +92,9 @@ public final class BluetoothInputDevice implements BluetoothProfile {
      */
     public static final int INPUT_OPERATION_SUCCESS = 5004;
 
-    /**
-     * @hide
-     */
-    public static final int PROTOCOL_REPORT_MODE = 0;
-
-    /**
-     * @hide
-     */
-    public static final int PROTOCOL_BOOT_MODE = 1;
-
-    /**
-     * @hide
-     */
-    public static final int PROTOCOL_UNSUPPORTED_MODE = 255;
-
-    /*  int reportType, int reportType, int bufferSize */
-    /**
-     * @hide
-     */
-    public static final byte REPORT_TYPE_INPUT = 0;
-
-    /**
-     * @hide
-     */
-    public static final byte REPORT_TYPE_OUTPUT = 1;
-
-    /**
-     * @hide
-     */
-    public static final byte REPORT_TYPE_FEATURE = 2;
-
-    /**
-     * @hide
-     */
-    public static final int VIRTUAL_UNPLUG_STATUS_SUCCESS = 0;
-
-    /**
-     * @hide
-     */
-    public static final int VIRTUAL_UNPLUG_STATUS_FAIL = 1;
-
-    /**
-     * @hide
-     */
-    public static final String EXTRA_PROTOCOL_MODE = "android.bluetooth.BluetoothInputDevice.extra.PROTOCOL_MODE";
-
-    /**
-     * @hide
-     */
-    public static final String EXTRA_REPORT_TYPE = "android.bluetooth.BluetoothInputDevice.extra.REPORT_TYPE";
-
-    /**
-     * @hide
-     */
-    public static final String EXTRA_REPORT_ID = "android.bluetooth.BluetoothInputDevice.extra.REPORT_ID";
-
-    /**
-     * @hide
-     */
-    public static final String EXTRA_REPORT_BUFFER_SIZE = "android.bluetooth.BluetoothInputDevice.extra.REPORT_BUFFER_SIZE";
-
-    /**
-     * @hide
-     */
-    public static final String EXTRA_REPORT = "android.bluetooth.BluetoothInputDevice.extra.REPORT";
-
-    /**
-     * @hide
-     */
-    public static final String EXTRA_VIRTUAL_UNPLUG_STATUS = "android.bluetooth.BluetoothInputDevice.extra.VIRTUAL_UNPLUG_STATUS";
-
-    private Context mContext;
     private ServiceListener mServiceListener;
     private BluetoothAdapter mAdapter;
-    private IBluetoothInputDevice mService;
-
-    final private IBluetoothStateChangeCallback mBluetoothStateChangeCallback =
-            new IBluetoothStateChangeCallback.Stub() {
-                public void onBluetoothStateChange(boolean up) {
-                    if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up);
-                    if (!up) {
-                        if (VDBG) Log.d(TAG,"Unbinding service...");
-                        synchronized (mConnection) {
-                            try {
-                                mService = null;
-                                mContext.unbindService(mConnection);
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    } else {
-                        synchronized (mConnection) {
-                            try {
-                                if (mService == null) {
-                                    if (VDBG) Log.d(TAG,"Binding service...");
-                                    if (!mContext.bindService(new Intent(IBluetoothInputDevice.class.getName()), mConnection, 0)) {
-                                        Log.e(TAG, "Could not bind to Bluetooth HID Service");
-                                    }
-                                }
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    }
-                }
-        };
+    private IBluetooth mService;
 
     /**
      * Create a BluetoothInputDevice proxy object for interacting with the local
@@ -224,46 +102,24 @@ public final class BluetoothInputDevice implements BluetoothProfile {
      *
      */
     /*package*/ BluetoothInputDevice(Context context, ServiceListener l) {
-        mContext = context;
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
         mServiceListener = l;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
-
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.registerStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (RemoteException e) {
-                Log.e(TAG,"",e);
+        if (b != null) {
+            mService = IBluetooth.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.INPUT_DEVICE, this);
             }
-        }
+        } else {
+            Log.w(TAG, "Bluetooth Service not available!");
 
-        if (!context.bindService(new Intent(IBluetoothInputDevice.class.getName()),
-                                 mConnection, 0)) {
-            Log.e(TAG, "Could not bind to Bluetooth HID Service");
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mService = null;
         }
     }
 
     /*package*/ void close() {
-        if (VDBG) log("close()");
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (Exception e) {
-                Log.e(TAG,"",e);
-            }
-        }
-
-        synchronized (mConnection) {
-            if (mService != null) {
-                try {
-                    mService = null;
-                    mContext.unbindService(mConnection);
-                } catch (Exception re) {
-                    Log.e(TAG,"",re);
-                }
-           }
-        }
         mServiceListener = null;
     }
 
@@ -291,7 +147,7 @@ public final class BluetoothInputDevice implements BluetoothProfile {
         if (DBG) log("connect(" + device + ")");
         if (mService != null && isEnabled() && isValidDevice(device)) {
             try {
-                return mService.connect(device);
+                return mService.connectInputDevice(device);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return false;
@@ -331,7 +187,7 @@ public final class BluetoothInputDevice implements BluetoothProfile {
         if (DBG) log("disconnect(" + device + ")");
         if (mService != null && isEnabled() && isValidDevice(device)) {
             try {
-                return mService.disconnect(device);
+                return mService.disconnectInputDevice(device);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return false;
@@ -348,7 +204,7 @@ public final class BluetoothInputDevice implements BluetoothProfile {
         if (VDBG) log("getConnectedDevices()");
         if (mService != null && isEnabled()) {
             try {
-                return mService.getConnectedDevices();
+                return mService.getConnectedInputDevices();
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return new ArrayList<BluetoothDevice>();
@@ -365,7 +221,7 @@ public final class BluetoothInputDevice implements BluetoothProfile {
         if (VDBG) log("getDevicesMatchingStates()");
         if (mService != null && isEnabled()) {
             try {
-                return mService.getDevicesMatchingConnectionStates(states);
+                return mService.getInputDevicesMatchingConnectionStates(states);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return new ArrayList<BluetoothDevice>();
@@ -382,7 +238,7 @@ public final class BluetoothInputDevice implements BluetoothProfile {
         if (VDBG) log("getState(" + device + ")");
         if (mService != null && isEnabled() && isValidDevice(device)) {
             try {
-                return mService.getConnectionState(device);
+                return mService.getInputDeviceConnectionState(device);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return BluetoothProfile.STATE_DISCONNECTED;
@@ -415,7 +271,7 @@ public final class BluetoothInputDevice implements BluetoothProfile {
               return false;
             }
             try {
-                return mService.setPriority(device, priority);
+                return mService.setInputDevicePriority(device, priority);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return false;
@@ -442,7 +298,7 @@ public final class BluetoothInputDevice implements BluetoothProfile {
         if (VDBG) log("getPriority(" + device + ")");
         if (mService != null && isEnabled() && isValidDevice(device)) {
             try {
-                return mService.getPriority(device);
+                return mService.getInputDevicePriority(device);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return BluetoothProfile.PRIORITY_OFF;
@@ -452,24 +308,6 @@ public final class BluetoothInputDevice implements BluetoothProfile {
         return BluetoothProfile.PRIORITY_OFF;
     }
 
-    private ServiceConnection mConnection = new ServiceConnection() {
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            if (DBG) Log.d(TAG, "Proxy object connected");
-            mService = IBluetoothInputDevice.Stub.asInterface(service);
-
-            if (mServiceListener != null) {
-                mServiceListener.onServiceConnected(BluetoothProfile.INPUT_DEVICE, BluetoothInputDevice.this);
-            }
-        }
-        public void onServiceDisconnected(ComponentName className) {
-            if (DBG) Log.d(TAG, "Proxy object disconnected");
-            mService = null;
-            if (mServiceListener != null) {
-                mServiceListener.onServiceDisconnected(BluetoothProfile.INPUT_DEVICE);
-            }
-        }
-    };
-
     private boolean isEnabled() {
        if (mAdapter.getState() == BluetoothAdapter.STATE_ON) return true;
        return false;
@@ -482,158 +320,6 @@ public final class BluetoothInputDevice implements BluetoothProfile {
        return false;
     }
 
-
-    /**
-     * Initiate virtual unplug for a HID input device.
-     *
-     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
-     *
-     * @param device Remote Bluetooth Device
-     * @return false on immediate error,
-     *               true otherwise
-     * @hide
-     */
-    public boolean virtualUnplug(BluetoothDevice device) {
-        if (DBG) log("virtualUnplug(" + device + ")");
-        if (mService != null && isEnabled() && isValidDevice(device)) {
-            try {
-                return mService.virtualUnplug(device);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
-                return false;
-            }
-        }
-
-        if (mService == null) Log.w(TAG, "Proxy not attached to service");
-        return false;
-
-    }
-
-    /**
-    * Send Get_Protocol_Mode command to the connected HID input device.
-    *
-    * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
-    *
-    * @param device Remote Bluetooth Device
-    * @return false on immediate error,
-    *true otherwise
-    * @hide
-    */
-    public boolean getProtocolMode(BluetoothDevice device) {
-        if (VDBG) log("getProtocolMode(" + device + ")");
-        if (mService != null && isEnabled() && isValidDevice(device)) {
-            try {
-                return mService.getProtocolMode(device);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
-                return false;
-            }
-        }
-        if (mService == null) Log.w(TAG, "Proxy not attached to service");
-            return false;
-    }
-
-    /**
-     * Send Set_Protocol_Mode command to the connected HID input device.
-     *
-     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
-     *
-     * @param device Remote Bluetooth Device
-     * @return false on immediate error,
-     *               true otherwise
-     * @hide
-     */
-    public boolean setProtocolMode(BluetoothDevice device, int protocolMode) {
-        if (DBG) log("setProtocolMode(" + device + ")");
-        if (mService != null && isEnabled() && isValidDevice(device)) {
-            try {
-                return mService.setProtocolMode(device, protocolMode);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
-                return false;
-            }
-        }
-        if (mService == null) Log.w(TAG, "Proxy not attached to service");
-        return false;
-    }
-
-    /**
-     * Send Get_Report command to the connected HID input device.
-     *
-     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
-     *
-     * @param device Remote Bluetooth Device
-     * @param reportType Report type
-     * @param reportId Report ID
-     * @param bufferSize Report receiving buffer size
-     * @return false on immediate error,
-     *               true otherwise
-     * @hide
-     */
-    public boolean getReport(BluetoothDevice device, byte reportType, byte reportId, int bufferSize) {
-        if (VDBG) log("getReport(" + device + "), reportType=" + reportType + " reportId=" + reportId + "bufferSize=" + bufferSize);
-        if (mService != null && isEnabled() && isValidDevice(device)) {
-            try {
-                return mService.getReport(device, reportType, reportId, bufferSize);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
-                return false;
-            }
-        }
-        if (mService == null) Log.w(TAG, "Proxy not attached to service");
-        return false;
-    }
-
-    /**
-     * Send Set_Report command to the connected HID input device.
-     *
-     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
-     *
-     * @param device Remote Bluetooth Device
-     * @param reportType Report type
-     * @param report Report receiving buffer size
-     * @return false on immediate error,
-     *               true otherwise
-     * @hide
-     */
-    public boolean setReport(BluetoothDevice device, byte reportType, String report) {
-        if (DBG) log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
-        if (mService != null && isEnabled() && isValidDevice(device)) {
-            try {
-                return mService.setReport(device, reportType, report);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
-                return false;
-            }
-        }
-        if (mService == null) Log.w(TAG, "Proxy not attached to service");
-        return false;
-    }
-
-    /**
-     * Send Send_Data command to the connected HID input device.
-     *
-     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
-     *
-     * @param device Remote Bluetooth Device
-     * @param data Data to send
-     * @return false on immediate error,
-     *               true otherwise
-     * @hide
-     */
-    public boolean sendData(BluetoothDevice device, String report) {
-        if (DBG) log("sendData(" + device + "), report=" + report);
-        if (mService != null && isEnabled() && isValidDevice(device)) {
-            try {
-                return mService.sendData(device, report);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
-                return false;
-            }
-        }
-        if (mService == null) Log.w(TAG, "Proxy not attached to service");
-        return false;
-    }
     private static void log(String msg) {
       Log.d(TAG, msg);
     }
diff --git a/core/java/android/bluetooth/BluetoothPan.java b/core/java/android/bluetooth/BluetoothPan.java
index e25ec86..a01a3a0 100644
--- a/core/java/android/bluetooth/BluetoothPan.java
+++ b/core/java/android/bluetooth/BluetoothPan.java
@@ -18,10 +18,7 @@ package android.bluetooth;
 
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
-import android.content.ComponentName;
 import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
 import android.os.IBinder;
 import android.os.RemoteException;
 import android.os.ServiceManager;
@@ -79,18 +76,15 @@ public final class BluetoothPan implements BluetoothProfile {
      */
     public static final String EXTRA_LOCAL_ROLE = "android.bluetooth.pan.extra.LOCAL_ROLE";
 
-    public static final int PAN_ROLE_NONE = 0;
     /**
      * The local device is acting as a Network Access Point.
      */
     public static final int LOCAL_NAP_ROLE = 1;
-    public static final int REMOTE_NAP_ROLE = 1;
 
     /**
      * The local device is acting as a PAN User.
      */
     public static final int LOCAL_PANU_ROLE = 2;
-    public static final int REMOTE_PANU_ROLE = 2;
 
     /**
      * Return codes for the connect and disconnect Bluez / Dbus calls.
@@ -118,10 +112,9 @@ public final class BluetoothPan implements BluetoothProfile {
      */
     public static final int PAN_OPERATION_SUCCESS = 1004;
 
-    private Context mContext;
     private ServiceListener mServiceListener;
     private BluetoothAdapter mAdapter;
-    private IBluetoothPan mPanService;
+    private IBluetooth mPanService;
 
     /**
      * Create a BluetoothPan proxy object for interacting with the local
@@ -129,66 +122,29 @@ public final class BluetoothPan implements BluetoothProfile {
      *
      */
     /*package*/ BluetoothPan(Context context, ServiceListener l) {
-        mContext = context;
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
         mServiceListener = l;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
-        try {
-            mAdapter.getBluetoothManager().registerStateChangeCallback(mStateChangeCallback);
-        } catch (RemoteException re) {
-            Log.w(TAG,"Unable to register BluetoothStateChangeCallback",re);
-        }
-        Log.d(TAG, "BluetoothPan() call bindService");
-        if (!context.bindService(new Intent(IBluetoothPan.class.getName()),
-                                 mConnection, 0)) {
-            Log.e(TAG, "Could not bind to Bluetooth HID Service");
+        if (b != null) {
+            mPanService = IBluetooth.Stub.asInterface(b);
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.PAN, this);
+            }
+        } else {
+            Log.w(TAG, "Bluetooth Service not available!");
+
+            // Instead of throwing an exception which prevents people from going
+            // into Wireless settings in the emulator. Let it crash later when it is actually used.
+            mPanService = null;
         }
         Log.d(TAG, "BluetoothPan(), bindService called");
     }
 
     /*package*/ void close() {
         if (VDBG) log("close()");
-        if (mConnection != null) {
-            mContext.unbindService(mConnection);
-            mConnection = null;
-        }
         mServiceListener = null;
-        try {
-            mAdapter.getBluetoothManager().unregisterStateChangeCallback(mStateChangeCallback);
-        } catch (RemoteException re) {
-            Log.w(TAG,"Unable to register BluetoothStateChangeCallback",re);
-        }
     }
 
-    protected void finalize() {
-        close();
-    }
-
-    private IBluetoothStateChangeCallback mStateChangeCallback = new IBluetoothStateChangeCallback.Stub() {
-
-        @Override
-        public void onBluetoothStateChange(boolean on) throws RemoteException {
-            //Handle enable request to bind again.
-            if (on) {
-                Log.d(TAG, "onBluetoothStateChange(on) call bindService");
-                if (!mContext.bindService(new Intent(IBluetoothPan.class.getName()),
-                                     mConnection, 0)) {
-                    Log.e(TAG, "Could not bind to Bluetooth HID Service");
-                }
-                Log.d(TAG, "BluetoothPan(), bindService called");
-            } else {
-                if (VDBG) Log.d(TAG,"Unbinding service...");
-                synchronized (mConnection) {
-                    try {
-                        mPanService = null;
-                        mContext.unbindService(mConnection);
-                    } catch (Exception re) {
-                        Log.e(TAG,"",re);
-                    }
-                }
-            }
-        }
-    };
-
     /**
      * Initiate connection to a profile of the remote bluetooth device.
      *
@@ -212,7 +168,7 @@ public final class BluetoothPan implements BluetoothProfile {
         if (mPanService != null && isEnabled() &&
             isValidDevice(device)) {
             try {
-                return mPanService.connect(device);
+                return mPanService.connectPanDevice(device);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return false;
@@ -253,7 +209,7 @@ public final class BluetoothPan implements BluetoothProfile {
         if (mPanService != null && isEnabled() &&
             isValidDevice(device)) {
             try {
-                return mPanService.disconnect(device);
+                return mPanService.disconnectPanDevice(device);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return false;
@@ -270,7 +226,7 @@ public final class BluetoothPan implements BluetoothProfile {
         if (VDBG) log("getConnectedDevices()");
         if (mPanService != null && isEnabled()) {
             try {
-                return mPanService.getConnectedDevices();
+                return mPanService.getConnectedPanDevices();
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return new ArrayList<BluetoothDevice>();
@@ -287,7 +243,7 @@ public final class BluetoothPan implements BluetoothProfile {
         if (VDBG) log("getDevicesMatchingStates()");
         if (mPanService != null && isEnabled()) {
             try {
-                return mPanService.getDevicesMatchingConnectionStates(states);
+                return mPanService.getPanDevicesMatchingConnectionStates(states);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return new ArrayList<BluetoothDevice>();
@@ -305,7 +261,7 @@ public final class BluetoothPan implements BluetoothProfile {
         if (mPanService != null && isEnabled()
             && isValidDevice(device)) {
             try {
-                return mPanService.getConnectionState(device);
+                return mPanService.getPanDeviceConnectionState(device);
             } catch (RemoteException e) {
                 Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
                 return BluetoothProfile.STATE_DISCONNECTED;
@@ -334,25 +290,6 @@ public final class BluetoothPan implements BluetoothProfile {
         return false;
     }
 
-    private ServiceConnection mConnection = new ServiceConnection() {
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            if (DBG) Log.d(TAG, "BluetoothPAN Proxy object connected");
-            mPanService = IBluetoothPan.Stub.asInterface(service);
-
-            if (mServiceListener != null) {
-                mServiceListener.onServiceConnected(BluetoothProfile.PAN,
-                                                    BluetoothPan.this);
-            }
-        }
-        public void onServiceDisconnected(ComponentName className) {
-            if (DBG) Log.d(TAG, "BluetoothPAN Proxy object disconnected");
-            mPanService = null;
-            if (mServiceListener != null) {
-                mServiceListener.onServiceDisconnected(BluetoothProfile.PAN);
-            }
-        }
-    };
-
     private boolean isEnabled() {
        if (mAdapter.getState() == BluetoothAdapter.STATE_ON) return true;
        return false;
diff --git a/core/java/android/bluetooth/BluetoothPbap.java b/core/java/android/bluetooth/BluetoothPbap.java
index b5280e5..f3da9b4 100644
--- a/core/java/android/bluetooth/BluetoothPbap.java
+++ b/core/java/android/bluetooth/BluetoothPbap.java
@@ -71,7 +71,6 @@ public class BluetoothPbap {
     private IBluetoothPbap mService;
     private final Context mContext;
     private ServiceListener mServiceListener;
-    private BluetoothAdapter mAdapter;
 
     /** There was an error trying to obtain the state */
     public static final int STATE_ERROR        = -1;
@@ -110,54 +109,12 @@ public class BluetoothPbap {
         public void onServiceDisconnected();
     }
 
-    final private IBluetoothStateChangeCallback mBluetoothStateChangeCallback =
-            new IBluetoothStateChangeCallback.Stub() {
-                public void onBluetoothStateChange(boolean up) {
-                    if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up);
-                    if (!up) {
-                        if (VDBG) Log.d(TAG,"Unbinding service...");
-                        synchronized (mConnection) {
-                            try {
-                                mService = null;
-                                mContext.unbindService(mConnection);
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    } else {
-                        synchronized (mConnection) {
-                            try {
-                                if (mService == null) {
-                                    if (VDBG) Log.d(TAG,"Binding service...");
-                                    if (!mContext.bindService(
-                                                        new Intent(IBluetoothPbap.class.getName()),
-                                                        mConnection, 0)) {
-                                        Log.e(TAG, "Could not bind to Bluetooth PBAP Service");
-                                    }
-                                }
-                            } catch (Exception re) {
-                                Log.e(TAG,"",re);
-                            }
-                        }
-                    }
-                }
-        };
-
     /**
      * Create a BluetoothPbap proxy object.
      */
     public BluetoothPbap(Context context, ServiceListener l) {
         mContext = context;
         mServiceListener = l;
-        mAdapter = BluetoothAdapter.getDefaultAdapter();
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.registerStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (RemoteException e) {
-                Log.e(TAG,"",e);
-            }
-        }
         if (!context.bindService(new Intent(IBluetoothPbap.class.getName()), mConnection, 0)) {
             Log.e(TAG, "Could not bind to Bluetooth Pbap Service");
         }
@@ -178,25 +135,9 @@ public class BluetoothPbap {
      * are ok.
      */
     public synchronized void close() {
-        IBluetoothManager mgr = mAdapter.getBluetoothManager();
-        if (mgr != null) {
-            try {
-                mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
-            } catch (Exception e) {
-                Log.e(TAG,"",e);
-            }
-        }
-
-        synchronized (mConnection) {
-            if (mService != null) {
-                try {
-                    mService = null;
-                    mContext.unbindService(mConnection);
-                    mConnection = null;
-                } catch (Exception re) {
-                    Log.e(TAG,"",re);
-                }
-            }
+        if (mConnection != null) {
+            mContext.unbindService(mConnection);
+            mConnection = null;
         }
         mServiceListener = null;
     }
diff --git a/core/java/android/bluetooth/BluetoothProfileState.java b/core/java/android/bluetooth/BluetoothProfileState.java
new file mode 100644
index 0000000..b0c0a0b
--- /dev/null
+++ b/core/java/android/bluetooth/BluetoothProfileState.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.bluetooth;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Message;
+import android.util.Log;
+
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+/**
+ * This state machine is used to serialize the connections
+ * to a particular profile. Currently, we only allow one device
+ * to be connected to a particular profile.
+ * States:
+ *      {@link StableState} : No pending commands. Send the
+ *      command to the appropriate remote device specific state machine.
+ *
+ *      {@link PendingCommandState} : A profile connection / disconnection
+ *      command is being executed. This will result in a profile state
+ *      change. Defer all commands.
+ * @hide
+ */
+
+public class BluetoothProfileState extends StateMachine {
+    private static final boolean DBG = true;
+    private static final String TAG = "BluetoothProfileState";
+
+    public static final int HFP = 0;
+    public static final int A2DP = 1;
+    public static final int HID = 2;
+
+    static final int TRANSITION_TO_STABLE = 100;
+
+    private int mProfile;
+    private BluetoothDevice mPendingDevice;
+    private PendingCommandState mPendingCommandState = new PendingCommandState();
+    private StableState mStableState = new StableState();
+
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (device == null) {
+                return;
+            }
+            if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                if (mProfile == HFP && (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED)) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                if (mProfile == A2DP && (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED)) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED)) {
+                int newState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                if (mProfile == HID && (newState == BluetoothProfile.STATE_CONNECTED ||
+                    newState == BluetoothProfile.STATE_DISCONNECTED)) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED)) {
+                if (device.equals(mPendingDevice)) {
+                    sendMessage(TRANSITION_TO_STABLE);
+                }
+            }
+        }
+    };
+
+    public BluetoothProfileState(Context context, int profile) {
+        super("BluetoothProfileState:" + profile);
+        mProfile = profile;
+        addState(mStableState);
+        addState(mPendingCommandState);
+        setInitialState(mStableState);
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
+        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+        context.registerReceiver(mBroadcastReceiver, filter);
+    }
+
+    private class StableState extends State {
+        @Override
+        public void enter() {
+            log("Entering Stable State");
+            mPendingDevice = null;
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            if (msg.what != TRANSITION_TO_STABLE) {
+                transitionTo(mPendingCommandState);
+            }
+            return true;
+        }
+    }
+
+    private class PendingCommandState extends State {
+        @Override
+        public void enter() {
+            log("Entering PendingCommandState State");
+            dispatchMessage(getCurrentMessage());
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            if (msg.what == TRANSITION_TO_STABLE) {
+                transitionTo(mStableState);
+            } else {
+                dispatchMessage(msg);
+            }
+            return true;
+        }
+
+        private void dispatchMessage(Message msg) {
+            BluetoothDeviceProfileState deviceProfileMgr =
+              (BluetoothDeviceProfileState)msg.obj;
+            int cmd = msg.arg1;
+            if (mPendingDevice == null || mPendingDevice.equals(deviceProfileMgr.getDevice())) {
+                mPendingDevice = deviceProfileMgr.getDevice();
+                deviceProfileMgr.sendMessage(cmd);
+            } else {
+                Message deferMsg = new Message();
+                deferMsg.arg1 = cmd;
+                deferMsg.obj = deviceProfileMgr;
+                deferMessage(deferMsg);
+            }
+        }
+    }
+
+    private void log(String message) {
+        if (DBG) {
+            Log.i(TAG, "Message:" + message);
+        }
+    }
+}
diff --git a/core/java/android/bluetooth/BluetoothServerSocket.java b/core/java/android/bluetooth/BluetoothServerSocket.java
index 49601c5..8b9fdb0 100644
--- a/core/java/android/bluetooth/BluetoothServerSocket.java
+++ b/core/java/android/bluetooth/BluetoothServerSocket.java
@@ -17,8 +17,6 @@
 package android.bluetooth;
 
 import android.os.Handler;
-import android.os.Message;
-import android.os.ParcelUuid;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -88,23 +86,6 @@ public final class BluetoothServerSocket implements Closeable {
     }
 
     /**
-     * Construct a socket for incoming connections.
-     * @param type    type of socket
-     * @param auth    require the remote device to be authenticated
-     * @param encrypt require the connection to be encrypted
-     * @param port    remote port
-     * @param uuid    uuid
-     * @throws IOException On error, for example Bluetooth not available, or
-     *                     insufficient privileges
-     */
-    /*package*/ BluetoothServerSocket(int type, boolean auth, boolean encrypt, int port, ParcelUuid uuid)
-            throws IOException {
-        mSocket = new BluetoothSocket(type, -1, auth, encrypt, null, port, uuid);
-        mChannel = mSocket.getPort();
-    }
-
-
-    /**
      * Block until a connection is established.
      * <p>Returns a connected {@link BluetoothSocket} on successful connection.
      * <p>Once this call returns, it can be called again to accept subsequent
@@ -152,9 +133,6 @@ public final class BluetoothServerSocket implements Closeable {
         mHandler = handler;
         mMessage = message;
     }
-    /*package*/ void setServiceName(String ServiceName) {
-        mSocket.setServiceName(ServiceName);
-    }
     /**
      * Returns the channel on which this socket is bound.
      * @hide
diff --git a/core/java/android/bluetooth/BluetoothSocket.java b/core/java/android/bluetooth/BluetoothSocket.java
index 8029a1a..38daea7 100644
--- a/core/java/android/bluetooth/BluetoothSocket.java
+++ b/core/java/android/bluetooth/BluetoothSocket.java
@@ -16,25 +16,16 @@
 
 package android.bluetooth;
 
-import android.os.IBinder;
+import android.bluetooth.IBluetoothCallback;
 import android.os.ParcelUuid;
-import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
-import android.os.ServiceManager;
 import android.util.Log;
 
 import java.io.Closeable;
-import java.io.FileDescriptor;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.util.List;
-import java.util.UUID;
-import android.net.LocalSocket;
-import java.nio.ByteOrder;
-import java.nio.ByteBuffer;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 /**
  * A connected or connecting Bluetooth socket.
  *
@@ -109,22 +100,14 @@ public final class BluetoothSocket implements Closeable {
     private final boolean mEncrypt;
     private final BluetoothInputStream mInputStream;
     private final BluetoothOutputStream mOutputStream;
-    private final ParcelUuid mUuid;
-    private ParcelFileDescriptor mPfd;
-    private LocalSocket mSocket;
-    private InputStream mSocketIS;
-    private OutputStream mSocketOS;
-    private int mPort;  /* RFCOMM channel or L2CAP psm */
-    private int mFd;
-    private String mServiceName;
-    private static int PROXY_CONNECTION_TIMEOUT = 5000;
+    private final SdpHelper mSdp;
 
     private static int SOCK_SIGNAL_SIZE = 16;
+    private int mPort;  /* RFCOMM channel or L2CAP psm */
 
     private enum SocketState {
         INIT,
         CONNECTED,
-        LISTENING,
         CLOSED,
     }
 
@@ -132,7 +115,10 @@ public final class BluetoothSocket implements Closeable {
     private volatile SocketState mSocketState;
 
     /** protects mSocketState */
-    //private final ReentrantReadWriteLock mLock;
+    private final ReentrantReadWriteLock mLock;
+
+    /** used by native code only */
+    private int mSocketData;
 
     /**
      * Construct a BluetoothSocket.
@@ -153,53 +139,32 @@ public final class BluetoothSocket implements Closeable {
                 throw new IOException("Invalid RFCOMM channel: " + port);
             }
         }
-        if(uuid != null)
-            mUuid = uuid;
-        else mUuid = new ParcelUuid(new UUID(0, 0));
+        if (uuid == null) {
+            mPort = port;
+            mSdp = null;
+        } else {
+            mSdp = new SdpHelper(device, uuid);
+            mPort = -1;
+        }
         mType = type;
         mAuth = auth;
         mEncrypt = encrypt;
         mDevice = device;
-        mPort = port;
-        mFd = fd;
-
-        mSocketState = SocketState.INIT;
-
         if (device == null) {
-            // Server socket
-            mAddress = BluetoothAdapter.getDefaultAdapter().getAddress();
+            mAddress = null;
         } else {
             // Remote socket
             mAddress = device.getAddress();
         }
+        if (fd == -1) {
+            initSocketNative();
+        } else {
+            initSocketFromFdNative(fd);
+        }
         mInputStream = new BluetoothInputStream(this);
         mOutputStream = new BluetoothOutputStream(this);
-    }
-    private BluetoothSocket(BluetoothSocket s) {
-        mUuid = s.mUuid;
-        mType = s.mType;
-        mAuth = s.mAuth;
-        mEncrypt = s.mEncrypt;
-        mPort = s.mPort;
-        mInputStream = new BluetoothInputStream(this);
-        mOutputStream = new BluetoothOutputStream(this);
-        mServiceName = s.mServiceName;
-    }
-    private BluetoothSocket acceptSocket(String RemoteAddr) throws IOException {
-        BluetoothSocket as = new BluetoothSocket(this);
-        as.mSocketState = SocketState.CONNECTED;
-        FileDescriptor[] fds = mSocket.getAncillaryFileDescriptors();
-        if (VDBG) Log.d(TAG, "socket fd passed by stack  fds: " + fds);
-        if(fds == null || fds.length != 1) {
-            Log.e(TAG, "socket fd passed from stack failed, fds: " + fds);
-            throw new IOException("bt socket acept failed");
-        }
-        as.mSocket = new LocalSocket(fds[0]);
-        as.mSocketIS = as.mSocket.getInputStream();
-        as.mSocketOS = as.mSocket.getOutputStream();
-        as.mAddress = RemoteAddr;
-        as.mDevice = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(RemoteAddr);
-        return as;
+        mSocketState = SocketState.INIT;
+        mLock = new ReentrantReadWriteLock();
     }
     /**
      * Construct a BluetoothSocket from address. Used by native code.
@@ -226,13 +191,67 @@ public final class BluetoothSocket implements Closeable {
             super.finalize();
         }
     }
-    private int getSecurityFlags() {
-        int flags = 0;
-        if(mAuth)
-            flags |= SEC_FLAG_AUTH;
-        if(mEncrypt)
-            flags |= SEC_FLAG_ENCRYPT;
-        return flags;
+
+    /**
+     * Attempt to connect to a remote device.
+     * <p>This method will block until a connection is made or the connection
+     * fails. If this method returns without an exception then this socket
+     * is now connected.
+     * <p>Creating new connections to
+     * remote Bluetooth devices should not be attempted while device discovery
+     * is in progress. Device discovery is a heavyweight procedure on the
+     * Bluetooth adapter and will significantly slow a device connection.
+     * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
+     * discovery. Discovery is not managed by the Activity,
+     * but is run as a system service, so an application should always call
+     * {@link BluetoothAdapter#cancelDiscovery()} even if it
+     * did not directly request a discovery, just to be sure.
+     * <p>{@link #close} can be used to abort this call from another thread.
+     * @throws IOException on error, for example connection failure
+     */
+    public void connect() throws IOException {
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+
+            if (mSdp != null) {
+                mPort = mSdp.doSdp();  // blocks
+            }
+
+            connectNative();  // blocks
+            mSocketState = SocketState.CONNECTED;
+        } finally {
+            mLock.readLock().unlock();
+        }
+    }
+
+    /**
+     * Immediately close this socket, and release all associated resources.
+     * <p>Causes blocked calls on this socket in other threads to immediately
+     * throw an IOException.
+     */
+    public void close() throws IOException {
+        // abort blocking operations on the socket
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) return;
+            if (mSdp != null) {
+                mSdp.cancel();
+            }
+            abortNative();
+        } finally {
+            mLock.readLock().unlock();
+        }
+
+        // all native calls are guaranteed to immediately return after
+        // abortNative(), so this lock should immediately acquire
+        mLock.writeLock().lock();
+        try {
+            mSocketState = SocketState.CLOSED;
+            destroyNative();
+        } finally {
+            mLock.writeLock().unlock();
+        }
     }
 
     /**
@@ -272,63 +291,7 @@ public final class BluetoothSocket implements Closeable {
      *         false if not connected
      */
     public boolean isConnected() {
-        return mSocketState == SocketState.CONNECTED;
-    }
-
-    /*package*/ void setServiceName(String name) {
-        mServiceName = name;
-    }
-
-    /**
-     * Attempt to connect to a remote device.
-     * <p>This method will block until a connection is made or the connection
-     * fails. If this method returns without an exception then this socket
-     * is now connected.
-     * <p>Creating new connections to
-     * remote Bluetooth devices should not be attempted while device discovery
-     * is in progress. Device discovery is a heavyweight procedure on the
-     * Bluetooth adapter and will significantly slow a device connection.
-     * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
-     * discovery. Discovery is not managed by the Activity,
-     * but is run as a system service, so an application should always call
-     * {@link BluetoothAdapter#cancelDiscovery()} even if it
-     * did not directly request a discovery, just to be sure.
-     * <p>{@link #close} can be used to abort this call from another thread.
-     * @throws IOException on error, for example connection failure
-     */
-    public void connect() throws IOException {
-        if (mDevice == null) throw new IOException("Connect is called on null device");
-
-        try {
-            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
-            IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
-            if (bluetoothProxy == null) throw new IOException("Bluetooth is off");
-            mPfd = bluetoothProxy.connectSocket(mDevice, mType,
-                    mUuid, mPort, getSecurityFlags());
-            synchronized(this)
-            {
-                if (DBG) Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
-                if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
-                if (mPfd == null) throw new IOException("bt socket connect failed");
-                FileDescriptor fd = mPfd.getFileDescriptor();
-                mSocket = new LocalSocket(fd);
-                mSocketIS = mSocket.getInputStream();
-                mSocketOS = mSocket.getOutputStream();
-            }
-            int channel = readInt(mSocketIS);
-            if (channel <= 0)
-                throw new IOException("bt socket connect failed");
-            mPort = channel;
-            waitSocketSignal(mSocketIS);
-            synchronized(this)
-            {
-                if (mSocketState == SocketState.CLOSED)
-                    throw new IOException("bt socket closed");
-                mSocketState = SocketState.CONNECTED;
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, Log.getStackTraceString(new Throwable()));
-        }
+        return (mSocketState == SocketState.CONNECTED);
     }
 
     /**
@@ -336,174 +299,129 @@ public final class BluetoothSocket implements Closeable {
      * so that BluetoothAdapter can check the error code for EADDRINUSE
      */
     /*package*/ int bindListen() {
-        int ret;
-        if (mSocketState == SocketState.CLOSED) return EBADFD;
-        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
-        if (bluetoothProxy == null) {
-            Log.e(TAG, "bindListen fail, reason: bluetooth is off");
-            return -1;
-        }
-        try {
-            mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName,
-                    mUuid, mPort, getSecurityFlags());
-        } catch (RemoteException e) {
-            Log.e(TAG, Log.getStackTraceString(new Throwable()));
-            return -1;
-        }
-
-        // read out port number
+        mLock.readLock().lock();
         try {
-            synchronized(this) {
-                if (VDBG) Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " +
-                                mPfd);
-                if(mSocketState != SocketState.INIT) return EBADFD;
-                if(mPfd == null) return -1;
-                FileDescriptor fd = mPfd.getFileDescriptor();
-                if (VDBG) Log.d(TAG, "bindListen(), new LocalSocket ");
-                mSocket = new LocalSocket(fd);
-                if (VDBG) Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
-                mSocketIS = mSocket.getInputStream();
-                mSocketOS = mSocket.getOutputStream();
-            }
-            if (VDBG) Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
-            int channel = readInt(mSocketIS);
-            synchronized(this) {
-                if(mSocketState == SocketState.INIT)
-                    mSocketState = SocketState.LISTENING;
-            }
-            if (VDBG) Log.d(TAG, "channel: " + channel);
-            if (mPort == -1) {
-                mPort = channel;
-            } // else ASSERT(mPort == channel)
-            ret = 0;
-        } catch (IOException e) {
-            Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
-            return -1;
+            if (mSocketState == SocketState.CLOSED) return EBADFD;
+            return bindListenNative();
+        } finally {
+            mLock.readLock().unlock();
         }
-        return ret;
     }
 
     /*package*/ BluetoothSocket accept(int timeout) throws IOException {
-        BluetoothSocket acceptedSocket;
-        if (mSocketState != SocketState.LISTENING) throw new IOException("bt socket is not in listen state");
-        if(timeout > 0) {
-            Log.d(TAG, "accept() set timeout (ms):" + timeout);
-           mSocket.setSoTimeout(timeout);
-        }
-        String RemoteAddr = waitSocketSignal(mSocketIS);
-        if(timeout > 0)
-            mSocket.setSoTimeout(0);
-        synchronized(this)
-        {
-            if (mSocketState != SocketState.LISTENING)
-                throw new IOException("bt socket is not in listen state");
-            acceptedSocket = acceptSocket(RemoteAddr);
-            //quick drop the reference of the file handle
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+
+            BluetoothSocket acceptedSocket = acceptNative(timeout);
+            mSocketState = SocketState.CONNECTED;
+            return acceptedSocket;
+        } finally {
+            mLock.readLock().unlock();
         }
-        return acceptedSocket;
     }
 
     /*package*/ int available() throws IOException {
-        if (VDBG) Log.d(TAG, "available: " + mSocketIS);
-        return mSocketIS.available();
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+            return availableNative();
+        } finally {
+            mLock.readLock().unlock();
+        }
     }
 
     /*package*/ int read(byte[] b, int offset, int length) throws IOException {
-
-            if (VDBG) Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
-            int ret = mSocketIS.read(b, offset, length);
-            if(ret < 0)
-                throw new IOException("bt socket closed, read return: " + ret);
-            if (VDBG) Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
-            return ret;
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+            return readNative(b, offset, length);
+        } finally {
+            mLock.readLock().unlock();
+        }
     }
 
     /*package*/ int write(byte[] b, int offset, int length) throws IOException {
-
-            if (VDBG) Log.d(TAG, "write: " + mSocketOS + " length: " + length);
-            mSocketOS.write(b, offset, length);
-            // There is no good way to confirm since the entire process is asynchronous anyway
-            if (VDBG) Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
-            return length;
-    }
-
-    @Override
-    public void close() throws IOException {
-        if (VDBG) Log.d(TAG, "close() in, this: " + this + ", channel: " + mPort + ", state: " + mSocketState);
-        if(mSocketState == SocketState.CLOSED)
-            return;
-        else
-        {
-            synchronized(this)
-            {
-                 if(mSocketState == SocketState.CLOSED)
-                    return;
-                 mSocketState = SocketState.CLOSED;
-                 if (VDBG) Log.d(TAG, "close() this: " + this + ", channel: " + mPort + ", mSocketIS: " + mSocketIS +
-                        ", mSocketOS: " + mSocketOS + "mSocket: " + mSocket);
-                 if(mSocket != null) {
-                    if (VDBG) Log.d(TAG, "Closing mSocket: " + mSocket);
-                    mSocket.shutdownInput();
-                    mSocket.shutdownOutput();
-                    mSocket.close();
-                    mSocket = null;
-                }
-                if(mPfd != null)
-                    mPfd.detachFd();
-           }
+        mLock.readLock().lock();
+        try {
+            if (mSocketState == SocketState.CLOSED) throw new IOException("socket closed");
+            return writeNative(b, offset, length);
+        } finally {
+            mLock.readLock().unlock();
         }
     }
 
-    /*package */ void removeChannel() {
-    }
+    private native void initSocketNative() throws IOException;
+    private native void initSocketFromFdNative(int fd) throws IOException;
+    private native void connectNative() throws IOException;
+    private native int bindListenNative();
+    private native BluetoothSocket acceptNative(int timeout) throws IOException;
+    private native int availableNative() throws IOException;
+    private native int readNative(byte[] b, int offset, int length) throws IOException;
+    private native int writeNative(byte[] b, int offset, int length) throws IOException;
+    private native void abortNative() throws IOException;
+    private native void destroyNative() throws IOException;
+    /**
+     * Throws an IOException for given posix errno. Done natively so we can
+     * use strerr to convert to string error.
+     */
+    /*package*/ native void throwErrnoNative(int errno) throws IOException;
 
-    /*package */ int getPort() {
-        return mPort;
-    }
-    private String convertAddr(final byte[] addr)  {
-        return String.format("%02X:%02X:%02X:%02X:%02X:%02X",
-                addr[0] , addr[1], addr[2], addr[3] , addr[4], addr[5]);
-    }
-    private String waitSocketSignal(InputStream is) throws IOException {
-        byte [] sig = new byte[SOCK_SIGNAL_SIZE];
-        int ret = readAll(is, sig);
-        if (VDBG) Log.d(TAG, "waitSocketSignal read 16 bytes signal ret: " + ret);
-        ByteBuffer bb = ByteBuffer.wrap(sig);
-        bb.order(ByteOrder.nativeOrder());
-        int size = bb.getShort();
-        if(size != SOCK_SIGNAL_SIZE)
-            throw new IOException("Connection failure, wrong signal size: " + size);
-        byte [] addr = new byte[6];
-        bb.get(addr);
-        int channel = bb.getInt();
-        int status = bb.getInt();
-        String RemoteAddr = convertAddr(addr);
-        if (VDBG) Log.d(TAG, "waitSocketSignal: sig size: " + size + ", remote addr: "
-                + RemoteAddr + ", channel: " + channel + ", status: " + status);
-        if(status != 0)
-            throw new IOException("Connection failure, status: " + status);
-        return RemoteAddr;
-    }
-    private int readAll(InputStream is, byte[] b) throws IOException {
-        int left = b.length;
-        while(left > 0) {
-            int ret = is.read(b, b.length - left, left);
-            if(ret <= 0)
-                 throw new IOException("read failed, socket might closed or timeout, read ret: " + ret);
-            left -= ret;
-            if(left != 0)
-                Log.w(TAG, "readAll() looping, read partial size: " + (b.length - left) +
-                            ", expect size: " + b.length);
+    /**
+     * Helper to perform blocking SDP lookup.
+     */
+    private static class SdpHelper extends IBluetoothCallback.Stub {
+        private final IBluetooth service;
+        private final ParcelUuid uuid;
+        private final BluetoothDevice device;
+        private int channel;
+        private boolean canceled;
+        public SdpHelper(BluetoothDevice device, ParcelUuid uuid) {
+            service = BluetoothDevice.getService();
+            this.device = device;
+            this.uuid = uuid;
+            canceled = false;
         }
-        return b.length;
-    }
+        /**
+         * Returns the RFCOMM channel for the UUID, or throws IOException
+         * on failure.
+         */
+        public synchronized int doSdp() throws IOException {
+            if (canceled) throw new IOException("Service discovery canceled");
+            channel = -1;
+
+            boolean inProgress = false;
+            try {
+                inProgress = service.fetchRemoteUuids(device.getAddress(), uuid, this);
+            } catch (RemoteException e) {Log.e(TAG, "", e);}
+
+            if (!inProgress) throw new IOException("Unable to start Service Discovery");
 
-    private int readInt(InputStream is) throws IOException {
-        byte[] ibytes = new byte[4];
-        int ret = readAll(is, ibytes);
-        if (VDBG) Log.d(TAG, "inputStream.read ret: " + ret);
-        ByteBuffer bb = ByteBuffer.wrap(ibytes);
-        bb.order(ByteOrder.nativeOrder());
-        return bb.getInt();
+            try {
+                /* 12 second timeout as a precaution - onRfcommChannelFound
+                 * should always occur before the timeout */
+                wait(12000);   // block
+
+            } catch (InterruptedException e) {}
+
+            if (canceled) throw new IOException("Service discovery canceled");
+            if (channel < 1) throw new IOException("Service discovery failed");
+
+            return channel;
+        }
+        /** Object cannot be re-used after calling cancel() */
+        public synchronized void cancel() {
+            if (!canceled) {
+                canceled = true;
+                channel = -1;
+                notifyAll();  // unblock
+            }
+        }
+        public synchronized void onRfcommChannelFound(int channel) {
+            if (!canceled) {
+                this.channel = channel;
+                notifyAll();  // unblock
+            }
+        }
     }
 }
diff --git a/core/java/android/bluetooth/BluetoothTetheringDataTracker.java b/core/java/android/bluetooth/BluetoothTetheringDataTracker.java
index 063e5a8..80b72fa 100644
--- a/core/java/android/bluetooth/BluetoothTetheringDataTracker.java
+++ b/core/java/android/bluetooth/BluetoothTetheringDataTracker.java
@@ -16,9 +16,6 @@
 
 package android.bluetooth;
 
-import android.os.IBinder;
-import android.os.ServiceManager;
-import android.os.INetworkManagementService;
 import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.DhcpInfoInternal;
@@ -31,11 +28,6 @@ import android.net.NetworkUtils;
 import android.os.Handler;
 import android.os.Message;
 import android.util.Log;
-import java.net.InterfaceAddress;
-import android.net.LinkAddress;
-import android.net.RouteInfo;
-import java.net.Inet4Address;
-import android.os.SystemProperties;
 
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -64,6 +56,7 @@ public class BluetoothTetheringDataTracker implements NetworkStateTracker {
     private NetworkInfo mNetworkInfo;
 
     private BluetoothPan mBluetoothPan;
+    private BluetoothDevice mDevice;
     private static String mIface;
     private Thread mDhcpThread;
     /* For sending events to connectivity service handler */
@@ -275,91 +268,39 @@ public class BluetoothTetheringDataTracker implements NetworkStateTracker {
         return "net.tcp.buffersize.wifi";
     }
 
-    private static short countPrefixLength(byte [] mask) {
-        short count = 0;
-        for (byte b : mask) {
-            for (int i = 0; i < 8; ++i) {
-                if ((b & (1 << i)) != 0) {
-                    ++count;
-                }
-            }
-        }
-        return count;
-    }
 
-
-    private boolean readLinkProperty(String iface) {
-        String DhcpPrefix = "dhcp." + iface + ".";
-        String ip = SystemProperties.get(DhcpPrefix + "ipaddress");
-        String dns1 = SystemProperties.get(DhcpPrefix + "dns1");
-        String dns2 = SystemProperties.get(DhcpPrefix + "dns2");
-        String gateway = SystemProperties.get(DhcpPrefix + "gateway");
-        String mask = SystemProperties.get(DhcpPrefix + "mask");
-        if(ip.isEmpty() || gateway.isEmpty()) {
-            Log.e(TAG, "readLinkProperty, ip: " +  ip + ", gateway: " + gateway + ", can not be empty");
-            return false;
-        }
-        int PrefixLen = countPrefixLength(NetworkUtils.numericToInetAddress(mask).getAddress());
-        mLinkProperties.addLinkAddress(new LinkAddress(NetworkUtils.numericToInetAddress(ip), PrefixLen));
-        RouteInfo ri = new RouteInfo(NetworkUtils.numericToInetAddress(gateway));
-        mLinkProperties.addRoute(ri);
-        if(!dns1.isEmpty())
-            mLinkProperties.addDns(NetworkUtils.numericToInetAddress(dns1));
-        if(!dns2.isEmpty())
-            mLinkProperties.addDns(NetworkUtils.numericToInetAddress(dns2));
-        mLinkProperties.setInterfaceName(iface);
-        return true;
-    }
-    public synchronized void startReverseTether(String iface) {
+    public synchronized void startReverseTether(String iface, BluetoothDevice device) {
         mIface = iface;
         if (DBG) Log.d(TAG, "startReverseTether mCsHandler: " + mCsHandler);
+        mDevice = device;
          mDhcpThread = new Thread(new Runnable() {
             public void run() {
                 //TODO(): Add callbacks for failure and success case.
                 //Currently this thread runs independently.
-                if (DBG) Log.d(TAG, "startReverseTether mCsHandler: " + mCsHandler);
-                String DhcpResultName = "dhcp." + mIface + ".result";;
-                String result = "";
-                if (VDBG) Log.d(TAG, "waiting for change of sys prop dhcp result: " + DhcpResultName);
-                for(int i = 0; i < 30*5; i++) {
-                    try { Thread.sleep(200); } catch (InterruptedException ie) { return;}
-                    result = SystemProperties.get(DhcpResultName);
-                    if (VDBG) Log.d(TAG, "read " + DhcpResultName + ": " + result);
-                    if(result.equals("failed")) {
-                        Log.e(TAG, "startReverseTether, failed to start dhcp service");
-                        return;
-                    }
-                    if(result.equals("ok")) {
-                        if (VDBG) Log.d(TAG, "startReverseTether, dhcp resut: " + result);
-                        if(readLinkProperty(mIface)) {
-
-                            mNetworkInfo.setIsAvailable(true);
-                            mNetworkInfo.setDetailedState(DetailedState.CONNECTED, null, null);
-
-                            if (VDBG) Log.d(TAG, "startReverseTether mCsHandler: " + mCsHandler);
-                            if(mCsHandler != null) {
-                                Message msg = mCsHandler.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
-                                msg.sendToTarget();
-
-                                msg = mCsHandler.obtainMessage(EVENT_STATE_CHANGED, mNetworkInfo);
-                                msg.sendToTarget();
-                            }
-                        }
-                        return;
-                    }
+                DhcpInfoInternal dhcpInfoInternal = new DhcpInfoInternal();
+                if (!NetworkUtils.runDhcp(mIface, dhcpInfoInternal)) {
+                    Log.e(TAG, "DHCP request error:" + NetworkUtils.getDhcpError());
+                    return;
                 }
-                Log.e(TAG, "startReverseTether, dhcp failed, resut: " + result);
+                mLinkProperties = dhcpInfoInternal.makeLinkProperties();
+                mLinkProperties.setInterfaceName(mIface);
+
+                mNetworkInfo.setIsAvailable(true);
+                mNetworkInfo.setDetailedState(DetailedState.CONNECTED, null, null);
+
+                Message msg = mCsHandler.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
+                msg.sendToTarget();
+
+                msg = mCsHandler.obtainMessage(EVENT_STATE_CHANGED, mNetworkInfo);
+                msg.sendToTarget();
             }
         });
         mDhcpThread.start();
     }
 
-    public synchronized void stopReverseTether() {
-        //NetworkUtils.stopDhcp(iface);
-        if(mDhcpThread != null && mDhcpThread.isAlive()) {
-            mDhcpThread.interrupt();
-            try { mDhcpThread.join(); } catch (InterruptedException ie) { return; }
-        }
+    public synchronized void stopReverseTether(String iface) {
+        NetworkUtils.stopDhcp(iface);
+
         mLinkProperties.clear();
         mNetworkInfo.setIsAvailable(false);
         mNetworkInfo.setDetailedState(DetailedState.DISCONNECTED, null, null);
diff --git a/core/java/android/bluetooth/HeadsetBase.java b/core/java/android/bluetooth/HeadsetBase.java
new file mode 100644
index 0000000..54ed5ed
--- /dev/null
+++ b/core/java/android/bluetooth/HeadsetBase.java
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.bluetooth;
+
+import android.os.Handler;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import android.util.Log;
+
+/**
+ * The Android Bluetooth API is not finalized, and *will* change. Use at your
+ * own risk.
+ *
+ * The base RFCOMM (service) connection for a headset or handsfree device.
+ *
+ * In the future this class will be removed.
+ *
+ * @hide
+ */
+public final class HeadsetBase {
+    private static final String TAG = "Bluetooth HeadsetBase";
+    private static final boolean DBG = false;
+
+    public static final int RFCOMM_DISCONNECTED = 1;
+
+    public static final int DIRECTION_INCOMING = 1;
+    public static final int DIRECTION_OUTGOING = 2;
+
+    private static int sAtInputCount = 0;  /* TODO: Consider not using a static variable */
+
+    private final BluetoothAdapter mAdapter;
+    private final BluetoothDevice mRemoteDevice;
+    private final String mAddress;  // for native code
+    private final int mRfcommChannel;
+    private int mNativeData;
+    private Thread mEventThread;
+    private volatile boolean mEventThreadInterrupted;
+    private Handler mEventThreadHandler;
+    private int mTimeoutRemainingMs;
+    private final int mDirection;
+    private final long mConnectTimestamp;
+
+    protected AtParser mAtParser;
+
+    private WakeLock mWakeLock;  // held while processing an AT command
+
+    private native static void classInitNative();
+    static {
+        classInitNative();
+    }
+
+    protected void finalize() throws Throwable {
+        try {
+            cleanupNativeDataNative();
+            releaseWakeLock();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private native void cleanupNativeDataNative();
+
+    public HeadsetBase(PowerManager pm, BluetoothAdapter adapter,
+                       BluetoothDevice device, int rfcommChannel) {
+        mDirection = DIRECTION_OUTGOING;
+        mConnectTimestamp = System.currentTimeMillis();
+        mAdapter = adapter;
+        mRemoteDevice = device;
+        mAddress = device.getAddress();
+        mRfcommChannel = rfcommChannel;
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "HeadsetBase");
+        mWakeLock.setReferenceCounted(false);
+        initializeAtParser();
+        // Must be called after this.mAddress is set.
+        initializeNativeDataNative(-1);
+    }
+
+    /* Create from an existing rfcomm connection */
+    public HeadsetBase(PowerManager pm, BluetoothAdapter adapter,
+                       BluetoothDevice device,
+                       int socketFd, int rfcommChannel, Handler handler) {
+        mDirection = DIRECTION_INCOMING;
+        mConnectTimestamp = System.currentTimeMillis();
+        mAdapter = adapter;
+        mRemoteDevice = device;
+        mAddress = device.getAddress();
+        mRfcommChannel = rfcommChannel;
+        mEventThreadHandler = handler;
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "HeadsetBase");
+        mWakeLock.setReferenceCounted(false);
+        initializeAtParser();
+        // Must be called after this.mAddress is set.
+        initializeNativeDataNative(socketFd);
+    }
+
+    private native void initializeNativeDataNative(int socketFd);
+
+    // interface for dealing with special input situations
+    public interface SpecialPDUInputHandler {
+        void handleInput(String input);
+    }
+    public SpecialPDUInputHandler specialPDUInputHandler = null;
+
+    /* Process an incoming AT command line
+     */
+    protected void handleInput(String input) {
+        acquireWakeLock();
+        long timestamp;
+
+        synchronized(HeadsetBase.class) {
+            if (sAtInputCount == Integer.MAX_VALUE) {
+                sAtInputCount = 0;
+            } else {
+                sAtInputCount++;
+            }
+        }
+
+        if (DBG) timestamp = System.currentTimeMillis();
+        AtCommandResult result = mAtParser.process(input);
+        if (DBG) Log.d(TAG, "Processing " + input + " took " +
+                       (System.currentTimeMillis() - timestamp) + " ms");
+
+        if (result.getResultCode() == AtCommandResult.ERROR) {
+            Log.i(TAG, "Error processing <" + input + ">");
+        }
+
+        sendURC(result.toString());
+
+        releaseWakeLock();
+    }
+
+    /**
+     * Register AT commands that are common to all Headset / Handsets. This
+     * function is called by the HeadsetBase constructor.
+     */
+    protected void initializeAtParser() {
+        mAtParser = new AtParser();
+
+        //TODO(): Get rid of this as there are no parsers registered. But because of dependencies
+        // it needs to be done as part of refactoring HeadsetBase and BluetoothHandsfree
+    }
+
+    public AtParser getAtParser() {
+        return mAtParser;
+    }
+
+    public void startEventThread() {
+        mEventThread =
+            new Thread("HeadsetBase Event Thread") {
+                public void run() {
+                    int last_read_error;
+                    while (!mEventThreadInterrupted) {
+
+                        String input;
+                        if (null == specialPDUInputHandler) {
+                            input = readNative(500);
+                            if (input != null) {
+                                handleInput(input);
+                            }
+                        } else {
+                            input = readNativePDUStream((500));
+                            if (input != null) {
+                                specialPDUInputHandler.handleInput(input);
+                            }
+                        }
+                        if (null == input) {
+                            last_read_error = getLastReadStatusNative();
+                            if (last_read_error != 0) {
+                                Log.i(TAG, "headset read error " + last_read_error);
+                                if (mEventThreadHandler != null) {
+                                    mEventThreadHandler.obtainMessage(RFCOMM_DISCONNECTED)
+                                            .sendToTarget();
+                                }
+                                disconnectNative();
+                                break;
+                            }
+                        }
+                    }
+                }
+            };
+        mEventThreadInterrupted = false;
+        mEventThread.start();
+    }
+
+    private native String readNative(int timeout_ms);
+    private native String readNativePDUStream(int timeout_ms);
+    private native int getLastReadStatusNative();
+
+    private void stopEventThread() {
+        mEventThreadInterrupted = true;
+        mEventThread.interrupt();
+        try {
+            mEventThread.join();
+        } catch (java.lang.InterruptedException e) {
+            // FIXME: handle this,
+        }
+        mEventThread = null;
+    }
+
+    public boolean connect(Handler handler) {
+        if (mEventThread == null) {
+            if (!connectNative()) return false;
+            mEventThreadHandler = handler;
+        }
+        return true;
+    }
+    private native boolean connectNative();
+
+    /*
+     * Returns true when either the asynchronous connect is in progress, or
+     * the connect is complete.  Call waitForAsyncConnect() to find out whether
+     * the connect is actually complete, or disconnect() to cancel.
+     */
+
+    public boolean connectAsync() {
+        int ret = connectAsyncNative();
+        return (ret == 0) ? true : false;
+    }
+    private native int connectAsyncNative();
+
+    public int getRemainingAsyncConnectWaitingTimeMs() {
+        return mTimeoutRemainingMs;
+    }
+
+    /*
+     * Returns 1 when an async connect is complete, 0 on timeout, and -1 on
+     * error.  On error, handler will be called, and you need to re-initiate
+     * the async connect.
+     */
+    public int waitForAsyncConnect(int timeout_ms, Handler handler) {
+        int res = waitForAsyncConnectNative(timeout_ms);
+        if (res > 0) {
+            mEventThreadHandler = handler;
+        }
+        return res;
+    }
+    private native int waitForAsyncConnectNative(int timeout_ms);
+
+    public void disconnect() {
+        if (mEventThread != null) {
+            stopEventThread();
+        }
+        disconnectNative();
+    }
+    private native void disconnectNative();
+
+
+    /*
+     * Note that if a remote side disconnects, this method will still return
+     * true until disconnect() is called.  You know when a remote side
+     * disconnects because you will receive the intent
+     * IBluetoothService.REMOTE_DEVICE_DISCONNECTED_ACTION.  If, when you get
+     * this intent, method isConnected() returns true, you know that the
+     * disconnect was initiated by the remote device.
+     */
+
+    public boolean isConnected() {
+        return mEventThread != null;
+    }
+
+    public BluetoothDevice getRemoteDevice() {
+        return mRemoteDevice;
+    }
+
+    public int getDirection() {
+        return mDirection;
+    }
+
+    public long getConnectTimestamp() {
+        return mConnectTimestamp;
+    }
+
+    public synchronized boolean sendURC(String urc) {
+        if (urc.length() > 0) {
+            boolean ret = sendURCNative(urc);
+            return ret;
+        }
+        return true;
+    }
+    private native boolean sendURCNative(String urc);
+    private native boolean sendURCNativeChars(String urc);
+
+    public synchronized boolean sendURCChars(String urc) {
+        if (urc.length() > 0) {
+            boolean ret = sendURCNativeChars(urc);
+            return ret;
+        }
+        return true;
+    }
+
+    private synchronized void acquireWakeLock() {
+        if (!mWakeLock.isHeld()) {
+            mWakeLock.acquire();
+        }
+    }
+
+    private synchronized void releaseWakeLock() {
+        if (mWakeLock.isHeld()) {
+            mWakeLock.release();
+        }
+    }
+
+    public static int getAtInputCount() {
+        return sAtInputCount;
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/core/java/android/bluetooth/IBluetooth.aidl b/core/java/android/bluetooth/IBluetooth.aidl
index d016c26..6075363 100644
--- a/core/java/android/bluetooth/IBluetooth.aidl
+++ b/core/java/android/bluetooth/IBluetooth.aidl
@@ -18,7 +18,9 @@ package android.bluetooth;
 
 import android.bluetooth.IBluetoothCallback;
 import android.bluetooth.IBluetoothStateChangeCallback;
+import android.bluetooth.IBluetoothHealthCallback;
 import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHealthAppConfiguration;
 import android.os.ParcelUuid;
 import android.os.ParcelFileDescriptor;
 
@@ -30,15 +32,15 @@ import android.os.ParcelFileDescriptor;
 interface IBluetooth
 {
     boolean isEnabled();
-    int getState();
+    int getBluetoothState();
     boolean enable();
     boolean enableNoAutoConnect();
-    boolean disable();
+    boolean disable(boolean persistSetting);
 
     String getAddress();
-    ParcelUuid[] getUuids();
-    boolean setName(in String name);
     String getName();
+    boolean setName(in String name);
+    ParcelUuid[] getUuids();
 
     int getScanMode();
     boolean setScanMode(int mode, int duration);
@@ -49,34 +51,77 @@ interface IBluetooth
     boolean startDiscovery();
     boolean cancelDiscovery();
     boolean isDiscovering();
+    byte[] readOutOfBandData();
 
     int getAdapterConnectionState();
     int getProfileConnectionState(int profile);
+    boolean changeApplicationBluetoothState(boolean on,
+                                in IBluetoothStateChangeCallback callback, in
+                                IBinder b);
 
-    BluetoothDevice[] getBondedDevices();
-    boolean createBond(in BluetoothDevice device);
-    boolean cancelBondProcess(in BluetoothDevice device);
-    boolean removeBond(in BluetoothDevice device);
-    int getBondState(in BluetoothDevice device);
+    boolean createBond(in String address);
+    boolean createBondOutOfBand(in String address, in byte[] hash, in byte[] randomizer);
+    boolean cancelBondProcess(in String address);
+    boolean removeBond(in String address);
+    String[] listBonds();
+    int getBondState(in String address);
+    boolean setDeviceOutOfBandData(in String address, in byte[] hash, in byte[] randomizer);
 
-    String getRemoteName(in BluetoothDevice device);
-    String getRemoteAlias(in BluetoothDevice device);
-    boolean setRemoteAlias(in BluetoothDevice device, in String name);
-    int getRemoteClass(in BluetoothDevice device);
-    ParcelUuid[] getRemoteUuids(in BluetoothDevice device);
-    boolean fetchRemoteUuids(in BluetoothDevice device);
+    String getRemoteName(in String address);
+    String getRemoteAlias(in String address);
+    boolean setRemoteAlias(in String address, in String name);
+    int getRemoteClass(in String address);
+    ParcelUuid[] getRemoteUuids(in String address);
+    boolean fetchRemoteUuids(in String address, in ParcelUuid uuid, in IBluetoothCallback callback);
+    int getRemoteServiceChannel(in String address, in ParcelUuid uuid);
 
-    boolean setPin(in BluetoothDevice device, boolean accept, int len, in byte[] pinCode);
-    boolean setPasskey(in BluetoothDevice device, boolean accept, int len, in byte[]
-    passkey);
-    boolean setPairingConfirmation(in BluetoothDevice device, boolean accept);
+    boolean setPin(in String address, in byte[] pin);
+    boolean setPasskey(in String address, int passkey);
+    boolean setPairingConfirmation(in String address, boolean confirm);
+    boolean setRemoteOutOfBandData(in String addres);
+    boolean cancelPairingUserInput(in String address);
 
-    void sendConnectionStateChange(in BluetoothDevice device, int profile, int state, int prevState);
+    boolean setTrust(in String address, in boolean value);
+    boolean getTrustState(in String address);
+    boolean isBluetoothDock(in String address);
 
-    void registerCallback(in IBluetoothCallback callback);
-    void unregisterCallback(in IBluetoothCallback callback);
+    int addRfcommServiceRecord(in String serviceName, in ParcelUuid uuid, int channel, IBinder b);
+    void removeServiceRecord(int handle);
+    boolean allowIncomingProfileConnect(in BluetoothDevice device, boolean value);
 
-    // For Socket
-    ParcelFileDescriptor connectSocket(in BluetoothDevice device, int type, in ParcelUuid uuid, int port, int flag);
-    ParcelFileDescriptor createSocketChannel(int type, in String serviceName, in ParcelUuid uuid, int port, int flag);
+    boolean connectHeadset(String address);
+    boolean disconnectHeadset(String address);
+    boolean notifyIncomingConnection(String address, boolean rejected);
+
+    // HID profile APIs
+    boolean connectInputDevice(in BluetoothDevice device);
+    boolean disconnectInputDevice(in BluetoothDevice device);
+    List<BluetoothDevice> getConnectedInputDevices();
+    List<BluetoothDevice> getInputDevicesMatchingConnectionStates(in int[] states);
+    int getInputDeviceConnectionState(in BluetoothDevice device);
+    boolean setInputDevicePriority(in BluetoothDevice device, int priority);
+    int getInputDevicePriority(in BluetoothDevice device);
+
+    boolean isTetheringOn();
+    void setBluetoothTethering(boolean value);
+    int getPanDeviceConnectionState(in BluetoothDevice device);
+    List<BluetoothDevice> getConnectedPanDevices();
+    List<BluetoothDevice> getPanDevicesMatchingConnectionStates(in int[] states);
+    boolean connectPanDevice(in BluetoothDevice device);
+    boolean disconnectPanDevice(in BluetoothDevice device);
+
+    // HDP profile APIs
+    boolean registerAppConfiguration(in BluetoothHealthAppConfiguration config,
+        in IBluetoothHealthCallback callback);
+    boolean unregisterAppConfiguration(in BluetoothHealthAppConfiguration config);
+    boolean connectChannelToSource(in BluetoothDevice device, in BluetoothHealthAppConfiguration config);
+    boolean connectChannelToSink(in BluetoothDevice device, in BluetoothHealthAppConfiguration config,
+        int channelType);
+    boolean disconnectChannel(in BluetoothDevice device, in BluetoothHealthAppConfiguration config, int id);
+    ParcelFileDescriptor getMainChannelFd(in BluetoothDevice device, in BluetoothHealthAppConfiguration config);
+    List<BluetoothDevice> getConnectedHealthDevices();
+    List<BluetoothDevice> getHealthDevicesMatchingConnectionStates(in int[] states);
+    int getHealthDeviceConnectionState(in BluetoothDevice device);
+
+    void sendConnectionStateChange(in BluetoothDevice device, int profile, int state, int prevState);
 }
diff --git a/core/java/android/bluetooth/IBluetoothA2dp.aidl b/core/java/android/bluetooth/IBluetoothA2dp.aidl
index 1f10998..444dd1e 100644
--- a/core/java/android/bluetooth/IBluetoothA2dp.aidl
+++ b/core/java/android/bluetooth/IBluetoothA2dp.aidl
@@ -33,4 +33,12 @@ interface IBluetoothA2dp {
     boolean setPriority(in BluetoothDevice device, int priority);
     int getPriority(in BluetoothDevice device);
     boolean isA2dpPlaying(in BluetoothDevice device);
+
+    // Internal APIs
+    boolean suspendSink(in BluetoothDevice device);
+    boolean resumeSink(in BluetoothDevice device);
+    boolean connectSinkInternal(in BluetoothDevice device);
+    boolean disconnectSinkInternal(in BluetoothDevice device);
+    boolean allowIncomingConnect(in BluetoothDevice device, boolean value);
+
 }
diff --git a/core/java/android/bluetooth/IBluetoothCallback.aidl b/core/java/android/bluetooth/IBluetoothCallback.aidl
index e280978..8edb3f4 100644
--- a/core/java/android/bluetooth/IBluetoothCallback.aidl
+++ b/core/java/android/bluetooth/IBluetoothCallback.aidl
@@ -23,6 +23,5 @@ package android.bluetooth;
  */
 interface IBluetoothCallback
 {
-    //void onRfcommChannelFound(int channel);
-    void onBluetoothStateChange(int prevState, int newState);
+    void onRfcommChannelFound(int channel);
 }
diff --git a/core/java/android/bluetooth/IBluetoothHeadset.aidl b/core/java/android/bluetooth/IBluetoothHeadset.aidl
index fc7627a..ec00527 100644
--- a/core/java/android/bluetooth/IBluetoothHeadset.aidl
+++ b/core/java/android/bluetooth/IBluetoothHeadset.aidl
@@ -40,17 +40,15 @@ interface IBluetoothHeadset {
     int getBatteryUsageHint(in BluetoothDevice device);
 
     // Internal functions, not be made public
+    boolean createIncomingConnect(in BluetoothDevice device);
     boolean acceptIncomingConnect(in BluetoothDevice device);
     boolean rejectIncomingConnect(in BluetoothDevice device);
+    boolean cancelConnectThread();
+    boolean connectHeadsetInternal(in BluetoothDevice device);
+    boolean disconnectHeadsetInternal(in BluetoothDevice device);
+    boolean setAudioState(in BluetoothDevice device, int state);
     int getAudioState(in BluetoothDevice device);
 
-    boolean isAudioOn();
-    boolean connectAudio();
-    boolean disconnectAudio();
     boolean startScoUsingVirtualVoiceCall(in BluetoothDevice device);
     boolean stopScoUsingVirtualVoiceCall(in BluetoothDevice device);
-    void phoneStateChanged(int numActive, int numHeld, int callState, String number, int type);
-    void roamChanged(boolean roam);
-    void clccResponse(int index, int direction, int status, int mode, boolean mpty,
-                      String number, int type);
 }
diff --git a/core/java/android/server/BluetoothA2dpService.java b/core/java/android/server/BluetoothA2dpService.java
new file mode 100644
index 0000000..f565901
--- /dev/null
+++ b/core/java/android/server/BluetoothA2dpService.java
@@ -0,0 +1,1036 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * TODO: Move this to services.jar
+ * and make the constructor package private again.
+ * @hide
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.bluetooth.IBluetoothA2dp;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.media.AudioManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Bundle;
+import android.os.ParcelUuid;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import android.provider.Settings;
+import android.util.Log;
+
+import com.android.internal.R;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+
+public class BluetoothA2dpService extends IBluetoothA2dp.Stub {
+    private static final String TAG = "BluetoothA2dpService";
+    private static final boolean DBG = true;
+
+    public static final String BLUETOOTH_A2DP_SERVICE = "bluetooth_a2dp";
+
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+    private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+
+    private static final String BLUETOOTH_ENABLED = "bluetooth_enabled";
+
+    private static final String PROPERTY_STATE = "State";
+
+    private final Context mContext;
+    private final IntentFilter mIntentFilter;
+    private HashMap<BluetoothDevice, Integer> mAudioDevices;
+    private final AudioManager mAudioManager;
+    private final BluetoothService mBluetoothService;
+    private final BluetoothAdapter mAdapter;
+    private int   mTargetA2dpState;
+    private BluetoothDevice mPlayingA2dpDevice;
+
+    private IntentBroadcastHandler mIntentBroadcastHandler;
+    private final WakeLock mWakeLock;
+
+    private static final int MSG_CONNECTION_STATE_CHANGED = 0;
+
+    /* AVRCP1.3 Metadata variables */
+    private String mTrackName = DEFAULT_METADATA_STRING;
+    private String mArtistName = DEFAULT_METADATA_STRING;
+    private String mAlbumName = DEFAULT_METADATA_STRING;
+    private String mMediaNumber = DEFAULT_METADATA_NUMBER;
+    private String mMediaCount = DEFAULT_METADATA_NUMBER;
+    private String mDuration = DEFAULT_METADATA_NUMBER;
+    private int mPlayStatus = (int)Integer.valueOf(DEFAULT_METADATA_NUMBER);
+    private long mPosition = (long)Long.valueOf(DEFAULT_METADATA_NUMBER);
+
+    /* AVRCP1.3 Events */
+    private final static int EVENT_PLAYSTATUS_CHANGED = 0x1;
+    private final static int EVENT_TRACK_CHANGED = 0x2;
+
+    private final static String DEFAULT_METADATA_STRING = "Unknown";
+    private final static String DEFAULT_METADATA_NUMBER = "0";
+
+    /* AVRCP 1.3 PlayStatus */
+    private final static int STATUS_STOPPED = 0X00;
+    private final static int STATUS_PLAYING = 0X01;
+    private final static int STATUS_PAUSED = 0X02;
+    private final static int STATUS_FWD_SEEK = 0X03;
+    private final static int STATUS_REV_SEEK = 0X04;
+    private final static int STATUS_ERROR = 0XFF;
+
+    /* AVRCP 1.3 Intents */
+    private List<String> metachanged_intents;
+    private List<String> playstatechanged_intents;
+
+    /* AVRCP 1.3 special extra keys */
+    private List<String> has_special_extra_keys;
+    private HashMap<String, String> special_extra_keys;
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+                int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                                               BluetoothAdapter.ERROR);
+                switch (state) {
+                case BluetoothAdapter.STATE_ON:
+                    onBluetoothEnable();
+                    break;
+                case BluetoothAdapter.STATE_TURNING_OFF:
+                    onBluetoothDisable();
+                    break;
+                }
+            } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED)) {
+                synchronized (this) {
+                    BluetoothDevice device =
+                    intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                    if (mAudioDevices.containsKey(device)) {
+                        int state = mAudioDevices.get(device);
+                        handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTED);
+                    }
+                }
+            } else if (action.equals(AudioManager.VOLUME_CHANGED_ACTION)) {
+                int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
+                if (streamType == AudioManager.STREAM_MUSIC) {
+                    List<BluetoothDevice> sinks = getConnectedDevices();
+
+                    if (sinks.size() != 0 && isPhoneDocked(sinks.get(0))) {
+                        String address = sinks.get(0).getAddress();
+                        int newVolLevel =
+                          intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, 0);
+                        int oldVolLevel =
+                          intent.getIntExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, 0);
+                        String path = mBluetoothService.getObjectPathFromAddress(address);
+                        if (newVolLevel > oldVolLevel) {
+                            avrcpVolumeUpNative(path);
+                        } else if (newVolLevel < oldVolLevel) {
+                            avrcpVolumeDownNative(path);
+                        }
+                    }
+                }
+            } else if (metachanged_intents.contains(action)) {
+                try {
+                    if(DBG) {
+                        Log.d(TAG, "action: " + action);
+
+                        Bundle extras = intent.getExtras();
+
+                        if (extras != null) {
+                            Set<String> ks = extras.keySet();
+                            Iterator<String> iterator = ks.iterator();
+                            while (iterator.hasNext()) {
+                                String key = iterator.next();
+                                Object value = extras.get(key);
+                                if (value != null)
+                                    Log.d(TAG, key + ": " + value.toString());
+                            }
+                        }
+                    }
+
+                    // check if there are special extra keys that we will use
+                    if (has_special_extra_keys.contains(action)) {
+                        if (special_extra_keys.containsKey(action + "_track")) {
+                            mTrackName = intent.getStringExtra(special_extra_keys.get(action + "_track"));
+                        }
+                        else {
+                            mTrackName = intent.getStringExtra("track");
+                        }
+
+                        if (special_extra_keys.containsKey(action + "_artist")) {
+                            mArtistName = intent.getStringExtra(special_extra_keys.get(action + "_artist"));
+                        }
+                        else {
+                            mArtistName = intent.getStringExtra("artist");
+                        }
+
+                        if (special_extra_keys.containsKey(action + "_album")) {
+                            mAlbumName = intent.getStringExtra(special_extra_keys.get(action + "_album"));
+                        }
+                        else {
+                            mAlbumName = intent.getStringExtra("album");
+                        }
+
+                        long extra;
+                        if (special_extra_keys.containsKey(action + "_id")){
+                            extra = intent.getLongExtra(special_extra_keys.get(action + "_id"), 0);
+                        }
+                        else {
+                            extra = intent.getLongExtra("id", 0);
+                        }
+                        if (extra < 0)
+                            extra = 0;
+                        mMediaNumber = String.valueOf(extra);
+                    }
+                    else {
+                        mTrackName = intent.getStringExtra("track");
+                        mArtistName = intent.getStringExtra("artist");
+                        mAlbumName = intent.getStringExtra("album");
+                        long extra = intent.getLongExtra("id", 0);
+                        if (extra < 0)
+                            extra = 0;
+                        mMediaNumber = String.valueOf(extra);
+                    }
+
+                    if (mTrackName == null)
+                        mTrackName = DEFAULT_METADATA_STRING;
+                    if (mArtistName == null)
+                        mArtistName = DEFAULT_METADATA_STRING;
+                    if (mAlbumName == null)
+                        mAlbumName = DEFAULT_METADATA_STRING;
+
+                    long extra = intent.getLongExtra("ListSize", 0);
+                    if (extra < 0)
+                        extra = 0;
+                    mMediaCount = String.valueOf(extra);
+
+                    extra = intent.getLongExtra("duration", 0);
+                    if (extra < 0)
+                        extra = 0;
+                    mDuration = String.valueOf(extra);
+                    extra = intent.getLongExtra("position", 0);
+                    if (extra < 0)
+                        extra = 0;
+                    mPosition = extra;
+                    if(DBG) {
+                        Log.d(TAG, "Meta changed " + mPlayStatus);
+                        Log.d(TAG, "player: " + action);
+                        Log.d(TAG, "trackname: "+ mTrackName + " artist: " + mArtistName);
+                        Log.d(TAG, "album: "+ mAlbumName);
+                        Log.d(TAG, "medianumber: " + mMediaNumber + " mediacount " + mMediaCount);
+                        Log.d(TAG, "postion "+ mPosition + " duration "+ mDuration);
+                    }
+                    for (String path: getConnectedSinksPaths()) {
+                        sendMetaData(path);
+                        sendEvent(path, EVENT_TRACK_CHANGED, Long.valueOf(mMediaNumber));
+                    }
+                }
+                catch (Exception e) {
+                    Log.e(TAG, "Error getting metadata from intent", e);
+                }
+            } else if (playstatechanged_intents.contains(action)) {
+                try {
+                    if(DBG) {
+                        Log.d(TAG, "action: " + action);
+
+                        Bundle extras = intent.getExtras();
+
+                        if (extras != null) {
+                            Set<String> ks = extras.keySet();
+                            Iterator<String> iterator = ks.iterator();
+                            while (iterator.hasNext()) {
+                                String key = iterator.next();
+                                Object value = extras.get(key);
+                                if (value != null)
+                                    Log.d(TAG, key + ": " + value.toString());
+                            }
+                        }
+                    }
+
+                    String currentTrackName;
+                    // check if there are special extra keys that we will use
+                    if (has_special_extra_keys.contains(action)) {
+                        if (special_extra_keys.containsKey(action + "_track")) {
+                            currentTrackName = intent.getStringExtra(special_extra_keys.get(action + "_track"));
+                        }
+                        else {
+                            currentTrackName = intent.getStringExtra("track");
+                        }
+                        if (currentTrackName == null)
+                            currentTrackName = DEFAULT_METADATA_STRING;
+                    }
+                    else {
+                        currentTrackName = intent.getStringExtra("track");
+                        if (currentTrackName == null)
+                            currentTrackName = DEFAULT_METADATA_STRING;
+                    }
+                    if ((!currentTrackName.equals(DEFAULT_METADATA_STRING)) && (!currentTrackName.equals(mTrackName))) {
+                        mTrackName = currentTrackName;
+                        // check if there are special extra keys that we will use
+                        if (has_special_extra_keys.contains(action)) {
+                            if (special_extra_keys.containsKey(action + "_artist")) {
+                                mArtistName = intent.getStringExtra(special_extra_keys.get(action + "_artist"));
+                            }
+                            else {
+                                mArtistName = intent.getStringExtra("artist");
+                            }
+
+                            if (special_extra_keys.containsKey(action + "_album")) {
+                                mAlbumName = intent.getStringExtra(special_extra_keys.get(action + "_album"));
+                            }
+                            else {
+                                mAlbumName = intent.getStringExtra("album");
+                            }
+
+                            long extra;
+                            if (special_extra_keys.containsKey(action + "_id")) {
+                                extra = intent.getLongExtra(special_extra_keys.get(action + "_id"), 0);
+                            }
+                            else {
+                                extra = intent.getLongExtra("id", 0);
+                            }
+                            if (extra < 0)
+                                extra = 0;
+                            mMediaNumber = String.valueOf(extra);
+                        }
+                        else {
+                            mArtistName = intent.getStringExtra("artist");
+                            mAlbumName = intent.getStringExtra("album");
+                            long extra = intent.getLongExtra("id", 0);
+                            if (extra < 0)
+                                extra = 0;
+                            mMediaNumber = String.valueOf(extra);
+                        }
+
+                        if (mArtistName == null)
+                            mArtistName = DEFAULT_METADATA_STRING;
+                        if (mAlbumName == null)
+                            mAlbumName = DEFAULT_METADATA_STRING;
+
+                        long extra = intent.getLongExtra("ListSize", 0);
+                        if (extra < 0)
+                            extra = 0;
+                        mMediaCount = String.valueOf(extra);
+                        extra = intent.getLongExtra("duration", 0);
+                        if (extra < 0)
+                            extra = 0;
+                        mDuration = String.valueOf(extra);
+                        extra = intent.getLongExtra("position", 0);
+                        if (extra < 0)
+                            extra = 0;
+                        mPosition = extra;
+                        for (String path: getConnectedSinksPaths())
+                            sendMetaData(path);
+                    }
+                    boolean playStatusPlaying = intent.getBooleanExtra("playing", false);
+                    boolean playStatusPlaystate = intent.getBooleanExtra("playstate", false);
+                    boolean playStatusState;
+
+                    int state = intent.getIntExtra("state", 2);
+
+                    if ((state == 0) || (state == 1))
+                        playStatusState = true;
+                    else
+                        playStatusState = false;
+
+                    boolean playStatus = playStatusPlaying || playStatusPlaystate || playStatusState;
+
+                    mPosition = intent.getLongExtra("position", 0);
+                    if (mPosition < 0)
+                        mPosition = 0;
+                    mPlayStatus = convertedPlayStatus(playStatus, mPosition);
+                    if(DBG) {
+                        Log.d(TAG, "PlayState changed " + mPlayStatus);
+                        Log.d(TAG, "player: " + action);
+                        Log.d(TAG, "trackname: "+ mTrackName + " artist: " + mArtistName);
+                        Log.d(TAG, "album: "+ mAlbumName);
+                        Log.d(TAG, "medianumber: " + mMediaNumber + " mediacount " + mMediaCount);
+                        Log.d(TAG, "postion "+ mPosition + " duration "+ mDuration);
+                    }
+
+                    for (String path: getConnectedSinksPaths()) {
+                        sendEvent(path, EVENT_PLAYSTATUS_CHANGED, (long)mPlayStatus);
+                    }
+                }
+                catch (Exception e) {
+                    Log.e(TAG, "Error getting playstate from intent", e);
+                }
+            }
+        }
+    };
+
+    private synchronized int convertedPlayStatus(boolean playing, long position) {
+        if (playing == false && position == 0)
+            return STATUS_STOPPED;
+        if (playing == false)
+            return STATUS_PAUSED;
+        if (playing == true)
+            return STATUS_PLAYING;
+        return STATUS_ERROR;
+    }
+
+    private synchronized void sendMetaData(String path) {
+        if(DBG) {
+            Log.d(TAG, "sendMetaData "+ path);
+        }
+        sendMetaDataNative(path);
+    }
+
+    private synchronized void sendEvent(String path, int eventId, long data) {
+        if(DBG)
+            Log.d(TAG, "sendEvent "+path+ " data "+ data);
+        sendEventNative(path, eventId, data);
+    }
+
+    private synchronized void sendPlayStatus(String path) {
+        if(DBG)
+            Log.d(TAG, "sendPlayStatus"+ path);
+        sendPlayStatusNative(path, (int)Integer.valueOf(mDuration), (int)mPosition, mPlayStatus);
+    }
+
+    private void onGetPlayStatusRequest() {
+        if(DBG)
+            Log.d(TAG, "onGetPlayStatusRequest");
+        for (String path: getConnectedSinksPaths()) {
+            sendPlayStatus(path);
+        }
+    }
+
+    private boolean isPhoneDocked(BluetoothDevice device) {
+        // This works only because these broadcast intents are "sticky"
+        Intent i = mContext.registerReceiver(null, new IntentFilter(Intent.ACTION_DOCK_EVENT));
+        if (i != null) {
+            int state = i.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
+            if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                BluetoothDevice dockDevice = i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (dockDevice != null && device.equals(dockDevice)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public BluetoothA2dpService(Context context, BluetoothService bluetoothService) {
+        mContext = context;
+
+        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "BluetoothA2dpService");
+
+        mIntentBroadcastHandler = new IntentBroadcastHandler();
+
+        mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+
+        mBluetoothService = bluetoothService;
+        if (mBluetoothService == null) {
+            throw new RuntimeException("Platform does not support Bluetooth");
+        }
+
+        if (!initNative()) {
+            throw new RuntimeException("Could not init BluetoothA2dpService");
+        }
+
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+
+        mIntentFilter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+        mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
+        mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+        mIntentFilter.addAction(AudioManager.VOLUME_CHANGED_ACTION);
+
+        Resources res = mContext.getResources();
+        try {
+            /* AVRCP 1.3 Intents */
+            metachanged_intents = Arrays.asList(res.getStringArray(R.array.avrcp_meta_changed_intents));
+            playstatechanged_intents = Arrays.asList(res.getStringArray(R.array.avrcp_playstate_changed_intents));
+
+            for (String intent: metachanged_intents) {
+                mIntentFilter.addAction(intent);
+            }
+
+            for (String intent: playstatechanged_intents) {
+                mIntentFilter.addAction(intent);
+            }
+        }
+        catch (Exception e) {
+            Log.e(TAG, "Error getting AVRCP 1.3 intents from the resource file.");
+        }
+
+        try {
+            /* AVRCP 1.3 special extra keys */
+            has_special_extra_keys = Arrays.asList(res.getStringArray(R.array.avrcp_special_extra_keys));
+
+            special_extra_keys = new HashMap<String, String>();
+
+            String key_name;
+            int resID;
+
+            List<String> overridable_extra_keys = Arrays.asList(res.getStringArray(R.array.avrcp_overridable_extra_keys));
+
+            for (String intent: has_special_extra_keys) {
+                if(DBG) {
+                    Log.d(TAG, "has_special_extra_keys: " + intent);
+                }
+                for (String key: overridable_extra_keys) {
+                    key_name = intent + "_" + key;
+                    if(DBG) {
+                        Log.d(TAG, "key_name: " + key_name);
+                    }
+                    resID = res.getIdentifier(key_name, "string", mContext.getPackageName());
+                    if (resID != 0) {
+                        special_extra_keys.put(key_name, res.getString(resID));
+                        if(DBG) {
+                            Log.d(TAG, key_name + ": " + special_extra_keys.get(key_name));
+                        }
+                    }
+                }
+            }
+        }
+        catch (Exception e) {
+            Log.e(TAG, "Error getting AVRCP 1.3 special extra keys from the resource file.");
+        }
+
+        mContext.registerReceiver(mReceiver, mIntentFilter);
+
+        mAudioDevices = new HashMap<BluetoothDevice, Integer>();
+
+        if (mBluetoothService.isEnabled())
+            onBluetoothEnable();
+        mTargetA2dpState = -1;
+        mBluetoothService.setA2dpService(this);
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        try {
+            cleanupNative();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private int convertBluezSinkStringToState(String value) {
+        if (value.equalsIgnoreCase("disconnected"))
+            return BluetoothA2dp.STATE_DISCONNECTED;
+        if (value.equalsIgnoreCase("connecting"))
+            return BluetoothA2dp.STATE_CONNECTING;
+        if (value.equalsIgnoreCase("connected"))
+            return BluetoothA2dp.STATE_CONNECTED;
+        if (value.equalsIgnoreCase("playing"))
+            return BluetoothA2dp.STATE_PLAYING;
+        return -1;
+    }
+
+    private boolean isSinkDevice(BluetoothDevice device) {
+        ParcelUuid[] uuids = mBluetoothService.getRemoteUuids(device.getAddress());
+        if (uuids != null && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSink)) {
+            return true;
+        }
+        return false;
+    }
+
+    private synchronized void addAudioSink(BluetoothDevice device) {
+        if (mAudioDevices.get(device) == null) {
+            mAudioDevices.put(device, BluetoothA2dp.STATE_DISCONNECTED);
+        }
+    }
+
+    private synchronized void onBluetoothEnable() {
+        String devices = mBluetoothService.getProperty("Devices", true);
+        if (devices != null) {
+            String [] paths = devices.split(",");
+            for (String path: paths) {
+                String address = mBluetoothService.getAddressFromObjectPath(path);
+                BluetoothDevice device = mAdapter.getRemoteDevice(address);
+                if (DBG) {
+                    log("RemoteName: " + mBluetoothService.getRemoteName(address));
+                    log("RemoteAlias: " + mBluetoothService.getRemoteAlias(address));
+                }
+                ParcelUuid[] remoteUuids = mBluetoothService.getRemoteUuids(address);
+                if (remoteUuids != null)
+                    if (BluetoothUuid.containsAnyUuid(remoteUuids,
+                            new ParcelUuid[] {BluetoothUuid.AudioSink,
+                                                BluetoothUuid.AdvAudioDist})) {
+                        addAudioSink(device);
+                    }
+                }
+        }
+        mAudioManager.setParameters(BLUETOOTH_ENABLED + "=true");
+        mAudioManager.setParameters("A2dpSuspended=false");
+    }
+
+    private synchronized void onBluetoothDisable() {
+        if (!mAudioDevices.isEmpty()) {
+            BluetoothDevice[] devices = new BluetoothDevice[mAudioDevices.size()];
+            devices = mAudioDevices.keySet().toArray(devices);
+            for (BluetoothDevice device : devices) {
+                int state = getConnectionState(device);
+                switch (state) {
+                    case BluetoothA2dp.STATE_CONNECTING:
+                    case BluetoothA2dp.STATE_CONNECTED:
+                    case BluetoothA2dp.STATE_PLAYING:
+                        disconnectSinkNative(mBluetoothService.getObjectPathFromAddress(
+                                device.getAddress()));
+                        handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTED);
+                        break;
+                    case BluetoothA2dp.STATE_DISCONNECTING:
+                        handleSinkStateChange(device, BluetoothA2dp.STATE_DISCONNECTING,
+                                              BluetoothA2dp.STATE_DISCONNECTED);
+                        break;
+                }
+            }
+            mAudioDevices.clear();
+        }
+
+        mAudioManager.setParameters(BLUETOOTH_ENABLED + "=false");
+    }
+
+    private synchronized boolean isConnectSinkFeasible(BluetoothDevice device) {
+        if (!mBluetoothService.isEnabled() || !isSinkDevice(device) ||
+                getPriority(device) == BluetoothA2dp.PRIORITY_OFF) {
+            return false;
+        }
+
+        addAudioSink(device);
+
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (path == null) {
+            return false;
+        }
+        return true;
+    }
+
+    public synchronized boolean isA2dpPlaying(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+            "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("isA2dpPlaying(" + device + ")");
+        if (device.equals(mPlayingA2dpDevice)) return true;
+        return false;
+    }
+
+    public synchronized boolean connect(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("connectSink(" + device + ")");
+        if (!isConnectSinkFeasible(device)) return false;
+
+        for (BluetoothDevice sinkDevice : mAudioDevices.keySet()) {
+            if (getConnectionState(sinkDevice) != BluetoothProfile.STATE_DISCONNECTED) {
+                disconnect(sinkDevice);
+            }
+        }
+
+        return mBluetoothService.connectSink(device.getAddress());
+    }
+
+    public synchronized boolean connectSinkInternal(BluetoothDevice device) {
+        if (!mBluetoothService.isEnabled()) return false;
+
+        int state = mAudioDevices.get(device);
+
+        // ignore if there are any active sinks
+        if (getDevicesMatchingConnectionStates(new int[] {
+                BluetoothA2dp.STATE_CONNECTING,
+                BluetoothA2dp.STATE_CONNECTED,
+                BluetoothA2dp.STATE_DISCONNECTING}).size() != 0) {
+            return false;
+        }
+
+        switch (state) {
+        case BluetoothA2dp.STATE_CONNECTED:
+        case BluetoothA2dp.STATE_DISCONNECTING:
+            return false;
+        case BluetoothA2dp.STATE_CONNECTING:
+            return true;
+        }
+
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+
+        // State is DISCONNECTED and we are connecting.
+        if (getPriority(device) < BluetoothA2dp.PRIORITY_AUTO_CONNECT) {
+            setPriority(device, BluetoothA2dp.PRIORITY_AUTO_CONNECT);
+        }
+        handleSinkStateChange(device, state, BluetoothA2dp.STATE_CONNECTING);
+
+        if (!connectSinkNative(path)) {
+            // Restore previous state
+            handleSinkStateChange(device, mAudioDevices.get(device), state);
+            return false;
+        }
+        return true;
+    }
+
+    private synchronized boolean isDisconnectSinkFeasible(BluetoothDevice device) {
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (path == null) {
+            return false;
+        }
+
+        int state = getConnectionState(device);
+        switch (state) {
+        case BluetoothA2dp.STATE_DISCONNECTED:
+        case BluetoothA2dp.STATE_DISCONNECTING:
+            return false;
+        }
+        return true;
+    }
+
+    public synchronized boolean disconnect(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("disconnectSink(" + device + ")");
+        if (!isDisconnectSinkFeasible(device)) return false;
+        return mBluetoothService.disconnectSink(device.getAddress());
+    }
+
+    public synchronized boolean disconnectSinkInternal(BluetoothDevice device) {
+        int state = getConnectionState(device);
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+
+        switch (state) {
+            case BluetoothA2dp.STATE_DISCONNECTED:
+            case BluetoothA2dp.STATE_DISCONNECTING:
+                return false;
+        }
+        // State is CONNECTING or CONNECTED or PLAYING
+        handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTING);
+        if (!disconnectSinkNative(path)) {
+            // Restore previous state
+            handleSinkStateChange(device, mAudioDevices.get(device), state);
+            return false;
+        }
+        return true;
+    }
+
+    public synchronized boolean suspendSink(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                            "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("suspendSink(" + device + "), mTargetA2dpState: "+ mTargetA2dpState);
+        if (device == null || mAudioDevices == null) {
+            return false;
+        }
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        Integer state = mAudioDevices.get(device);
+        if (path == null || state == null) {
+            return false;
+        }
+
+        mTargetA2dpState = BluetoothA2dp.STATE_CONNECTED;
+        return checkSinkSuspendState(state.intValue());
+    }
+
+    public synchronized boolean resumeSink(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                            "Need BLUETOOTH_ADMIN permission");
+        if (DBG) log("resumeSink(" + device + "), mTargetA2dpState: "+ mTargetA2dpState);
+        if (device == null || mAudioDevices == null) {
+            return false;
+        }
+        String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        Integer state = mAudioDevices.get(device);
+        if (path == null || state == null) {
+            return false;
+        }
+        mTargetA2dpState = BluetoothA2dp.STATE_PLAYING;
+        return checkSinkSuspendState(state.intValue());
+    }
+
+    public synchronized int getConnectionState(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        Integer state = mAudioDevices.get(device);
+        if (state == null)
+            return BluetoothA2dp.STATE_DISCONNECTED;
+        return state;
+    }
+
+    public synchronized List<String> getConnectedSinksPaths() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        List<BluetoothDevice> btDevices = getConnectedDevices();
+        ArrayList<String> paths = new ArrayList<String>();
+        for(BluetoothDevice device:btDevices) {
+            paths.add(mBluetoothService.getObjectPathFromAddress(device.getAddress()));
+        }
+        return paths;
+    }
+
+    public synchronized List<BluetoothDevice> getConnectedDevices() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        List<BluetoothDevice> sinks = getDevicesMatchingConnectionStates(
+                new int[] {BluetoothA2dp.STATE_CONNECTED});
+        return sinks;
+    }
+
+    public synchronized List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        ArrayList<BluetoothDevice> sinks = new ArrayList<BluetoothDevice>();
+        for (BluetoothDevice device: mAudioDevices.keySet()) {
+            int sinkState = getConnectionState(device);
+            for (int state : states) {
+                if (state == sinkState) {
+                    sinks.add(device);
+                    break;
+                }
+            }
+        }
+        return sinks;
+    }
+
+    public synchronized int getPriority(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()),
+                BluetoothA2dp.PRIORITY_UNDEFINED);
+    }
+
+    public synchronized boolean setPriority(BluetoothDevice device, int priority) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        return Settings.Global.putInt(mContext.getContentResolver(),
+                Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()), priority);
+    }
+
+    public synchronized boolean allowIncomingConnect(BluetoothDevice device, boolean value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        String address = device.getAddress();
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        Integer data = mBluetoothService.getAuthorizationAgentRequestData(address);
+        if (data == null) {
+            Log.w(TAG, "allowIncomingConnect(" + device + ") called but no native data available");
+            return false;
+        }
+        log("allowIncomingConnect: A2DP: " + device + ":" + value);
+        return mBluetoothService.setAuthorizationNative(address, value, data.intValue());
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.AudioSink.
+     *
+     * @param path the object path for the changed device
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    private synchronized void onSinkPropertyChanged(String path, String[] propValues) {
+        if (!mBluetoothService.isEnabled()) {
+            return;
+        }
+
+        String name = propValues[0];
+        String address = mBluetoothService.getAddressFromObjectPath(path);
+        if (address == null) {
+            Log.e(TAG, "onSinkPropertyChanged: Address of the remote device in null");
+            return;
+        }
+
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+
+        if (name.equals(PROPERTY_STATE)) {
+            int state = convertBluezSinkStringToState(propValues[1]);
+            log("A2DP: onSinkPropertyChanged newState is: " + state + " mPlayingA2dpDevice: " + mPlayingA2dpDevice);
+
+            if (mAudioDevices.get(device) == null) {
+                // This is for an incoming connection for a device not known to us.
+                // We have authorized it and bluez state has changed.
+                addAudioSink(device);
+                handleSinkStateChange(device, BluetoothA2dp.STATE_DISCONNECTED, state);
+            } else {
+                if (state == BluetoothA2dp.STATE_PLAYING && mPlayingA2dpDevice == null) {
+                   mPlayingA2dpDevice = device;
+                   handleSinkPlayingStateChange(device, state, BluetoothA2dp.STATE_NOT_PLAYING);
+                } else if (state == BluetoothA2dp.STATE_CONNECTED && mPlayingA2dpDevice != null) {
+                    mPlayingA2dpDevice = null;
+                    handleSinkPlayingStateChange(device, BluetoothA2dp.STATE_NOT_PLAYING,
+                        BluetoothA2dp.STATE_PLAYING);
+                } else {
+                   mPlayingA2dpDevice = null;
+                   int prevState = mAudioDevices.get(device);
+                   handleSinkStateChange(device, prevState, state);
+                }
+            }
+        }
+    }
+
+    private void handleSinkStateChange(BluetoothDevice device, int prevState, int state) {
+        if (state != prevState) {
+            mAudioDevices.put(device, state);
+
+            checkSinkSuspendState(state);
+            mTargetA2dpState = -1;
+
+            if (getPriority(device) > BluetoothA2dp.PRIORITY_OFF &&
+                    state == BluetoothA2dp.STATE_CONNECTED) {
+                // We have connected or attempting to connect.
+                // Bump priority
+                setPriority(device, BluetoothA2dp.PRIORITY_AUTO_CONNECT);
+                // We will only have 1 device with AUTO_CONNECT priority
+                // To be backward compatible set everyone else to have PRIORITY_ON
+                adjustOtherSinkPriorities(device);
+            }
+
+            int delay = mAudioManager.setBluetoothA2dpDeviceConnectionState(device, state);
+
+            mWakeLock.acquire();
+            mIntentBroadcastHandler.sendMessageDelayed(mIntentBroadcastHandler.obtainMessage(
+                                                            MSG_CONNECTION_STATE_CHANGED,
+                                                            prevState,
+                                                            state,
+                                                            device),
+                                                       delay);
+        }
+        if (prevState == BluetoothA2dp.STATE_CONNECTING &&
+             state == BluetoothA2dp.STATE_CONNECTED) {
+            for (String path: getConnectedSinksPaths()) {
+                sendMetaData(path);
+                sendEvent(path, EVENT_PLAYSTATUS_CHANGED, (long)mPlayStatus);
+            }
+        }
+    }
+
+    private void handleSinkPlayingStateChange(BluetoothDevice device, int state, int prevState) {
+        Intent intent = new Intent(BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
+        intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+
+        if (DBG) log("A2DP Playing state : device: " + device + " State:" + prevState + "->" + state);
+    }
+
+    private void adjustOtherSinkPriorities(BluetoothDevice connectedDevice) {
+        for (BluetoothDevice device : mAdapter.getBondedDevices()) {
+            if (getPriority(device) >= BluetoothA2dp.PRIORITY_AUTO_CONNECT &&
+                !device.equals(connectedDevice)) {
+                setPriority(device, BluetoothA2dp.PRIORITY_ON);
+            }
+        }
+    }
+
+    private boolean checkSinkSuspendState(int state) {
+        boolean result = true;
+
+        if (state != mTargetA2dpState) {
+            if (state == BluetoothA2dp.STATE_PLAYING &&
+                mTargetA2dpState == BluetoothA2dp.STATE_CONNECTED) {
+                mAudioManager.setParameters("A2dpSuspended=true");
+            } else if (state == BluetoothA2dp.STATE_CONNECTED &&
+                mTargetA2dpState == BluetoothA2dp.STATE_PLAYING) {
+                mAudioManager.setParameters("A2dpSuspended=false");
+            } else {
+                result = false;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Called by native code for the async response to a Connect
+     * method call to org.bluez.AudioSink.
+     *
+     * @param deviceObjectPath the object path for the connecting device
+     * @param result true on success; false on error
+     */
+    private void onConnectSinkResult(String deviceObjectPath, boolean result) {
+        // If the call was a success, ignore we will update the state
+        // when we a Sink Property Change
+        if (!result) {
+            if (deviceObjectPath != null) {
+                String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+                if (address == null) return;
+                BluetoothDevice device = mAdapter.getRemoteDevice(address);
+                int state = getConnectionState(device);
+                handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTED);
+            }
+        }
+    }
+
+    /** Handles A2DP connection state change intent broadcasts. */
+    private class IntentBroadcastHandler extends Handler {
+
+        private void onConnectionStateChanged(BluetoothDevice device, int prevState, int state) {
+            Intent intent = new Intent(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
+            intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+
+            if (DBG) log("A2DP state : device: " + device + " State:" + prevState + "->" + state);
+
+            mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.A2DP, state,
+                                                        prevState);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_CONNECTION_STATE_CHANGED:
+                    onConnectionStateChanged((BluetoothDevice) msg.obj, msg.arg1, msg.arg2);
+                    mWakeLock.release();
+                    break;
+            }
+        }
+    }
+
+
+    @Override
+    protected synchronized void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
+
+        if (mAudioDevices.isEmpty()) return;
+        pw.println("Cached audio devices:");
+        for (BluetoothDevice device : mAudioDevices.keySet()) {
+            int state = mAudioDevices.get(device);
+            pw.println(device + " " + BluetoothA2dp.stateToString(state));
+        }
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+
+    private native boolean initNative();
+    private native void cleanupNative();
+    private synchronized native boolean connectSinkNative(String path);
+    private synchronized native boolean disconnectSinkNative(String path);
+    private synchronized native boolean suspendSinkNative(String path);
+    private synchronized native boolean resumeSinkNative(String path);
+    private synchronized native Object []getSinkPropertiesNative(String path);
+    private synchronized native boolean avrcpVolumeUpNative(String path);
+    private synchronized native boolean avrcpVolumeDownNative(String path);
+    private synchronized native boolean sendMetaDataNative(String path);
+    private synchronized native boolean sendEventNative(String path, int eventId, long data);
+    private synchronized native boolean sendPlayStatusNative(String path, int duration,
+                                                             int position, int playStatus);
+}
diff --git a/core/java/android/server/BluetoothAdapterProperties.java b/core/java/android/server/BluetoothAdapterProperties.java
new file mode 100644
index 0000000..9723f60
--- /dev/null
+++ b/core/java/android/server/BluetoothAdapterProperties.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.content.Context;
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.Map;
+
+class BluetoothAdapterProperties {
+
+    private static final String TAG = "BluetoothAdapterProperties";
+
+    private final Map<String, String> mPropertiesMap;
+    private final Context mContext;
+    private final BluetoothService mService;
+
+    BluetoothAdapterProperties(Context context, BluetoothService service) {
+        mPropertiesMap = new HashMap<String, String>();
+        mContext = context;
+        mService = service;
+    }
+
+    synchronized String getProperty(String name) {
+        if (mPropertiesMap.isEmpty()) {
+            getAllProperties();
+        }
+        return mPropertiesMap.get(name);
+    }
+
+    String getObjectPath() {
+        return getProperty("ObjectPath");
+    }
+
+    synchronized void clear() {
+        mPropertiesMap.clear();
+    }
+
+    synchronized boolean isEmpty() {
+        return mPropertiesMap.isEmpty();
+    }
+
+    synchronized void setProperty(String name, String value) {
+        mPropertiesMap.put(name, value);
+    }
+
+    synchronized void getAllProperties() {
+        mContext.enforceCallingOrSelfPermission(
+                BluetoothService.BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        mPropertiesMap.clear();
+
+        String properties[] = (String[]) mService
+                .getAdapterPropertiesNative();
+        // The String Array consists of key-value pairs.
+        if (properties == null) {
+            Log.e(TAG, "*Error*: GetAdapterProperties returned NULL");
+            return;
+        }
+
+        for (int i = 0; i < properties.length; i++) {
+            String name = properties[i];
+            String newValue = null;
+            if (name == null) {
+                Log.e(TAG, "Error:Adapter Property at index " + i + " is null");
+                continue;
+            }
+            if (name.equals("Devices") || name.equals("UUIDs")) {
+                StringBuilder str = new StringBuilder();
+                int len = Integer.valueOf(properties[++i]);
+                for (int j = 0; j < len; j++) {
+                    str.append(properties[++i]);
+                    str.append(",");
+                }
+                if (len > 0) {
+                    newValue = str.toString();
+                }
+            } else {
+                newValue = properties[++i];
+            }
+            mPropertiesMap.put(name, newValue);
+        }
+
+        // Add adapter object path property.
+        String adapterPath = mService.getAdapterPathNative();
+        if (adapterPath != null) {
+            mPropertiesMap.put("ObjectPath", adapterPath + "/dev_");
+        }
+    }
+}
diff --git a/core/java/android/server/BluetoothAdapterStateMachine.java b/core/java/android/server/BluetoothAdapterStateMachine.java
new file mode 100644
index 0000000..dde1493
--- /dev/null
+++ b/core/java/android/server/BluetoothAdapterStateMachine.java
@@ -0,0 +1,822 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.IBluetoothStateChangeCallback;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.os.Message;
+import android.os.RemoteException;
+import android.provider.Settings;
+import android.util.Log;
+
+import com.android.internal.util.IState;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+import java.io.PrintWriter;
+
+/**
+ * Bluetooth Adapter StateMachine
+ * All the states are at the same level, ie, no hierarchy.
+ *                         (BluetootOn)<----------------------<-
+ *                           |    ^    -------------------->-  |
+ *                           |    |                         |  |
+ *            USER_TURN_OFF  |    | SCAN_MODE_CHANGED    m1 |  | USER_TURN_ON
+ *         AIRPLANE_MODE_ON  |    |                         |  |
+ *                           V    |                         |  |
+ *                         (Switching)                   (PerProcessState)
+ *                           |    ^                         |  |
+ *     POWER_STATE_CHANGED & |    | TURN_ON(_CONTINUE)      |  |
+ * ALL_DEVICES_DISCONNECTED  |    |                     m2  |  |
+ *                           V    |------------------------<   | SCAN_MODE_CHANGED
+ *                          (HotOff)-------------------------->- PER_PROCESS_TURN_ON
+ *                           /    ^
+ *                          /     |  SERVICE_RECORD_LOADED
+ *                         |      |
+ *              TURN_COLD  |   (Warmup)
+ *                         \      ^
+ *                          \     |  TURN_HOT/TURN_ON
+ *                           |    |  AIRPLANE_MODE_OFF(when Bluetooth was on before)
+ *                           V    |
+ *                           (PowerOff)   <----- initial state
+ *
+ * Legend:
+ * m1 = TURN_HOT
+ * m2 = Transition to HotOff when number of process wanting BT on is 0.
+ *      POWER_STATE_CHANGED will make the transition.
+ * Note:
+ * The diagram above shows all the states and messages that trigger normal state changes.
+ * The diagram above does not capture everything:
+ *   The diagram does not capture following messages.
+ *   - messages that do not trigger state changes
+ *     For example, PER_PROCESS_TURN_ON received in BluetoothOn state
+ *   - unhandled messages
+ *     For example, USER_TURN_ON received in BluetoothOn state
+ *   - timeout messages
+ *   The diagram does not capture error conditions and state recoveries.
+ *   - For example POWER_STATE_CHANGED received in BluetoothOn state
+ */
+final class BluetoothAdapterStateMachine extends StateMachine {
+    private static final String TAG = "BluetoothAdapterStateMachine";
+    private static final boolean DBG = false;
+
+    // Message(what) to take an action
+    //
+    // We get this message when user tries to turn on BT
+    static final int USER_TURN_ON = 1;
+    // We get this message when user tries to turn off BT
+    static final int USER_TURN_OFF = 2;
+    // Per process enable / disable messages
+    static final int PER_PROCESS_TURN_ON = 3;
+    static final int PER_PROCESS_TURN_OFF = 4;
+
+    // Turn on Bluetooth Module, Load firmware, and do all the preparation
+    // needed to get the Bluetooth Module ready but keep it not discoverable
+    // and not connectable. This way the Bluetooth Module can be quickly
+    // switched on if needed
+    static final int TURN_HOT = 5;
+
+    // Message(what) to report a event that the state machine need to respond to
+    //
+    // Event indicates sevice records have been loaded
+    static final int SERVICE_RECORD_LOADED = 51;
+    // Event indicates all the remote Bluetooth devices has been disconnected
+    static final int ALL_DEVICES_DISCONNECTED = 52;
+    // Event indicates the Bluetooth scan mode has changed
+    static final int SCAN_MODE_CHANGED = 53;
+    // Event indicates the powered state has changed
+    static final int POWER_STATE_CHANGED = 54;
+    // Event indicates airplane mode is turned on
+    static final int AIRPLANE_MODE_ON = 55;
+    // Event indicates airplane mode is turned off
+    static final int AIRPLANE_MODE_OFF = 56;
+
+    // private internal messages
+    //
+    // USER_TURN_ON is changed to TURN_ON_CONTINUE after we broadcast the
+    // state change intent so that we will not broadcast the intent again in
+    // other state
+    private static final int TURN_ON_CONTINUE = 101;
+    // Unload firmware, turning off Bluetooth module power
+    private static final int TURN_COLD = 102;
+    // Device disconnecting timeout happens
+    private static final int DEVICES_DISCONNECT_TIMEOUT = 103;
+    // Prepare Bluetooth timeout happens
+    private static final int PREPARE_BLUETOOTH_TIMEOUT = 104;
+    // Bluetooth turn off wait timeout happens
+    private static final int TURN_OFF_TIMEOUT = 105;
+    // Bluetooth device power off wait timeout happens
+    private static final int POWER_DOWN_TIMEOUT = 106;
+
+    private Context mContext;
+    private BluetoothService mBluetoothService;
+    private BluetoothEventLoop mEventLoop;
+
+    private BluetoothOn mBluetoothOn;
+    private Switching mSwitching;
+    private HotOff mHotOff;
+    private WarmUp mWarmUp;
+    private PowerOff mPowerOff;
+    private PerProcessState mPerProcessState;
+
+    // this is the BluetoothAdapter state that reported externally
+    private int mPublicState;
+    // When turning off, broadcast STATE_OFF in the last HotOff state
+    // This is because we do HotOff -> PowerOff -> HotOff for USER_TURN_OFF
+    private boolean mDelayBroadcastStateOff;
+
+    // timeout value waiting for all the devices to be disconnected
+    private static final int DEVICES_DISCONNECT_TIMEOUT_TIME = 3000;
+
+    private static final int PREPARE_BLUETOOTH_TIMEOUT_TIME = 10000;
+
+    private static final int TURN_OFF_TIMEOUT_TIME = 5000;
+    private static final int POWER_DOWN_TIMEOUT_TIME = 20;
+
+    BluetoothAdapterStateMachine(Context context, BluetoothService bluetoothService,
+                                 BluetoothAdapter bluetoothAdapter) {
+        super(TAG);
+        mContext = context;
+        mBluetoothService = bluetoothService;
+        mEventLoop = new BluetoothEventLoop(context, bluetoothAdapter, bluetoothService, this);
+
+        mBluetoothOn = new BluetoothOn();
+        mSwitching = new Switching();
+        mHotOff = new HotOff();
+        mWarmUp = new WarmUp();
+        mPowerOff = new PowerOff();
+        mPerProcessState = new PerProcessState();
+
+        addState(mBluetoothOn);
+        addState(mSwitching);
+        addState(mHotOff);
+        addState(mWarmUp);
+        addState(mPowerOff);
+        addState(mPerProcessState);
+
+        setInitialState(mPowerOff);
+        mPublicState = BluetoothAdapter.STATE_OFF;
+        mDelayBroadcastStateOff = false;
+    }
+
+    /**
+     * Bluetooth module's power is off, firmware is not loaded.
+     */
+    private class PowerOff extends State {
+        @Override
+        public void enter() {
+            if (DBG) log("Enter PowerOff: " + getCurrentMessage().what);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            log("PowerOff process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case USER_TURN_ON:
+                    // starts turning on BT module, broadcast this out
+                    broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                    transitionTo(mWarmUp);
+                    if (prepareBluetooth()) {
+                        // this is user request, save the setting
+                        if ((Boolean) message.obj) {
+                            persistSwitchSetting(true);
+                        }
+                        // We will continue turn the BT on all the way to the BluetoothOn state
+                        deferMessage(obtainMessage(TURN_ON_CONTINUE));
+                    } else {
+                        Log.e(TAG, "failed to prepare bluetooth, abort turning on");
+                        transitionTo(mPowerOff);
+                        broadcastState(BluetoothAdapter.STATE_OFF);
+                    }
+                    break;
+                case TURN_HOT:
+                    if (prepareBluetooth()) {
+                        transitionTo(mWarmUp);
+                    }
+                    break;
+                case AIRPLANE_MODE_OFF:
+                    if (getBluetoothPersistedSetting()) {
+                        // starts turning on BT module, broadcast this out
+                        broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                        transitionTo(mWarmUp);
+                        if (prepareBluetooth()) {
+                            // We will continue turn the BT on all the way to the BluetoothOn state
+                            deferMessage(obtainMessage(TURN_ON_CONTINUE));
+                            transitionTo(mWarmUp);
+                        } else {
+                            Log.e(TAG, "failed to prepare bluetooth, abort turning on");
+                            transitionTo(mPowerOff);
+                            broadcastState(BluetoothAdapter.STATE_OFF);
+                        }
+                    } else if (mContext.getResources().getBoolean
+                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
+                        sendMessage(TURN_HOT);
+                    }
+                    break;
+                case PER_PROCESS_TURN_ON:
+                    if (prepareBluetooth()) {
+                        transitionTo(mWarmUp);
+                    }
+                    deferMessage(obtainMessage(PER_PROCESS_TURN_ON));
+                    break;
+                case PER_PROCESS_TURN_OFF:
+                    perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
+                    break;
+                case USER_TURN_OFF:
+                    Log.w(TAG, "PowerOff received: " + message.what);
+                case AIRPLANE_MODE_ON: // ignore
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+        /**
+         * Turn on Bluetooth Module, Load firmware, and do all the preparation
+         * needed to get the Bluetooth Module ready but keep it not discoverable
+         * and not connectable.
+         * The last step of this method sets up the local service record DB.
+         * There will be a event reporting the status of the SDP setup.
+         */
+        private boolean prepareBluetooth() {
+            if (mBluetoothService.enableNative() != 0) {
+                return false;
+            }
+
+            // try to start event loop, give 2 attempts
+            int retryCount = 2;
+            boolean eventLoopStarted = false;
+            while ((retryCount-- > 0) && !eventLoopStarted) {
+                mEventLoop.start();
+                // it may take a moment for the other thread to do its
+                // thing.  Check periodically for a while.
+                int pollCount = 5;
+                while ((pollCount-- > 0) && !eventLoopStarted) {
+                    if (mEventLoop.isEventLoopRunning()) {
+                        eventLoopStarted = true;
+                        break;
+                    }
+                    try {
+                        Thread.sleep(100);
+                    } catch (InterruptedException e) {
+                        log("prepareBluetooth sleep interrupted: " + pollCount);
+                        break;
+                    }
+                }
+            }
+
+            if (!eventLoopStarted) {
+                mBluetoothService.disableNative();
+                return false;
+            }
+
+            // get BluetoothService ready
+            if (!mBluetoothService.prepareBluetooth()) {
+                mEventLoop.stop();
+                mBluetoothService.disableNative();
+                return false;
+            }
+
+            sendMessageDelayed(PREPARE_BLUETOOTH_TIMEOUT, PREPARE_BLUETOOTH_TIMEOUT_TIME);
+            return true;
+        }
+    }
+
+    /**
+     * Turning on Bluetooth module's power, loading firmware, starting
+     * event loop thread to listen on Bluetooth module event changes.
+     */
+    private class WarmUp extends State {
+
+        @Override
+        public void enter() {
+            if (DBG) log("Enter WarmUp: " + getCurrentMessage().what);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("WarmUp process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case SERVICE_RECORD_LOADED:
+                    removeMessages(PREPARE_BLUETOOTH_TIMEOUT);
+                    transitionTo(mHotOff);
+                    if (mDelayBroadcastStateOff) {
+                        broadcastState(BluetoothAdapter.STATE_OFF);
+                        mDelayBroadcastStateOff = false;
+                    }
+                    break;
+                case PREPARE_BLUETOOTH_TIMEOUT:
+                    Log.e(TAG, "Bluetooth adapter SDP failed to load");
+                    shutoffBluetooth();
+                    transitionTo(mPowerOff);
+                    broadcastState(BluetoothAdapter.STATE_OFF);
+                    break;
+                case USER_TURN_ON: // handle this at HotOff state
+                case TURN_ON_CONTINUE: // Once in HotOff state, continue turn bluetooth
+                                       // on to the BluetoothOn state
+                case AIRPLANE_MODE_ON:
+                case AIRPLANE_MODE_OFF:
+                case PER_PROCESS_TURN_ON:
+                case PER_PROCESS_TURN_OFF:
+                    deferMessage(message);
+                    break;
+                case USER_TURN_OFF:
+                    Log.w(TAG, "WarmUp received: " + message.what);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+    }
+
+    /**
+     * Bluetooth Module has powered, firmware loaded, event loop started,
+     * SDP loaded, but the modules stays non-discoverable and
+     * non-connectable.
+     */
+    private class HotOff extends State {
+        @Override
+        public void enter() {
+            if (DBG) log("Enter HotOff: " + getCurrentMessage().what);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("HotOff process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case USER_TURN_ON:
+                    broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                    if ((Boolean) message.obj) {
+                        persistSwitchSetting(true);
+                    }
+                    // let it fall to TURN_ON_CONTINUE:
+                    //$FALL-THROUGH$
+                case TURN_ON_CONTINUE:
+                    mBluetoothService.switchConnectable(true);
+                    transitionTo(mSwitching);
+                    break;
+                case AIRPLANE_MODE_ON:
+                case TURN_COLD:
+                    shutoffBluetooth();
+                    // we cannot go to power off state yet, we need wait for the Bluetooth
+                    // device power off. Unfortunately the stack does not give a event back
+                    // so we wait a little bit here
+                    sendMessageDelayed(POWER_DOWN_TIMEOUT,
+                                       POWER_DOWN_TIMEOUT_TIME);
+                    break;
+                case POWER_DOWN_TIMEOUT:
+                    transitionTo(mPowerOff);
+                    if (!mDelayBroadcastStateOff) {
+                        broadcastState(BluetoothAdapter.STATE_OFF);
+                    }
+                    break;
+                case AIRPLANE_MODE_OFF:
+                    if (getBluetoothPersistedSetting()) {
+                        broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                        transitionTo(mSwitching);
+                        mBluetoothService.switchConnectable(true);
+                    }
+                    break;
+                case PER_PROCESS_TURN_ON:
+                    transitionTo(mPerProcessState);
+
+                    // Resend the PER_PROCESS_TURN_ON message so that the callback
+                    // can be sent through.
+                    deferMessage(message);
+
+                    mBluetoothService.switchConnectable(true);
+                    break;
+                case PER_PROCESS_TURN_OFF:
+                    perProcessCallback(false, (IBluetoothStateChangeCallback)message.obj);
+                    break;
+                case USER_TURN_OFF: // ignore
+                    break;
+                case POWER_STATE_CHANGED:
+                    if ((Boolean) message.obj) {
+                        recoverStateMachine(TURN_HOT, null);
+                    }
+                    break;
+                case TURN_HOT:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+    }
+
+    private class Switching extends State {
+
+        @Override
+        public void enter() {
+            if (DBG) log("Enter Switching: " + getCurrentMessage().what);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            log("Switching process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case SCAN_MODE_CHANGED:
+                    // This event matches mBluetoothService.switchConnectable action
+                    if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
+                        // set pairable if it's not
+                        mBluetoothService.setPairable();
+                        mBluetoothService.initBluetoothAfterTurningOn();
+                        transitionTo(mBluetoothOn);
+                        broadcastState(BluetoothAdapter.STATE_ON);
+                        // run bluetooth now that it's turned on
+                        // Note runBluetooth should be called only in adapter STATE_ON
+                        mBluetoothService.runBluetooth();
+                    }
+                    break;
+                case POWER_STATE_CHANGED:
+                    removeMessages(TURN_OFF_TIMEOUT);
+                    if (!((Boolean) message.obj)) {
+                        if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
+                            transitionTo(mHotOff);
+                            mBluetoothService.finishDisable();
+                            mBluetoothService.cleanupAfterFinishDisable();
+                            deferMessage(obtainMessage(TURN_COLD));
+                            if (mContext.getResources().getBoolean
+                                (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) &&
+                                !mBluetoothService.isAirplaneModeOn()) {
+                                deferMessage(obtainMessage(TURN_HOT));
+                                mDelayBroadcastStateOff = true;
+                            }
+                        }
+                    } else {
+                        if (mPublicState != BluetoothAdapter.STATE_TURNING_ON) {
+                            if (mContext.getResources().getBoolean
+                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
+                                recoverStateMachine(TURN_HOT, null);
+                            } else {
+                                recoverStateMachine(TURN_COLD, null);
+                            }
+                        }
+                    }
+                    break;
+                case ALL_DEVICES_DISCONNECTED:
+                    removeMessages(DEVICES_DISCONNECT_TIMEOUT);
+                    mBluetoothService.switchConnectable(false);
+                    sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME);
+                    break;
+                case DEVICES_DISCONNECT_TIMEOUT:
+                    sendMessage(ALL_DEVICES_DISCONNECTED);
+                    // reset the hardware for error recovery
+                    Log.e(TAG, "Devices failed to disconnect, reseting...");
+                    deferMessage(obtainMessage(TURN_COLD));
+                    if (mContext.getResources().getBoolean
+                        (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
+                        deferMessage(obtainMessage(TURN_HOT));
+                    }
+                    break;
+                case TURN_OFF_TIMEOUT:
+                    transitionTo(mHotOff);
+                    finishSwitchingOff();
+                    // reset the hardware for error recovery
+                    Log.e(TAG, "Devices failed to power down, reseting...");
+                    deferMessage(obtainMessage(TURN_COLD));
+                    if (mContext.getResources().getBoolean
+                        (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
+                        deferMessage(obtainMessage(TURN_HOT));
+                    }
+                    break;
+                case USER_TURN_ON:
+                case AIRPLANE_MODE_OFF:
+                case AIRPLANE_MODE_ON:
+                case PER_PROCESS_TURN_ON:
+                case PER_PROCESS_TURN_OFF:
+                case USER_TURN_OFF:
+                    deferMessage(message);
+                    break;
+
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+    }
+
+    private class BluetoothOn extends State {
+
+        @Override
+        public void enter() {
+            if (DBG) log("Enter BluetoothOn: " + getCurrentMessage().what);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            log("BluetoothOn process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case USER_TURN_OFF:
+                    if ((Boolean) message.obj) {
+                        persistSwitchSetting(false);
+                    }
+
+                    if (mBluetoothService.isDiscovering()) {
+                        mBluetoothService.cancelDiscovery();
+                    }
+                    if (!mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
+                        transitionTo(mPerProcessState);
+                        deferMessage(obtainMessage(TURN_HOT));
+                        break;
+                    }
+                    //$FALL-THROUGH$ to AIRPLANE_MODE_ON
+                case AIRPLANE_MODE_ON:
+                    broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
+                    transitionTo(mSwitching);
+                    if (mBluetoothService.getAdapterConnectionState() !=
+                        BluetoothAdapter.STATE_DISCONNECTED) {
+                        mBluetoothService.disconnectDevices();
+                        sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT,
+                                           DEVICES_DISCONNECT_TIMEOUT_TIME);
+                    } else {
+                        mBluetoothService.switchConnectable(false);
+                        sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME);
+                    }
+
+                    if (message.what == AIRPLANE_MODE_ON || mBluetoothService.isAirplaneModeOn()) {
+                        // We inform all the per process callbacks
+                        allProcessesCallback(false);
+                    }
+                    break;
+                case AIRPLANE_MODE_OFF:
+                case USER_TURN_ON:
+                    Log.w(TAG, "BluetoothOn received: " + message.what);
+                    break;
+                case PER_PROCESS_TURN_ON:
+                    perProcessCallback(true, (IBluetoothStateChangeCallback)message.obj);
+                    break;
+                case PER_PROCESS_TURN_OFF:
+                    perProcessCallback(false, (IBluetoothStateChangeCallback)message.obj);
+                    break;
+                case POWER_STATE_CHANGED:
+                    if ((Boolean) message.obj) {
+                        // reset the state machine and send it TURN_ON_CONTINUE message
+                        recoverStateMachine(USER_TURN_ON, false);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+    }
+
+
+    private class PerProcessState extends State {
+        IBluetoothStateChangeCallback mCallback = null;
+        boolean isTurningOn = false;
+
+        @Override
+        public void enter() {
+            int what = getCurrentMessage().what;
+            if (DBG) log("Enter PerProcessState: " + what);
+
+            if (what == PER_PROCESS_TURN_ON) {
+                isTurningOn = true;
+            } else if (what == USER_TURN_OFF) {
+                isTurningOn = false;
+            } else {
+                Log.e(TAG, "enter PerProcessState: wrong msg: " + what);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            log("PerProcessState process message: " + message.what);
+
+            boolean retValue = HANDLED;
+            switch (message.what) {
+                case PER_PROCESS_TURN_ON:
+                    mCallback = (IBluetoothStateChangeCallback)getCurrentMessage().obj;
+
+                    // If this is not the first application call the callback.
+                    if (mBluetoothService.getNumberOfApplicationStateChangeTrackers() > 1) {
+                        perProcessCallback(true, mCallback);
+                    }
+                    break;
+                case SCAN_MODE_CHANGED:
+                    if (isTurningOn) {
+                        perProcessCallback(true, mCallback);
+                        isTurningOn = false;
+                    }
+                    break;
+                case POWER_STATE_CHANGED:
+                    removeMessages(TURN_OFF_TIMEOUT);
+                    if (!((Boolean) message.obj)) {
+                        transitionTo(mHotOff);
+                        if (!mContext.getResources().getBoolean
+                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
+                            deferMessage(obtainMessage(TURN_COLD));
+                        }
+                    } else {
+                        if (!isTurningOn) {
+                            recoverStateMachine(TURN_COLD, null);
+                            for (IBluetoothStateChangeCallback c:
+                                     mBluetoothService.getApplicationStateChangeCallbacks()) {
+                                perProcessCallback(false, c);
+                                deferMessage(obtainMessage(PER_PROCESS_TURN_ON, c));
+                            }
+                        }
+                    }
+                    break;
+                case TURN_OFF_TIMEOUT:
+                    transitionTo(mHotOff);
+                    Log.e(TAG, "Power-down timed out, resetting...");
+                    deferMessage(obtainMessage(TURN_COLD));
+                    if (mContext.getResources().getBoolean
+                        (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
+                        deferMessage(obtainMessage(TURN_HOT));
+                    }
+                    break;
+                case USER_TURN_ON:
+                    broadcastState(BluetoothAdapter.STATE_TURNING_ON);
+                    persistSwitchSetting(true);
+                    mBluetoothService.initBluetoothAfterTurningOn();
+                    transitionTo(mBluetoothOn);
+                    broadcastState(BluetoothAdapter.STATE_ON);
+                    // run bluetooth now that it's turned on
+                    mBluetoothService.runBluetooth();
+                    break;
+                case TURN_HOT:
+                    broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
+                    if (mBluetoothService.getAdapterConnectionState() !=
+                        BluetoothAdapter.STATE_DISCONNECTED) {
+                        mBluetoothService.disconnectDevices();
+                        sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT,
+                                           DEVICES_DISCONNECT_TIMEOUT_TIME);
+                        break;
+                    }
+                    //$FALL-THROUGH$ all devices are already disconnected
+                case ALL_DEVICES_DISCONNECTED:
+                    removeMessages(DEVICES_DISCONNECT_TIMEOUT);
+                    finishSwitchingOff();
+                    break;
+                case DEVICES_DISCONNECT_TIMEOUT:
+                    finishSwitchingOff();
+                    Log.e(TAG, "Devices fail to disconnect, reseting...");
+                    transitionTo(mHotOff);
+                    deferMessage(obtainMessage(TURN_COLD));
+                    for (IBluetoothStateChangeCallback c:
+                             mBluetoothService.getApplicationStateChangeCallbacks()) {
+                        perProcessCallback(false, c);
+                        deferMessage(obtainMessage(PER_PROCESS_TURN_ON, c));
+                    }
+                    break;
+                case PER_PROCESS_TURN_OFF:
+                    perProcessCallback(false, (IBluetoothStateChangeCallback)message.obj);
+                    if (mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
+                        mBluetoothService.switchConnectable(false);
+                        sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME);
+                    }
+                    break;
+                case AIRPLANE_MODE_ON:
+                    mBluetoothService.switchConnectable(false);
+                    sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME);
+                    allProcessesCallback(false);
+                    break;
+                case USER_TURN_OFF:
+                    Log.w(TAG, "PerProcessState received: " + message.what);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+    }
+
+    private void finishSwitchingOff() {
+        mBluetoothService.finishDisable();
+        broadcastState(BluetoothAdapter.STATE_OFF);
+        mBluetoothService.cleanupAfterFinishDisable();
+    }
+
+    private void shutoffBluetooth() {
+        mBluetoothService.shutoffBluetooth();
+        mEventLoop.stop();
+        mBluetoothService.cleanNativeAfterShutoffBluetooth();
+    }
+
+    private void perProcessCallback(boolean on, IBluetoothStateChangeCallback c) {
+        if (c == null) return;
+
+        try {
+            c.onBluetoothStateChange(on);
+        } catch (RemoteException e) {}
+    }
+
+    private void allProcessesCallback(boolean on) {
+        for (IBluetoothStateChangeCallback c:
+             mBluetoothService.getApplicationStateChangeCallbacks()) {
+            perProcessCallback(on, c);
+        }
+        if (!on) {
+            mBluetoothService.clearApplicationStateChangeTracker();
+        }
+    }
+
+    /**
+     * Return the public BluetoothAdapter state
+     */
+    int getBluetoothAdapterState() {
+        return mPublicState;
+    }
+
+    BluetoothEventLoop getBluetoothEventLoop() {
+        return mEventLoop;
+    }
+
+    private void persistSwitchSetting(boolean setOn) {
+        long origCallerIdentityToken = Binder.clearCallingIdentity();
+        Settings.Global.putInt(mContext.getContentResolver(),
+                               Settings.Global.BLUETOOTH_ON,
+                               setOn ? 1 : 0);
+        Binder.restoreCallingIdentity(origCallerIdentityToken);
+    }
+
+    private boolean getBluetoothPersistedSetting() {
+        ContentResolver contentResolver = mContext.getContentResolver();
+        return (Settings.Global.getInt(contentResolver,
+                                       Settings.Global.BLUETOOTH_ON, 0) > 0);
+    }
+
+    private void broadcastState(int newState) {
+
+        log("Bluetooth state " + mPublicState + " -> " + newState);
+        if (mPublicState == newState) {
+            return;
+        }
+
+        Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
+        intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, mPublicState);
+        intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mPublicState = newState;
+
+        mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
+    }
+
+    /**
+     * bluetoothd has crashed and recovered, the adapter state machine has to
+     * reset itself and try to return to previous state
+     */
+    private void recoverStateMachine(int what, Object obj) {
+        Log.e(TAG, "Get unexpected power on event, reset with: " + what);
+        transitionTo(mHotOff);
+        deferMessage(obtainMessage(TURN_COLD));
+        deferMessage(obtainMessage(what, obj));
+    }
+
+    private void dump(PrintWriter pw) {
+        IState currentState = getCurrentState();
+        if (currentState == mPowerOff) {
+            pw.println("Bluetooth OFF - power down\n");
+        } else if (currentState == mWarmUp) {
+            pw.println("Bluetooth OFF - warm up\n");
+        } else if (currentState == mHotOff) {
+            pw.println("Bluetooth OFF - hot but off\n");
+        } else if (currentState == mSwitching) {
+            pw.println("Bluetooth Switching\n");
+        } else if (currentState == mBluetoothOn) {
+            pw.println("Bluetooth ON\n");
+        } else {
+            pw.println("ERROR: Bluetooth UNKNOWN STATE ");
+        }
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/core/java/android/server/BluetoothBondState.java b/core/java/android/server/BluetoothBondState.java
new file mode 100644
index 0000000..0446f02
--- /dev/null
+++ b/core/java/android/server/BluetoothBondState.java
@@ -0,0 +1,497 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothHeadset;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.provider.Settings;
+import android.util.Log;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Local cache of bonding state.
+ * We keep our own state to track the intermediate state BONDING, which
+ * bluez does not track.
+ * All addresses must be passed in upper case.
+ */
+class BluetoothBondState {
+    private static final String TAG = "BluetoothBondState";
+    private static final boolean DBG =  true;
+
+    private final HashMap<String, Integer> mState = new HashMap<String, Integer>();
+    private final HashMap<String, Integer> mPinAttempt = new HashMap<String, Integer>();
+
+    private static final String AUTO_PAIRING_BLACKLIST =
+        "/etc/bluetooth/auto_pairing.conf";
+    private static final String DYNAMIC_AUTO_PAIRING_BLACKLIST =
+        "/data/misc/bluetooth/dynamic_auto_pairing.conf";
+    private ArrayList<String> mAutoPairingAddressBlacklist;
+    private ArrayList<String> mAutoPairingExactNameBlacklist;
+    private ArrayList<String> mAutoPairingPartialNameBlacklist;
+    private ArrayList<String> mAutoPairingFixedPinZerosKeyboardList;
+    // Addresses added to blacklist dynamically based on usage.
+    private ArrayList<String> mAutoPairingDynamicAddressBlacklist;
+
+    // If this is an outgoing connection, store the address.
+    // There can be only 1 pending outgoing connection at a time,
+    private String mPendingOutgoingBonding;
+
+    private final Context mContext;
+    private final BluetoothService mService;
+    private final BluetoothInputProfileHandler mBluetoothInputProfileHandler;
+    private BluetoothA2dp mA2dpProxy;
+    private BluetoothHeadset mHeadsetProxy;
+
+    private ArrayList<String> mPairingRequestRcvd = new ArrayList<String>();
+
+    BluetoothBondState(Context context, BluetoothService service) {
+        mContext = context;
+        mService = service;
+        mBluetoothInputProfileHandler =
+            BluetoothInputProfileHandler.getInstance(mContext, mService);
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        mContext.registerReceiver(mReceiver, filter);
+        readAutoPairingData();
+    }
+
+    synchronized void setPendingOutgoingBonding(String address) {
+        mPendingOutgoingBonding = address;
+    }
+
+    public synchronized String getPendingOutgoingBonding() {
+        return mPendingOutgoingBonding;
+    }
+
+    public synchronized void initBondState() {
+        getProfileProxy();
+        loadBondState();
+    }
+
+    private void loadBondState() {
+        if (mService.getBluetoothStateInternal() !=
+                BluetoothAdapter.STATE_TURNING_ON) {
+            return;
+        }
+        String val = mService.getAdapterProperties().getProperty("Devices");
+        if (val == null) {
+            return;
+        }
+        String[] bonds = val.split(",");
+        if (bonds == null) {
+            return;
+        }
+        mState.clear();
+        if (DBG) Log.d(TAG, "found " + bonds.length + " bonded devices");
+        for (String device : bonds) {
+            mState.put(mService.getAddressFromObjectPath(device).toUpperCase(),
+                    BluetoothDevice.BOND_BONDED);
+        }
+    }
+
+    public synchronized void setBondState(String address, int state) {
+        setBondState(address, state, 0);
+    }
+
+    /** reason is ignored unless state == BOND_NOT_BONDED */
+    public synchronized void setBondState(String address, int state, int reason) {
+        if (DBG) Log.d(TAG, "setBondState " + "address" + " " + state + "reason: " + reason);
+
+        int oldState = getBondState(address);
+        if (oldState == state) {
+            return;
+        }
+
+        // Check if this was a pending outgoing bonding.
+        // If yes, reset the state.
+        if (oldState == BluetoothDevice.BOND_BONDING) {
+            if (address.equals(mPendingOutgoingBonding)) {
+                mPendingOutgoingBonding = null;
+            }
+        }
+
+        if (state == BluetoothDevice.BOND_BONDED) {
+            boolean setTrust = false;
+            if (mPairingRequestRcvd.contains(address)) setTrust = true;
+
+            mService.addProfileState(address, setTrust);
+            mPairingRequestRcvd.remove(address);
+
+        } else if (state == BluetoothDevice.BOND_BONDING) {
+            if (mA2dpProxy == null || mHeadsetProxy == null) {
+                getProfileProxy();
+            }
+        } else if (state == BluetoothDevice.BOND_NONE) {
+            mPairingRequestRcvd.remove(address);
+        }
+
+        setProfilePriorities(address, state);
+
+        if (DBG) {
+            Log.d(TAG, address + " bond state " + oldState + " -> " + state
+                + " (" + reason + ")");
+        }
+        Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mService.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, state);
+        intent.putExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, oldState);
+        if (state == BluetoothDevice.BOND_NONE) {
+            if (reason <= 0) {
+                Log.w(TAG, "setBondState() called to unbond device, but reason code is " +
+                      "invalid. Overriding reason code with BOND_RESULT_REMOVED");
+                reason = BluetoothDevice.UNBOND_REASON_REMOVED;
+            }
+            intent.putExtra(BluetoothDevice.EXTRA_REASON, reason);
+            mState.remove(address);
+        } else {
+            mState.put(address, state);
+        }
+
+        mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
+    }
+
+    public boolean isAutoPairingBlacklisted(String address) {
+        if (mAutoPairingAddressBlacklist != null) {
+            for (String blacklistAddress : mAutoPairingAddressBlacklist) {
+                if (address.startsWith(blacklistAddress)) return true;
+            }
+        }
+
+        if (mAutoPairingDynamicAddressBlacklist != null) {
+            for (String blacklistAddress: mAutoPairingDynamicAddressBlacklist) {
+                if (address.equals(blacklistAddress)) return true;
+            }
+        }
+
+        String name = mService.getRemoteName(address);
+        if (name != null) {
+            if (mAutoPairingExactNameBlacklist != null) {
+                for (String blacklistName : mAutoPairingExactNameBlacklist) {
+                    if (name.equals(blacklistName)) return true;
+                }
+            }
+
+            if (mAutoPairingPartialNameBlacklist != null) {
+                for (String blacklistName : mAutoPairingPartialNameBlacklist) {
+                    if (name.startsWith(blacklistName)) return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public boolean isFixedPinZerosAutoPairKeyboard(String address) {
+        // Note: the meaning of blacklist is reversed in this case.
+        // If its in the list, we can go ahead and auto pair since
+        // by default keyboard should have a variable PIN that we don't
+        // auto pair using 0000.
+        if (mAutoPairingFixedPinZerosKeyboardList != null) {
+            for (String blacklistAddress : mAutoPairingFixedPinZerosKeyboardList) {
+                if (address.startsWith(blacklistAddress)) return true;
+            }
+        }
+        return false;
+    }
+
+    public synchronized int getBondState(String address) {
+        Integer state = mState.get(address);
+        if (state == null) {
+            return BluetoothDevice.BOND_NONE;
+        }
+        return state.intValue();
+    }
+
+    /*package*/ synchronized String[] listInState(int state) {
+        ArrayList<String> result = new ArrayList<String>(mState.size());
+        for (Map.Entry<String, Integer> e : mState.entrySet()) {
+            if (e.getValue().intValue() == state) {
+                result.add(e.getKey());
+            }
+        }
+        return result.toArray(new String[result.size()]);
+    }
+
+    public synchronized void addAutoPairingFailure(String address) {
+        if (mAutoPairingDynamicAddressBlacklist == null) {
+            mAutoPairingDynamicAddressBlacklist = new ArrayList<String>();
+        }
+
+        updateAutoPairingData(address);
+        mAutoPairingDynamicAddressBlacklist.add(address);
+    }
+
+    public synchronized boolean isAutoPairingAttemptsInProgress(String address) {
+        return getAttempt(address) != 0;
+    }
+
+    public synchronized void clearPinAttempts(String address) {
+        if (DBG) Log.d(TAG, "clearPinAttempts: " + address);
+
+        mPinAttempt.remove(address);
+    }
+
+    public synchronized boolean hasAutoPairingFailed(String address) {
+        if (mAutoPairingDynamicAddressBlacklist == null) return false;
+
+        return mAutoPairingDynamicAddressBlacklist.contains(address);
+    }
+
+    public synchronized int getAttempt(String address) {
+        Integer attempt = mPinAttempt.get(address);
+        if (attempt == null) {
+            return 0;
+        }
+        return attempt.intValue();
+    }
+
+    public synchronized void attempt(String address) {
+        Integer attempt = mPinAttempt.get(address);
+        int newAttempt;
+        if (attempt == null) {
+            newAttempt = 1;
+        } else {
+            newAttempt = attempt.intValue() + 1;
+        }
+        if (DBG) Log.d(TAG, "attemp newAttempt: " + newAttempt);
+
+        mPinAttempt.put(address, new Integer(newAttempt));
+    }
+
+    private void getProfileProxy() {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+
+        if (mA2dpProxy == null) {
+            bluetoothAdapter.getProfileProxy(mContext, mProfileServiceListener,
+                                             BluetoothProfile.A2DP);
+        }
+
+        if (mHeadsetProxy == null) {
+            bluetoothAdapter.getProfileProxy(mContext, mProfileServiceListener,
+                                             BluetoothProfile.HEADSET);
+        }
+    }
+
+    private void closeProfileProxy() {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+
+        if (mA2dpProxy != null) {
+            bluetoothAdapter.closeProfileProxy(BluetoothProfile.A2DP, mA2dpProxy);
+        }
+
+        if (mHeadsetProxy != null) {
+            bluetoothAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mHeadsetProxy);
+        }
+    }
+
+    private BluetoothProfile.ServiceListener mProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            if (profile == BluetoothProfile.A2DP) {
+                mA2dpProxy = (BluetoothA2dp) proxy;
+            } else if (profile == BluetoothProfile.HEADSET) {
+                mHeadsetProxy = (BluetoothHeadset) proxy;
+            }
+        }
+
+        public void onServiceDisconnected(int profile) {
+            if (profile == BluetoothProfile.A2DP) {
+                mA2dpProxy = null;
+            } else if (profile == BluetoothProfile.HEADSET) {
+                mHeadsetProxy = null;
+            }
+        }
+    };
+
+    private void copyAutoPairingData() {
+        FileInputStream in = null;
+        FileOutputStream out = null;
+        try {
+            File file = new File(DYNAMIC_AUTO_PAIRING_BLACKLIST);
+            if (file.exists()) return;
+
+            in = new FileInputStream(AUTO_PAIRING_BLACKLIST);
+            out= new FileOutputStream(DYNAMIC_AUTO_PAIRING_BLACKLIST);
+
+            byte[] buf = new byte[1024];
+            int len;
+            while ((len = in.read(buf)) > 0) {
+                out.write(buf, 0, len);
+            }
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException: copyAutoPairingData " + e);
+        } catch (IOException e) {
+            Log.e(TAG, "IOException: copyAutoPairingData " + e);
+        } finally {
+             try {
+                 if (in != null) in.close();
+                 if (out != null) out.close();
+             } catch (IOException e) {}
+        }
+    }
+
+    synchronized public void readAutoPairingData() {
+        if (mAutoPairingAddressBlacklist != null) return;
+        copyAutoPairingData();
+        FileInputStream fstream = null;
+        try {
+            fstream = new FileInputStream(DYNAMIC_AUTO_PAIRING_BLACKLIST);
+            DataInputStream in = new DataInputStream(fstream);
+            BufferedReader file = new BufferedReader(new InputStreamReader(in));
+            String line;
+            while((line = file.readLine()) != null) {
+                line = line.trim();
+                if (line.length() == 0 || line.startsWith("//")) continue;
+                String[] value = line.split("=");
+                if (value != null && value.length == 2) {
+                    String[] val = value[1].split(",");
+                    if (value[0].equalsIgnoreCase("AddressBlacklist")) {
+                        mAutoPairingAddressBlacklist =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else if (value[0].equalsIgnoreCase("ExactNameBlacklist")) {
+                        mAutoPairingExactNameBlacklist =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else if (value[0].equalsIgnoreCase("PartialNameBlacklist")) {
+                        mAutoPairingPartialNameBlacklist =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else if (value[0].equalsIgnoreCase("FixedPinZerosKeyboardBlacklist")) {
+                        mAutoPairingFixedPinZerosKeyboardList =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else if (value[0].equalsIgnoreCase("DynamicAddressBlacklist")) {
+                        mAutoPairingDynamicAddressBlacklist =
+                            new ArrayList<String>(Arrays.asList(val));
+                    } else {
+                        Log.e(TAG, "Error parsing Auto pairing blacklist file");
+                    }
+                }
+            }
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException: readAutoPairingData " + e);
+        } catch (IOException e) {
+            Log.e(TAG, "IOException: readAutoPairingData " + e);
+        } finally {
+            if (fstream != null) {
+                try {
+                    fstream.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+    }
+
+    // This function adds a bluetooth address to the auto pairing blacklist
+    // file. These addresses are added to DynamicAddressBlacklistSection
+    private void updateAutoPairingData(String address) {
+        BufferedWriter out = null;
+        try {
+            out = new BufferedWriter(new FileWriter(DYNAMIC_AUTO_PAIRING_BLACKLIST, true));
+            StringBuilder str = new StringBuilder();
+            if (mAutoPairingDynamicAddressBlacklist.size() == 0) {
+                str.append("DynamicAddressBlacklist=");
+            }
+            str.append(address);
+            str.append(",");
+            out.write(str.toString());
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException: updateAutoPairingData " + e);
+        } catch (IOException e) {
+            Log.e(TAG, "IOException: updateAutoPairingData " + e);
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+    }
+
+    // Set service priority of Hid, A2DP and Headset profiles depending on
+    // the bond state change
+    private void setProfilePriorities(String address, int state) {
+        BluetoothDevice remoteDevice = mService.getRemoteDevice(address);
+        // HID is handled by BluetoothService
+        mBluetoothInputProfileHandler.setInitialInputDevicePriority(remoteDevice, state);
+
+        // Set service priority of A2DP and Headset
+        // We used to do the priority change in the 2 services after the broadcast
+        //   intent reach them. But that left a small time gap that could reject
+        //   incoming connection due to undefined priorities.
+        if (state == BluetoothDevice.BOND_BONDED) {
+            if (mA2dpProxy != null &&
+                  mA2dpProxy.getPriority(remoteDevice) == BluetoothProfile.PRIORITY_UNDEFINED) {
+                mA2dpProxy.setPriority(remoteDevice, BluetoothProfile.PRIORITY_ON);
+            }
+
+            if (mHeadsetProxy != null &&
+                  mHeadsetProxy.getPriority(remoteDevice) == BluetoothProfile.PRIORITY_UNDEFINED) {
+                mHeadsetProxy.setPriority(remoteDevice, BluetoothProfile.PRIORITY_ON);
+            }
+        } else if (state == BluetoothDevice.BOND_NONE) {
+            if (mA2dpProxy != null) {
+                mA2dpProxy.setPriority(remoteDevice, BluetoothProfile.PRIORITY_UNDEFINED);
+            }
+            if (mHeadsetProxy != null) {
+                mHeadsetProxy.setPriority(remoteDevice, BluetoothProfile.PRIORITY_UNDEFINED);
+            }
+        }
+
+        if (mA2dpProxy == null || mHeadsetProxy == null) {
+            Log.e(TAG, "Proxy is null:" + mA2dpProxy + ":" + mHeadsetProxy);
+        }
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) return;
+
+            String action = intent.getAction();
+            if (action.equals(BluetoothDevice.ACTION_PAIRING_REQUEST)) {
+                BluetoothDevice dev = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                String address = dev.getAddress();
+                mPairingRequestRcvd.add(address);
+            }
+        }
+    };
+}
diff --git a/core/java/android/server/BluetoothDeviceProperties.java b/core/java/android/server/BluetoothDeviceProperties.java
new file mode 100644
index 0000000..fe3ef79
--- /dev/null
+++ b/core/java/android/server/BluetoothDeviceProperties.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.os.ParcelUuid;
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+class BluetoothDeviceProperties {
+
+    private static final String TAG = "BluetoothDeviceProperties";
+
+    private final HashMap<String, Map<String, String>> mPropertiesMap;
+    private final BluetoothService mService;
+
+    BluetoothDeviceProperties(BluetoothService service) {
+        mPropertiesMap = new HashMap<String, Map<String, String>>();
+        mService = service;
+    }
+
+    Map<String, String> addProperties(String address, String[] properties) {
+        /*
+         * We get a DeviceFound signal every time RSSI changes or name changes.
+         * Don't create a new Map object every time.
+         */
+        Map<String, String> propertyValues;
+        synchronized(mPropertiesMap) {
+            propertyValues = mPropertiesMap.get(address);
+            if (propertyValues == null) {
+                propertyValues = new HashMap<String, String>();
+            }
+
+            for (int i = 0; i < properties.length; i++) {
+                String name = properties[i];
+                String newValue = null;
+                int len;
+                if (name == null) {
+                    Log.e(TAG, "Error: Remote Device Property at index "
+                        + i + " is null");
+                    continue;
+                }
+                if (name.equals("UUIDs") || name.equals("Nodes")) {
+                    StringBuilder str = new StringBuilder();
+                    len = Integer.valueOf(properties[++i]);
+                    for (int j = 0; j < len; j++) {
+                        str.append(properties[++i]);
+                        str.append(",");
+                    }
+                    if (len > 0) {
+                        newValue = str.toString();
+                    }
+                } else {
+                    newValue = properties[++i];
+                }
+
+                propertyValues.put(name, newValue);
+            }
+            mPropertiesMap.put(address, propertyValues);
+        }
+
+        // We have added a new remote device or updated its properties.
+        // Also update the serviceChannel cache.
+        mService.updateDeviceServiceChannelCache(address);
+        return propertyValues;
+    }
+
+    void setProperty(String address, String name, String value) {
+        synchronized(mPropertiesMap) {
+            Map <String, String> propVal = mPropertiesMap.get(address);
+            if (propVal != null) {
+                propVal.put(name, value);
+                mPropertiesMap.put(address, propVal);
+            } else {
+                Log.e(TAG, "setRemoteDeviceProperty for a device not in cache:" + address);
+            }
+        }
+    }
+
+    boolean isInCache(String address) {
+        synchronized (mPropertiesMap) {
+            return (mPropertiesMap.get(address) != null);
+        }
+    }
+
+    boolean isEmpty() {
+        synchronized (mPropertiesMap) {
+            return mPropertiesMap.isEmpty();
+        }
+    }
+
+    Set<String> keySet() {
+        synchronized (mPropertiesMap) {
+            return mPropertiesMap.keySet();
+        }
+    }
+
+    String getProperty(String address, String property) {
+        synchronized(mPropertiesMap) {
+            Map<String, String> properties = mPropertiesMap.get(address);
+            if (properties != null) {
+                return properties.get(property);
+            } else {
+                // Query for remote device properties, again.
+                // We will need to reload the cache when we switch Bluetooth on / off
+                // or if we crash.
+                properties = updateCache(address);
+                if (properties != null) {
+                    return properties.get(property);
+                }
+            }
+        }
+        Log.e(TAG, "getRemoteDeviceProperty: " + property + " not present: " + address);
+        return null;
+    }
+
+    Map<String, String> updateCache(String address) {
+        String[] propValues = mService.getRemoteDeviceProperties(address);
+        if (propValues != null) {
+            return addProperties(address, propValues);
+        }
+        return null;
+    }
+}
diff --git a/core/java/android/server/BluetoothEventLoop.java b/core/java/android/server/BluetoothEventLoop.java
new file mode 100644
index 0000000..b758e7f
--- /dev/null
+++ b/core/java/android/server/BluetoothEventLoop.java
@@ -0,0 +1,1067 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHealth;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ParcelUuid;
+import android.os.PowerManager;
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.List;
+
+
+/**
+ * @hide
+ */
+class BluetoothEventLoop {
+    private static final String TAG = "BluetoothEventLoop";
+    private static final boolean DBG = false;
+
+    private int mNativeData;
+    private Thread mThread;
+    private boolean mStarted;
+    private boolean mInterrupted;
+
+    private final HashMap<String, Integer> mPasskeyAgentRequestData;
+    private final HashMap<String, Integer> mAuthorizationAgentRequestData;
+    private final BluetoothService mBluetoothService;
+    private final BluetoothAdapter mAdapter;
+    private final BluetoothAdapterStateMachine mBluetoothState;
+    private BluetoothA2dp mA2dp;
+    private final Context mContext;
+    // The WakeLock is used for bringing up the LCD during a pairing request
+    // from remote device when Android is in Suspend state.
+    private PowerManager.WakeLock mWakeLock;
+
+    private static final int EVENT_PAIRING_CONSENT_DELAYED_ACCEPT = 1;
+    private static final int EVENT_AGENT_CANCEL = 2;
+
+    private static final int CREATE_DEVICE_ALREADY_EXISTS = 1;
+    private static final int CREATE_DEVICE_SUCCESS = 0;
+    private static final int CREATE_DEVICE_FAILED = -1;
+
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+    private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            String address = null;
+            switch (msg.what) {
+            case EVENT_PAIRING_CONSENT_DELAYED_ACCEPT:
+                address = (String)msg.obj;
+                if (address != null) {
+                    mBluetoothService.setPairingConfirmation(address, true);
+                }
+                break;
+            case EVENT_AGENT_CANCEL:
+                // Set the Bond State to BOND_NONE.
+                // We always have only 1 device in BONDING state.
+                String[] devices = mBluetoothService.listInState(BluetoothDevice.BOND_BONDING);
+                if (devices.length == 0) {
+                    break;
+                } else if (devices.length > 1) {
+                    Log.e(TAG, " There is more than one device in the Bonding State");
+                    break;
+                }
+                address = devices[0];
+                mBluetoothService.setBondState(address,
+                        BluetoothDevice.BOND_NONE,
+                        BluetoothDevice.UNBOND_REASON_REMOTE_AUTH_CANCELED);
+                break;
+            }
+        }
+    };
+
+    static { classInitNative(); }
+    private static native void classInitNative();
+
+    /* package */ BluetoothEventLoop(Context context, BluetoothAdapter adapter,
+                                     BluetoothService bluetoothService,
+                                     BluetoothAdapterStateMachine bluetoothState) {
+        mBluetoothService = bluetoothService;
+        mContext = context;
+        mBluetoothState = bluetoothState;
+        mPasskeyAgentRequestData = new HashMap<String, Integer>();
+        mAuthorizationAgentRequestData = new HashMap<String, Integer>();
+        mAdapter = adapter;
+        //WakeLock instantiation in BluetoothEventLoop class
+        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP
+                | PowerManager.ON_AFTER_RELEASE, TAG);
+        mWakeLock.setReferenceCounted(false);
+        initializeNativeDataNative();
+    }
+
+    /*package*/ void getProfileProxy() {
+        mAdapter.getProfileProxy(mContext, mProfileServiceListener, BluetoothProfile.A2DP);
+        mAdapter.getProfileProxy(mContext, mProfileServiceListener, BluetoothProfile.INPUT_DEVICE);
+    }
+
+    private BluetoothProfile.ServiceListener mProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            if (profile == BluetoothProfile.A2DP) {
+                mA2dp = (BluetoothA2dp) proxy;
+            }
+        }
+        public void onServiceDisconnected(int profile) {
+            if (profile == BluetoothProfile.A2DP) {
+                mA2dp = null;
+            }
+        }
+    };
+
+
+    protected void finalize() throws Throwable {
+        try {
+            cleanupNativeDataNative();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    /* package */ HashMap<String, Integer> getPasskeyAgentRequestData() {
+        return mPasskeyAgentRequestData;
+    }
+
+    /* package */ HashMap<String, Integer> getAuthorizationAgentRequestData() {
+        return mAuthorizationAgentRequestData;
+    }
+
+    /* package */ void start() {
+
+        if (!isEventLoopRunningNative()) {
+            if (DBG) log("Starting Event Loop thread");
+            startEventLoopNative();
+        }
+    }
+
+    public void stop() {
+        if (isEventLoopRunningNative()) {
+            if (DBG) log("Stopping Event Loop thread");
+            stopEventLoopNative();
+        }
+    }
+
+    public boolean isEventLoopRunning() {
+        return isEventLoopRunningNative();
+    }
+
+    private void addDevice(String address, String[] properties) {
+        BluetoothDeviceProperties deviceProperties =
+                mBluetoothService.getDeviceProperties();
+        deviceProperties.addProperties(address, properties);
+        String rssi = deviceProperties.getProperty(address, "RSSI");
+        String classValue = deviceProperties.getProperty(address, "Class");
+        String name = deviceProperties.getProperty(address, "Name");
+        short rssiValue;
+        // For incoming connections, we don't get the RSSI value. Use a default of MIN_VALUE.
+        // If we accept the pairing, we will automatically show it at the top of the list.
+        if (rssi != null) {
+            rssiValue = (short)Integer.valueOf(rssi).intValue();
+        } else {
+            rssiValue = Short.MIN_VALUE;
+        }
+        if (classValue != null) {
+            Intent intent = new Intent(BluetoothDevice.ACTION_FOUND);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+            intent.putExtra(BluetoothDevice.EXTRA_CLASS,
+                    new BluetoothClass(Integer.valueOf(classValue)));
+            intent.putExtra(BluetoothDevice.EXTRA_RSSI, rssiValue);
+            intent.putExtra(BluetoothDevice.EXTRA_NAME, name);
+
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else {
+            log ("ClassValue: " + classValue + " for remote device: " + address + " is null");
+        }
+    }
+
+    /**
+     * Called by native code on a DeviceFound signal from org.bluez.Adapter.
+     *
+     * @param address the MAC address of the new device
+     * @param properties an array of property keys and value strings
+     *
+     * @see BluetoothDeviceProperties#addProperties(String, String[])
+     */
+    private void onDeviceFound(String address, String[] properties) {
+        if (properties == null) {
+            Log.e(TAG, "ERROR: Remote device properties are null");
+            return;
+        }
+        addDevice(address, properties);
+    }
+
+    /**
+     * Called by native code on a DeviceDisappeared signal from
+     * org.bluez.Adapter.
+     *
+     * @param address the MAC address of the disappeared device
+     */
+    private void onDeviceDisappeared(String address) {
+        Intent intent = new Intent(BluetoothDevice.ACTION_DISAPPEARED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+    }
+
+    /**
+     * Called by native code on a DisconnectRequested signal from
+     * org.bluez.Device.
+     *
+     * @param deviceObjectPath the object path for the disconnecting device
+     */
+    private void onDeviceDisconnectRequested(String deviceObjectPath) {
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) {
+            Log.e(TAG, "onDeviceDisconnectRequested: Address of the remote device in null");
+            return;
+        }
+        Intent intent = new Intent(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+    }
+
+    /**
+     * Called by native code for the async response to a CreatePairedDevice
+     * method call to org.bluez.Adapter.
+     *
+     * @param address the MAC address of the device to pair
+     * @param result success or error result for the pairing operation
+     */
+    private void onCreatePairedDeviceResult(String address, int result) {
+        address = address.toUpperCase();
+        mBluetoothService.onCreatePairedDeviceResult(address, result);
+    }
+
+    /**
+     * Called by native code on a DeviceCreated signal from org.bluez.Adapter.
+     *
+     * @param deviceObjectPath the object path for the created device
+     */
+    private void onDeviceCreated(String deviceObjectPath) {
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) {
+            Log.e(TAG, "onDeviceCreated: device address null!" + " deviceObjectPath: " +
+                  deviceObjectPath);
+            return;
+        }
+        if (!mBluetoothService.isRemoteDeviceInCache(address)) {
+            // Incoming connection, we haven't seen this device, add to cache.
+            String[] properties = mBluetoothService.getRemoteDeviceProperties(address);
+            if (properties != null) {
+                addDevice(address, properties);
+            }
+        }
+    }
+
+    /**
+     * Called by native code on a DeviceRemoved signal from org.bluez.Adapter.
+     *
+     * @param deviceObjectPath the object path for the removed device
+     */
+    private void onDeviceRemoved(String deviceObjectPath) {
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address != null) {
+            mBluetoothService.setBondState(address.toUpperCase(), BluetoothDevice.BOND_NONE,
+                BluetoothDevice.UNBOND_REASON_REMOVED);
+            mBluetoothService.setRemoteDeviceProperty(address, "UUIDs", null);
+        }
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.Adapter. This method is also called from
+     * {@link BluetoothAdapterStateMachine} to set the "Pairable"
+     * property when Bluetooth is enabled.
+     *
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    /*package*/ void onPropertyChanged(String[] propValues) {
+        BluetoothAdapterProperties adapterProperties =
+                mBluetoothService.getAdapterProperties();
+
+        if (adapterProperties.isEmpty()) {
+            // We have got a property change before
+            // we filled up our cache.
+            adapterProperties.getAllProperties();
+        }
+        log("Property Changed: " + propValues[0] + " : " + propValues[1]);
+        String name = propValues[0];
+        if (name.equals("Name")) {
+            adapterProperties.setProperty(name, propValues[1]);
+            Intent intent = new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
+            intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME, propValues[1]);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Pairable") || name.equals("Discoverable")) {
+            adapterProperties.setProperty(name, propValues[1]);
+
+            if (name.equals("Discoverable")) {
+                mBluetoothState.sendMessage(BluetoothAdapterStateMachine.SCAN_MODE_CHANGED);
+            }
+
+            String pairable = name.equals("Pairable") ? propValues[1] :
+                adapterProperties.getProperty("Pairable");
+            String discoverable = name.equals("Discoverable") ? propValues[1] :
+                adapterProperties.getProperty("Discoverable");
+
+            // This shouldn't happen, unless Adapter Properties are null.
+            if (pairable == null || discoverable == null)
+                return;
+
+            int mode = BluetoothService.bluezStringToScanMode(
+                    pairable.equals("true"),
+                    discoverable.equals("true"));
+            if (mode >= 0) {
+                Intent intent = new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
+                intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mode);
+                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+                mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+            }
+        } else if (name.equals("Discovering")) {
+            Intent intent;
+            adapterProperties.setProperty(name, propValues[1]);
+            if (propValues[1].equals("true")) {
+                intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
+            } else {
+                // Stop the discovery.
+                mBluetoothService.cancelDiscovery();
+                intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
+            }
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Devices") || name.equals("UUIDs")) {
+            String value = null;
+            int len = Integer.valueOf(propValues[1]);
+            if (len > 0) {
+                StringBuilder str = new StringBuilder();
+                for (int i = 2; i < propValues.length; i++) {
+                    str.append(propValues[i]);
+                    str.append(",");
+                }
+                value = str.toString();
+            }
+            adapterProperties.setProperty(name, value);
+            if (name.equals("UUIDs")) {
+                mBluetoothService.updateBluetoothState(value);
+            }
+        } else if (name.equals("Powered")) {
+            mBluetoothState.sendMessage(BluetoothAdapterStateMachine.POWER_STATE_CHANGED,
+                propValues[1].equals("true") ? new Boolean(true) : new Boolean(false));
+        } else if (name.equals("DiscoverableTimeout")) {
+            adapterProperties.setProperty(name, propValues[1]);
+        }
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.Device.
+     *
+     * @param deviceObjectPath the object path for the changed device
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    private void onDevicePropertyChanged(String deviceObjectPath, String[] propValues) {
+        String name = propValues[0];
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) {
+            Log.e(TAG, "onDevicePropertyChanged: Address of the remote device in null");
+            return;
+        }
+        log("Device property changed: " + address + " property: "
+            + name + " value: " + propValues[1]);
+
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        if (name.equals("Name")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = new Intent(BluetoothDevice.ACTION_NAME_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothDevice.EXTRA_NAME, propValues[1]);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Alias")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = new Intent(BluetoothDevice.ACTION_ALIAS_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Class")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = new Intent(BluetoothDevice.ACTION_CLASS_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothDevice.EXTRA_CLASS,
+                    new BluetoothClass(Integer.valueOf(propValues[1])));
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("Connected")) {
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+            Intent intent = null;
+            if (propValues[1].equals("true")) {
+                intent = new Intent(BluetoothDevice.ACTION_ACL_CONNECTED);
+                // Set the link timeout to 8000 slots (5 sec timeout)
+                // for bluetooth docks.
+                if (mBluetoothService.isBluetoothDock(address)) {
+                    mBluetoothService.setLinkTimeout(address, 8000);
+                }
+            } else {
+                intent = new Intent(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+            }
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        } else if (name.equals("UUIDs")) {
+            String uuid = null;
+            int len = Integer.valueOf(propValues[1]);
+            if (len > 0) {
+                StringBuilder str = new StringBuilder();
+                for (int i = 2; i < propValues.length; i++) {
+                    str.append(propValues[i]);
+                    str.append(",");
+                }
+                uuid = str.toString();
+            }
+            mBluetoothService.setRemoteDeviceProperty(address, name, uuid);
+
+            // UUIDs have changed, query remote service channel and update cache.
+            mBluetoothService.updateDeviceServiceChannelCache(address);
+
+            mBluetoothService.sendUuidIntent(address);
+        } else if (name.equals("Paired")) {
+            if (propValues[1].equals("true")) {
+                // If locally initiated pairing, we will
+                // not go to BOND_BONDED state until we have received a
+                // successful return value in onCreatePairedDeviceResult
+                if (null == mBluetoothService.getPendingOutgoingBonding()) {
+                    mBluetoothService.setBondState(address, BluetoothDevice.BOND_BONDED);
+                }
+            } else {
+                mBluetoothService.setBondState(address, BluetoothDevice.BOND_NONE);
+                mBluetoothService.setRemoteDeviceProperty(address, "Trusted", "false");
+            }
+        } else if (name.equals("Trusted")) {
+            if (DBG)
+                log("set trust state succeeded, value is: " + propValues[1]);
+            mBluetoothService.setRemoteDeviceProperty(address, name, propValues[1]);
+        }
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.Input.
+     *
+     * @param path the object path for the changed input device
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    private void onInputDevicePropertyChanged(String path, String[] propValues) {
+        String address = mBluetoothService.getAddressFromObjectPath(path);
+        if (address == null) {
+            Log.e(TAG, "onInputDevicePropertyChanged: Address of the remote device is null");
+            return;
+        }
+        log("Input Device : Name of Property is: " + propValues[0]);
+        boolean state = false;
+        if (propValues[1].equals("true")) {
+            state = true;
+        }
+        mBluetoothService.handleInputDevicePropertyChange(address, state);
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.Network.
+     *
+     * @param deviceObjectPath the object path for the changed PAN device
+     * @param propValues a string array containing the key and one or more
+     *  values.
+     */
+    private void onPanDevicePropertyChanged(String deviceObjectPath, String[] propValues) {
+        String name = propValues[0];
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) {
+            Log.e(TAG, "onPanDevicePropertyChanged: Address of the remote device in null");
+            return;
+        }
+        if (DBG) {
+            log("Pan Device property changed: " + address + "  property: "
+                    + name + " value: "+ propValues[1]);
+        }
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        if (name.equals("Connected")) {
+            if (propValues[1].equals("false")) {
+                mBluetoothService.handlePanDeviceStateChange(device,
+                                          BluetoothPan.STATE_DISCONNECTED,
+                                          BluetoothPan.LOCAL_PANU_ROLE);
+            }
+        } else if (name.equals("Interface")) {
+            String iface = propValues[1];
+            if (!iface.equals("")) {
+                mBluetoothService.handlePanDeviceStateChange(device, iface,
+                                              BluetoothPan.STATE_CONNECTED,
+                                              BluetoothPan.LOCAL_PANU_ROLE);
+            }
+        }
+    }
+
+    private String checkPairingRequestAndGetAddress(String objectPath, int nativeData) {
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) {
+            Log.e(TAG, "Unable to get device address in checkPairingRequestAndGetAddress, " +
+                  "returning null");
+            return null;
+        }
+        address = address.toUpperCase();
+        mPasskeyAgentRequestData.put(address, new Integer(nativeData));
+
+        if (mBluetoothService.getBluetoothState() == BluetoothAdapter.STATE_TURNING_OFF) {
+            // shutdown path
+            mBluetoothService.cancelPairingUserInput(address);
+            return null;
+        }
+        // Set state to BONDING. For incoming connections it will be set here.
+        // For outgoing connections, it gets set when we call createBond.
+        // Also set it only when the state is not already Bonded, we can sometimes
+        // get an authorization request from the remote end if it doesn't have the link key
+        // while we still have it.
+        if (mBluetoothService.getBondState(address) != BluetoothDevice.BOND_BONDED)
+            mBluetoothService.setBondState(address, BluetoothDevice.BOND_BONDING);
+        return address;
+    }
+
+    /**
+     * Called by native code on a RequestPairingConsent method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device to request pairing consent for
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestPairingConsent(String objectPath, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+
+        /* The link key will not be stored if the incoming request has MITM
+         * protection switched on. Unfortunately, some devices have MITM
+         * switched on even though their capabilities are NoInputNoOutput,
+         * so we may get this request many times. Also if we respond immediately,
+         * the other end is unable to handle it. Delay sending the message.
+         */
+        if (mBluetoothService.getBondState(address) == BluetoothDevice.BOND_BONDED) {
+            Message message = mHandler.obtainMessage(EVENT_PAIRING_CONSENT_DELAYED_ACCEPT);
+            message.obj = address;
+            mHandler.sendMessageDelayed(message, 1500);
+            return;
+        }
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                        BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+        return;
+    }
+
+    /**
+     * Called by native code on a RequestConfirmation method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device to confirm the passkey for
+     * @param passkey an integer containing the 6-digit passkey to confirm
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestPasskeyConfirmation(String objectPath, int passkey, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_KEY, passkey);
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.PAIRING_VARIANT_PASSKEY_CONFIRMATION);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+        return;
+    }
+
+    /**
+     * Called by native code on a RequestPasskey method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device requesting a passkey
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestPasskey(String objectPath, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.PAIRING_VARIANT_PASSKEY);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+        return;
+    }
+
+    /**
+     * Called by native code on a RequestPinCode method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device requesting a PIN code
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestPinCode(String objectPath, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+
+        String pendingOutgoingAddress =
+                mBluetoothService.getPendingOutgoingBonding();
+        BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
+        int btDeviceClass = btClass.getDeviceClass();
+
+        if (address.equals(pendingOutgoingAddress)) {
+            // we initiated the bonding
+
+            // Check if its a dock
+            if (mBluetoothService.isBluetoothDock(address)) {
+                String pin = mBluetoothService.getDockPin();
+                mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
+                return;
+            }
+
+            // try 0000 once if the device looks dumb
+            switch (btDeviceClass) {
+            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
+            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
+            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
+            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
+            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
+                if (mBluetoothService.attemptAutoPair(address)) return;
+           }
+        }
+
+        if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD ||
+            btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
+            // Its a keyboard. Follow the HID spec recommendation of creating the
+            // passkey and displaying it to the user. If the keyboard doesn't follow
+            // the spec recommendation, check if the keyboard has a fixed PIN zero
+            // and pair.
+            if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
+                mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
+                return;
+            }
+
+            // Generate a variable PIN. This is not truly random but good enough.
+            int pin = (int) Math.floor(Math.random() * 10000);
+            sendDisplayPinIntent(address, pin);
+            return;
+        }
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+        return;
+    }
+
+    /**
+     * Called by native code on a DisplayPasskey method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device to display the passkey for
+     * @param passkey an integer containing the 6-digit passkey
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onDisplayPasskey(String objectPath, int passkey, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_KEY, passkey);
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                        BluetoothDevice.PAIRING_VARIANT_DISPLAY_PASSKEY);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        //Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
+    }
+
+    private void sendDisplayPinIntent(String address, int pin) {
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_KEY, pin);
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                        BluetoothDevice.PAIRING_VARIANT_DISPLAY_PIN);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        //Release wakelock to allow the LCD to go off after the PIN popup notifcation.
+        mWakeLock.release();
+    }
+
+    /**
+     * Called by native code on a RequestOobData method call to
+     * org.bluez.Agent.
+     *
+     * @param objectPath the path of the device requesting OOB data
+     * @param nativeData a native pointer to the original D-Bus message
+     */
+    private void onRequestOobData(String objectPath, int nativeData) {
+        String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
+        if (address == null) return;
+
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.PAIRING_VARIANT_OOB_CONSENT);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+    }
+
+    /**
+     * Called by native code on an Authorize method call to org.bluez.Agent.
+     *
+     * @param objectPath the path of the device requesting to be authorized
+     * @param deviceUuid the UUID of the requesting device
+     * @param nativeData reference for native data
+     */
+    private void  onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
+        if (!mBluetoothService.isEnabled()) return;
+
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) {
+            Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
+            return;
+        }
+
+        boolean authorized = false;
+        ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
+
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
+
+        // Bluez sends the UUID of the local service being accessed, _not_ the
+        // remote service
+        if (mA2dp != null &&
+            (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid)
+              || BluetoothUuid.isAdvAudioDist(uuid)) &&
+              !isOtherSinkInNonDisconnectedState(address)) {
+            authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
+            if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
+                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
+                // Some headsets try to connect AVCTP before AVDTP - against the recommendation
+                // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
+                // machine.  We don't handle AVCTP signals currently. We only send
+                // intents for AVDTP state changes. We need to handle both of them in
+                // some cases. For now, just don't move to incoming state in this case.
+                mBluetoothService.notifyIncomingA2dpConnection(address, false);
+            } else {
+                Log.i(TAG, "" + authorized +
+                      "Incoming A2DP / AVRCP connection from " + address);
+                mA2dp.allowIncomingConnect(device, authorized);
+                mBluetoothService.notifyIncomingA2dpConnection(address, true);
+            }
+        } else if (BluetoothUuid.isInputDevice(uuid)) {
+            // We can have more than 1 input device connected.
+            authorized = mBluetoothService.getInputDevicePriority(device) >
+                    BluetoothInputDevice.PRIORITY_OFF;
+            if (authorized) {
+                Log.i(TAG, "First check pass for incoming HID connection from " + address);
+                // notify profile state change
+                mBluetoothService.notifyIncomingHidConnection(address);
+            } else {
+                Log.i(TAG, "Rejecting incoming HID connection from " + address);
+                mBluetoothService.allowIncomingProfileConnect(device, authorized);
+            }
+        } else if (BluetoothUuid.isBnep(uuid)) {
+            // PAN doesn't go to the state machine, accept or reject from here
+            authorized = mBluetoothService.allowIncomingTethering();
+            mBluetoothService.allowIncomingProfileConnect(device, authorized);
+        } else {
+            Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
+            mBluetoothService.allowIncomingProfileConnect(device, authorized);
+        }
+        log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
+    }
+
+    private boolean onAgentOutOfBandDataAvailable(String objectPath) {
+        if (!mBluetoothService.isEnabled()) return false;
+
+        String address = mBluetoothService.getAddressFromObjectPath(objectPath);
+        if (address == null) return false;
+
+        if (mBluetoothService.getDeviceOutOfBandData(
+            mAdapter.getRemoteDevice(address)) != null) {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isOtherSinkInNonDisconnectedState(String address) {
+        List<BluetoothDevice> devices =
+            mA2dp.getDevicesMatchingConnectionStates(new int[] {BluetoothA2dp.STATE_CONNECTED,
+                                                     BluetoothA2dp.STATE_CONNECTING,
+                                                     BluetoothA2dp.STATE_DISCONNECTING});
+
+        if (devices.size() == 0) return false;
+        for (BluetoothDevice dev: devices) {
+            if (!dev.getAddress().equals(address)) return true;
+        }
+        return false;
+    }
+
+    /**
+     * Called by native code on a Cancel method call to org.bluez.Agent.
+     */
+    private void onAgentCancel() {
+        Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_CANCEL);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+
+        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_AGENT_CANCEL),
+                   1500);
+
+        return;
+    }
+
+    /**
+     * Called by native code for the async response to a DiscoverServices
+     * method call to org.bluez.Adapter.
+     *
+     * @param deviceObjectPath the path for the specified device
+     * @param result true for success; false on error
+     */
+    private void onDiscoverServicesResult(String deviceObjectPath, boolean result) {
+        String address = mBluetoothService.getAddressFromObjectPath(deviceObjectPath);
+        if (address == null) return;
+
+        // We don't parse the xml here, instead just query Bluez for the properties.
+        if (result) {
+            mBluetoothService.updateRemoteDevicePropertiesCache(address);
+        }
+        mBluetoothService.sendUuidIntent(address);
+        mBluetoothService.makeServiceChannelCallbacks(address);
+    }
+
+    /**
+     * Called by native code for the async response to a CreateDevice
+     * method call to org.bluez.Adapter.
+     *
+     * @param address the MAC address of the device to create
+     * @param result {@link #CREATE_DEVICE_SUCCESS},
+     *  {@link #CREATE_DEVICE_ALREADY_EXISTS} or {@link #CREATE_DEVICE_FAILED}}
+     */
+    private void onCreateDeviceResult(String address, int result) {
+        if (DBG) log("Result of onCreateDeviceResult:" + result);
+
+        switch (result) {
+        case CREATE_DEVICE_ALREADY_EXISTS:
+            String path = mBluetoothService.getObjectPathFromAddress(address);
+            if (path != null) {
+                mBluetoothService.discoverServicesNative(path, "");
+                break;
+            }
+            Log.w(TAG, "Device exists, but we don't have the bluez path, failing");
+            // fall-through
+        case CREATE_DEVICE_FAILED:
+            mBluetoothService.sendUuidIntent(address);
+            mBluetoothService.makeServiceChannelCallbacks(address);
+            break;
+        case CREATE_DEVICE_SUCCESS:
+            // nothing to do, UUID intent's will be sent via property changed
+        }
+    }
+
+    /**
+     * Called by native code for the async response to a Connect
+     * method call to org.bluez.Input.
+     *
+     * @param path the path of the specified input device
+     * @param result Result code of the operation.
+     */
+    private void onInputDeviceConnectionResult(String path, int result) {
+        // Success case gets handled by Property Change signal
+        if (result != BluetoothInputDevice.INPUT_OPERATION_SUCCESS) {
+            String address = mBluetoothService.getAddressFromObjectPath(path);
+            if (address == null) return;
+
+            boolean connected = false;
+            BluetoothDevice device = mAdapter.getRemoteDevice(address);
+            int state = mBluetoothService.getInputDeviceConnectionState(device);
+            if (state == BluetoothInputDevice.STATE_CONNECTING) {
+                if (result == BluetoothInputDevice.INPUT_CONNECT_FAILED_ALREADY_CONNECTED) {
+                    connected = true;
+                } else {
+                    connected = false;
+                }
+            } else if (state == BluetoothInputDevice.STATE_DISCONNECTING) {
+                if (result == BluetoothInputDevice.INPUT_DISCONNECT_FAILED_NOT_CONNECTED) {
+                    connected = false;
+                } else {
+                    // There is no better way to handle this, this shouldn't happen
+                    connected = true;
+                }
+            } else {
+                Log.e(TAG, "Error onInputDeviceConnectionResult. State is:" + state);
+            }
+            mBluetoothService.handleInputDevicePropertyChange(address, connected);
+        }
+    }
+
+    /**
+     * Called by native code for the async response to a Connect
+     * method call to org.bluez.Network.
+     *
+     * @param path the path of the specified PAN device
+     * @param result Result code of the operation.
+     */
+    private void onPanDeviceConnectionResult(String path, int result) {
+        log ("onPanDeviceConnectionResult " + path + " " + result);
+        // Success case gets handled by Property Change signal
+        if (result != BluetoothPan.PAN_OPERATION_SUCCESS) {
+            String address = mBluetoothService.getAddressFromObjectPath(path);
+            if (address == null) return;
+
+            boolean connected = false;
+            BluetoothDevice device = mAdapter.getRemoteDevice(address);
+            int state = mBluetoothService.getPanDeviceConnectionState(device);
+            if (state == BluetoothPan.STATE_CONNECTING) {
+                if (result == BluetoothPan.PAN_CONNECT_FAILED_ALREADY_CONNECTED) {
+                    connected = true;
+                } else {
+                    connected = false;
+                }
+            } else if (state == BluetoothPan.STATE_DISCONNECTING) {
+                if (result == BluetoothPan.PAN_DISCONNECT_FAILED_NOT_CONNECTED) {
+                    connected = false;
+                } else {
+                    // There is no better way to handle this, this shouldn't happen
+                    connected = true;
+                }
+            } else {
+                Log.e(TAG, "Error onPanDeviceConnectionResult. State is: "
+                        + state + " result: "+ result);
+            }
+            int newState = connected? BluetoothPan.STATE_CONNECTED :
+                BluetoothPan.STATE_DISCONNECTED;
+            mBluetoothService.handlePanDeviceStateChange(device, newState,
+                                                  BluetoothPan.LOCAL_PANU_ROLE);
+        }
+    }
+
+    /**
+     * Called by native code for the async response to a Connect
+     * method call to org.bluez.Health
+     *
+     * @param chanCode The internal id of the channel
+     * @param result Result code of the operation.
+     */
+    private void onHealthDeviceConnectionResult(int chanCode, int result) {
+        log ("onHealthDeviceConnectionResult " + chanCode + " " + result);
+        // Success case gets handled by Property Change signal
+        if (result != BluetoothHealth.HEALTH_OPERATION_SUCCESS) {
+            mBluetoothService.onHealthDeviceChannelConnectionError(chanCode,
+                                                 BluetoothHealth.STATE_CHANNEL_DISCONNECTED);
+        }
+    }
+
+    /**
+     * Called by native code on a DeviceDisconnected signal from
+     * org.bluez.NetworkServer.
+     *
+     * @param address the MAC address of the disconnected device
+     */
+    private void onNetworkDeviceDisconnected(String address) {
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        mBluetoothService.handlePanDeviceStateChange(device, BluetoothPan.STATE_DISCONNECTED,
+                                                      BluetoothPan.LOCAL_NAP_ROLE);
+    }
+
+    /**
+     * Called by native code on a DeviceConnected signal from
+     * org.bluez.NetworkServer.
+     *
+     * @param address the MAC address of the connected device
+     * @param iface interface of remote network
+     * @param destUuid unused UUID parameter
+     */
+    private void onNetworkDeviceConnected(String address, String iface, int destUuid) {
+        BluetoothDevice device = mAdapter.getRemoteDevice(address);
+        mBluetoothService.handlePanDeviceStateChange(device, iface, BluetoothPan.STATE_CONNECTED,
+                                                      BluetoothPan.LOCAL_NAP_ROLE);
+    }
+
+    /**
+     * Called by native code on a PropertyChanged signal from
+     * org.bluez.HealthDevice.
+     *
+     * @param devicePath the object path of the remote device
+     * @param propValues Properties (Name-Value) of the Health Device.
+     */
+    private void onHealthDevicePropertyChanged(String devicePath, String[] propValues) {
+        log("Health Device : Name of Property is: " + propValues[0] + " Value:" + propValues[1]);
+        mBluetoothService.onHealthDevicePropertyChanged(devicePath, propValues[1]);
+    }
+
+    /**
+     * Called by native code on a ChannelCreated/Deleted signal from
+     * org.bluez.HealthDevice.
+     *
+     * @param devicePath the object path of the remote device
+     * @param channelPath the path of the health channel.
+     * @param exists Boolean to indicate if the channel was created or deleted.
+     */
+    private void onHealthDeviceChannelChanged(String devicePath, String channelPath,
+            boolean exists) {
+        log("Health Device : devicePath: " + devicePath + ":channelPath:" + channelPath +
+                ":exists" + exists);
+        mBluetoothService.onHealthDeviceChannelChanged(devicePath, channelPath, exists);
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+
+    private native void initializeNativeDataNative();
+    private native void startEventLoopNative();
+    private native void stopEventLoopNative();
+    private native boolean isEventLoopRunningNative();
+    private native void cleanupNativeDataNative();
+}
diff --git a/core/java/android/server/BluetoothHealthProfileHandler.java b/core/java/android/server/BluetoothHealthProfileHandler.java
new file mode 100644
index 0000000..5e93b81
--- /dev/null
+++ b/core/java/android/server/BluetoothHealthProfileHandler.java
@@ -0,0 +1,671 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHealth;
+import android.bluetooth.BluetoothHealthAppConfiguration;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.IBluetoothHealthCallback;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ParcelFileDescriptor;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * This handles all the operations on the Bluetooth Health profile.
+ * All functions are called by BluetoothService, as Bluetooth Service
+ * is the Service handler for the HDP profile.
+ *
+ * @hide
+ */
+final class BluetoothHealthProfileHandler {
+    private static final String TAG = "BluetoothHealthProfileHandler";
+    private static final boolean DBG = false;
+
+    private static BluetoothHealthProfileHandler sInstance;
+    private BluetoothService mBluetoothService;
+    private ArrayList<HealthChannel> mHealthChannels;
+    private HashMap <BluetoothHealthAppConfiguration, String> mHealthAppConfigs;
+    private HashMap <BluetoothDevice, Integer> mHealthDevices;
+    private HashMap <BluetoothHealthAppConfiguration, IBluetoothHealthCallback> mCallbacks;
+
+    private static final int MESSAGE_REGISTER_APPLICATION = 0;
+    private static final int MESSAGE_UNREGISTER_APPLICATION = 1;
+    private static final int MESSAGE_CONNECT_CHANNEL = 2;
+    private static final AtomicInteger sChannelId = new AtomicInteger();
+
+    class HealthChannel {
+        private ParcelFileDescriptor mChannelFd;
+        private boolean mMainChannel;
+        private String mChannelPath;
+        private BluetoothDevice mDevice;
+        private BluetoothHealthAppConfiguration mConfig;
+        private int mState;
+        private int mChannelType;
+        private int mId;
+
+        HealthChannel(BluetoothDevice device, BluetoothHealthAppConfiguration config,
+                ParcelFileDescriptor fd, boolean mainChannel, String channelPath) {
+             mChannelFd = fd;
+             mMainChannel = mainChannel;
+             mChannelPath = channelPath;
+             mDevice = device;
+             mConfig = config;
+             mState = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+             mId = getChannelId();
+        }
+    }
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case MESSAGE_REGISTER_APPLICATION:
+                BluetoothHealthAppConfiguration registerApp =
+                    (BluetoothHealthAppConfiguration) msg.obj;
+                int role = registerApp.getRole();
+                String path = null;
+
+                if (role == BluetoothHealth.SINK_ROLE) {
+                    path = mBluetoothService.registerHealthApplicationNative(
+                            registerApp.getDataType(), getStringRole(role), registerApp.getName());
+                } else {
+                    path = mBluetoothService.registerHealthApplicationNative(
+                            registerApp.getDataType(), getStringRole(role), registerApp.getName(),
+                            getStringChannelType(registerApp.getChannelType()));
+                }
+
+                if (path == null) {
+                    callHealthApplicationStatusCallback(registerApp,
+                            BluetoothHealth.APP_CONFIG_REGISTRATION_FAILURE);
+                    mCallbacks.remove(registerApp);
+                } else {
+                    mHealthAppConfigs.put(registerApp, path);
+                    callHealthApplicationStatusCallback(registerApp,
+                            BluetoothHealth.APP_CONFIG_REGISTRATION_SUCCESS);
+                }
+
+                break;
+            case MESSAGE_UNREGISTER_APPLICATION:
+                BluetoothHealthAppConfiguration unregisterApp =
+                    (BluetoothHealthAppConfiguration) msg.obj;
+
+                // Disconnect all the channels
+                for (HealthChannel chan : mHealthChannels) {
+                    if (chan.mConfig.equals(unregisterApp) &&
+                            chan.mState != BluetoothHealth.STATE_CHANNEL_DISCONNECTED) {
+                        disconnectChannel(chan.mDevice, unregisterApp, chan.mId);
+                    }
+                }
+
+                boolean result = mBluetoothService.unregisterHealthApplicationNative(
+                        mHealthAppConfigs.get(unregisterApp));
+                if (result) {
+                    callHealthApplicationStatusCallback(unregisterApp,
+                            BluetoothHealth.APP_CONFIG_UNREGISTRATION_SUCCESS);
+                    mCallbacks.remove(unregisterApp);
+                    mHealthAppConfigs.remove(unregisterApp);
+                } else {
+                    callHealthApplicationStatusCallback(unregisterApp,
+                            BluetoothHealth.APP_CONFIG_UNREGISTRATION_FAILURE);
+                }
+                break;
+            case MESSAGE_CONNECT_CHANNEL:
+                HealthChannel chan = (HealthChannel)msg.obj;
+                String deviceObjectPath =
+                    mBluetoothService.getObjectPathFromAddress(chan.mDevice.getAddress());
+                String configPath = mHealthAppConfigs.get(chan.mConfig);
+                String channelType = getStringChannelType(chan.mChannelType);
+
+                if (!mBluetoothService.createChannelNative(deviceObjectPath, configPath,
+                          channelType, chan.mId)) {
+                    int prevState = chan.mState;
+                    int state = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+                    callHealthChannelCallback(chan.mConfig, chan.mDevice, prevState, state, null,
+                            chan.mId);
+                    mHealthChannels.remove(chan);
+                }
+            }
+        }
+    };
+
+    private BluetoothHealthProfileHandler(Context context, BluetoothService service) {
+        mBluetoothService = service;
+        mHealthAppConfigs = new HashMap<BluetoothHealthAppConfiguration, String>();
+        mHealthChannels = new ArrayList<HealthChannel>();
+        mHealthDevices = new HashMap<BluetoothDevice, Integer>();
+        mCallbacks = new HashMap<BluetoothHealthAppConfiguration, IBluetoothHealthCallback>();
+    }
+
+    static synchronized BluetoothHealthProfileHandler getInstance(Context context,
+            BluetoothService service) {
+        if (sInstance == null) sInstance = new BluetoothHealthProfileHandler(context, service);
+        return sInstance;
+    }
+
+    boolean registerAppConfiguration(BluetoothHealthAppConfiguration config,
+                                     IBluetoothHealthCallback callback) {
+        Message msg = mHandler.obtainMessage(MESSAGE_REGISTER_APPLICATION);
+        msg.obj = config;
+        mHandler.sendMessage(msg);
+        mCallbacks.put(config, callback);
+        return true;
+    }
+
+    boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration config) {
+        String path = mHealthAppConfigs.get(config);
+        if (path == null) return false;
+
+        Message msg = mHandler.obtainMessage(MESSAGE_UNREGISTER_APPLICATION);
+        msg.obj = config;
+        mHandler.sendMessage(msg);
+        return true;
+    }
+
+    boolean connectChannelToSource(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        return connectChannel(device, config, BluetoothHealth.CHANNEL_TYPE_ANY);
+    }
+
+    private HealthChannel getMainChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        for (HealthChannel chan: mHealthChannels) {
+            if (chan.mDevice.equals(device) && chan.mConfig.equals(config)) {
+                if (chan.mMainChannel) return chan;
+            }
+        }
+        return null;
+    }
+
+    boolean connectChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int channelType) {
+        String deviceObjectPath =
+            mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (deviceObjectPath == null) return false;
+
+        String configPath = mHealthAppConfigs.get(config);
+        if (configPath == null) return false;
+
+        HealthChannel chan = new HealthChannel(device, config, null, false, null);
+        chan.mState = BluetoothHealth.STATE_CHANNEL_CONNECTING;
+        chan.mChannelType = channelType;
+        mHealthChannels.add(chan);
+
+        int prevState = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+        int state = BluetoothHealth.STATE_CHANNEL_CONNECTING;
+        callHealthChannelCallback(config, device, prevState, state, null, chan.mId);
+
+        Message msg = mHandler.obtainMessage(MESSAGE_CONNECT_CHANNEL);
+        msg.obj = chan;
+        mHandler.sendMessage(msg);
+
+        return true;
+    }
+
+    private String getStringChannelType(int type) {
+        if (type == BluetoothHealth.CHANNEL_TYPE_RELIABLE) {
+            return "Reliable";
+        } else if (type == BluetoothHealth.CHANNEL_TYPE_STREAMING) {
+            return "Streaming";
+        } else {
+            return "Any";
+        }
+    }
+
+    private String getStringRole(int role) {
+        if (role == BluetoothHealth.SINK_ROLE) {
+            return "Sink";
+        } else if (role == BluetoothHealth.SOURCE_ROLE) {
+            return "Streaming";
+        } else {
+            return null;
+        }
+    }
+
+    private int getChannelId() {
+        // The function doesn't need to be synchronized, as the health profile handler
+        // will only allow one health channel object creation at a time.
+        // In the worst case the while loop will have to break out at some point of
+        // time, because only a limited number of L2CAP channels are possible.
+        int id;
+        boolean found;
+        do {
+            id = sChannelId.incrementAndGet();
+            found = false;
+            for (HealthChannel chan: mHealthChannels) {
+                if (chan.mId == id) found = true;
+            }
+        } while (found);
+        return id;
+    }
+
+    boolean disconnectChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int id) {
+        HealthChannel chan = findChannelById(id);
+        if (chan == null) {
+          return false;
+        }
+
+        String deviceObjectPath =
+                mBluetoothService.getObjectPathFromAddress(device.getAddress());
+
+        mBluetoothService.releaseChannelFdNative(chan.mChannelPath);
+
+        int prevState = chan.mState;
+        chan.mState = BluetoothHealth.STATE_CHANNEL_DISCONNECTING;
+        callHealthChannelCallback(config, device, prevState, chan.mState,
+                null, chan.mId);
+
+        if (!mBluetoothService.destroyChannelNative(deviceObjectPath, chan.mChannelPath,
+                                                    chan.mId)) {
+            prevState = chan.mState;
+            chan.mState = BluetoothHealth.STATE_CHANNEL_CONNECTED;
+            callHealthChannelCallback(config, device, prevState, chan.mState,
+                    chan.mChannelFd, chan.mId);
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    private HealthChannel findChannelById(int id) {
+        for (HealthChannel chan : mHealthChannels) {
+            if (chan.mId == id) return chan;
+        }
+        return null;
+    }
+
+    private HealthChannel findChannelByPath(BluetoothDevice device, String path) {
+        for (HealthChannel chan : mHealthChannels) {
+            if (path.equals(chan.mChannelPath) && device.equals(chan.mDevice)) return chan;
+        }
+        return null;
+    }
+
+    private List<HealthChannel> findChannelByStates(BluetoothDevice device, int[] states) {
+        List<HealthChannel> channels = new ArrayList<HealthChannel>();
+        for (HealthChannel chan: mHealthChannels) {
+            if (chan.mDevice.equals(device)) {
+                for (int state : states) {
+                    if (chan.mState == state) {
+                        channels.add(chan);
+                    }
+                }
+            }
+        }
+        return channels;
+    }
+
+    private HealthChannel findConnectingChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        for (HealthChannel chan : mHealthChannels) {
+            if (chan.mDevice.equals(device) && chan.mConfig.equals(config) &&
+                chan.mState == BluetoothHealth.STATE_CHANNEL_CONNECTING) return chan;
+        }
+        return null;
+    }
+
+    ParcelFileDescriptor getMainChannelFd(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        HealthChannel chan = getMainChannel(device, config);
+        if (chan != null) {
+            ParcelFileDescriptor pfd =  null;
+            try {
+                pfd = chan.mChannelFd.dup();
+                return pfd;
+            } catch (IOException e) {
+                return null;
+            }
+        }
+
+        String objectPath =
+                mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (objectPath == null) return null;
+
+        String mainChannelPath = mBluetoothService.getMainChannelNative(objectPath);
+        if (mainChannelPath == null) return null;
+
+        // We had no record of the main channel but querying Bluez we got a
+        // main channel. We might not have received the PropertyChanged yet for
+        // the main channel creation so update our data structure here.
+        chan = findChannelByPath(device, mainChannelPath);
+        if (chan == null) {
+            errorLog("Main Channel present but we don't have any account of it:" +
+                    device +":" + config);
+            return null;
+        }
+        chan.mMainChannel = true;
+        try {
+            return chan.mChannelFd.dup();
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /*package*/ void onHealthDevicePropertyChanged(String devicePath,
+            String channelPath) {
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        String address = mBluetoothService.getAddressFromObjectPath(devicePath);
+        if (address == null) return;
+
+        //TODO: Fix this in Bluez
+        if (channelPath.equals("/")) {
+            // This means that the main channel is being destroyed.
+            return;
+        }
+
+        BluetoothDevice device = adapter.getRemoteDevice(address);
+        BluetoothHealthAppConfiguration config = findHealthApplication(device,
+                channelPath);
+        if (config != null) {
+            HealthChannel chan = findChannelByPath(device, channelPath);
+            if (chan == null) {
+                errorLog("Health Channel is not present:" + channelPath);
+            } else {
+                chan.mMainChannel = true;
+            }
+        }
+    }
+
+    /*package*/ void onHealthDeviceChannelConnectionError(int chanCode,
+                                                          int state) {
+        HealthChannel channel = findChannelById(chanCode);
+        if (channel == null) errorLog("No record of this channel:" + chanCode);
+
+        callHealthChannelCallback(channel.mConfig, channel.mDevice, channel.mState, state, null,
+                chanCode);
+    }
+
+    private BluetoothHealthAppConfiguration findHealthApplication(
+            BluetoothDevice device, String channelPath) {
+        BluetoothHealthAppConfiguration config = null;
+        HealthChannel chan = findChannelByPath(device, channelPath);
+
+        if (chan != null) {
+            config = chan.mConfig;
+        } else {
+            String configPath = mBluetoothService.getChannelApplicationNative(channelPath);
+            if (configPath == null) {
+                errorLog("Config path is null for application");
+            } else {
+                for (Entry<BluetoothHealthAppConfiguration, String> e :
+                        mHealthAppConfigs.entrySet()) {
+                    if (e.getValue().equals(configPath)) {
+                        config = e.getKey();
+                    }
+                }
+                if (config == null) errorLog("No associated application for path:" + configPath);
+            }
+        }
+        return config;
+    }
+
+    /*package*/ void onHealthDeviceChannelChanged(String devicePath,
+            String channelPath, boolean exists) {
+        debugLog("onHealthDeviceChannelChanged: devicePath: " + devicePath +
+                "ChannelPath: " + channelPath + "Exists: " + exists);
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        String address = mBluetoothService.getAddressFromObjectPath(devicePath);
+        if (address == null) return;
+
+        BluetoothDevice device = adapter.getRemoteDevice(address);
+        BluetoothHealthAppConfiguration config;
+        int state, prevState = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+        ParcelFileDescriptor fd;
+        HealthChannel channel;
+        config = findHealthApplication(device, channelPath);
+
+        if (exists) {
+            channel = findConnectingChannel(device, config);
+            if (channel == null) {
+               channel = new HealthChannel(device, config, null, false,
+                       channelPath);
+               channel.mState = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+               mHealthChannels.add(channel);
+            }
+            channel.mChannelPath = channelPath;
+
+            fd = mBluetoothService.getChannelFdNative(channelPath);
+            if (fd == null) {
+                errorLog("Error obtaining fd for channel:" + channelPath);
+                disconnectChannel(device, config, channel.mId);
+                return;
+            }
+            boolean mainChannel =
+                    getMainChannel(device, config) == null ? false : true;
+            if (!mainChannel) {
+                String mainChannelPath =
+                        mBluetoothService.getMainChannelNative(devicePath);
+                if (mainChannelPath == null) {
+                    errorLog("Main Channel Path is null for devicePath:" + devicePath);
+                    return;
+                }
+                if (mainChannelPath.equals(channelPath)) mainChannel = true;
+            }
+
+            channel.mChannelFd = fd;
+            channel.mMainChannel = mainChannel;
+            prevState = channel.mState;
+            state = BluetoothHealth.STATE_CHANNEL_CONNECTED;
+        } else {
+            channel = findChannelByPath(device, channelPath);
+            if (channel == null) {
+                errorLog("Channel not found:" + config + ":" + channelPath);
+                return;
+            }
+            mHealthChannels.remove(channel);
+
+            channel.mChannelFd = null;
+            prevState = channel.mState;
+            state = BluetoothHealth.STATE_CHANNEL_DISCONNECTED;
+        }
+        channel.mState = state;
+        callHealthChannelCallback(config, device, prevState, state, channel.mChannelFd,
+                channel.mId);
+    }
+
+    private void callHealthChannelCallback(BluetoothHealthAppConfiguration config,
+            BluetoothDevice device, int prevState, int state, ParcelFileDescriptor fd, int id) {
+        broadcastHealthDeviceStateChange(device, prevState, state);
+
+        debugLog("Health Device Callback: " + device + " State Change: "
+                + prevState + "->" + state);
+
+        ParcelFileDescriptor dupedFd = null;
+        if (fd != null) {
+            try {
+                dupedFd = fd.dup();
+            } catch (IOException e) {
+                dupedFd = null;
+                errorLog("Exception while duping: " + e);
+            }
+        }
+
+        IBluetoothHealthCallback callback = mCallbacks.get(config);
+        if (callback != null) {
+            try {
+                callback.onHealthChannelStateChange(config, device, prevState, state, dupedFd, id);
+            } catch (RemoteException e) {
+                errorLog("Remote Exception:" + e);
+            }
+        }
+    }
+
+    private void callHealthApplicationStatusCallback(
+            BluetoothHealthAppConfiguration config, int status) {
+        debugLog("Health Device Application: " + config + " State Change: status:"
+                + status);
+        IBluetoothHealthCallback callback = mCallbacks.get(config);
+        if (callback != null) {
+            try {
+                callback.onHealthAppConfigurationStatusChange(config, status);
+            } catch (RemoteException e) {
+                errorLog("Remote Exception:" + e);
+            }
+        }
+    }
+
+    int getHealthDeviceConnectionState(BluetoothDevice device) {
+        if (mHealthDevices.get(device) == null) {
+            return BluetoothHealth.STATE_DISCONNECTED;
+        }
+        return mHealthDevices.get(device);
+    }
+
+    List<BluetoothDevice> getConnectedHealthDevices() {
+        List<BluetoothDevice> devices = lookupHealthDevicesMatchingStates(
+                    new int[] {BluetoothHealth.STATE_CONNECTED});
+        return devices;
+    }
+
+    List<BluetoothDevice> getHealthDevicesMatchingConnectionStates(int[] states) {
+        List<BluetoothDevice> devices = lookupHealthDevicesMatchingStates(states);
+        return devices;
+    }
+
+    List<BluetoothDevice> lookupHealthDevicesMatchingStates(int[] states) {
+        List<BluetoothDevice> healthDevices = new ArrayList<BluetoothDevice>();
+
+        for (BluetoothDevice device: mHealthDevices.keySet()) {
+            int healthDeviceState = getHealthDeviceConnectionState(device);
+            for (int state : states) {
+                if (state == healthDeviceState) {
+                    healthDevices.add(device);
+                    break;
+                }
+            }
+        }
+        return healthDevices;
+    }
+
+    /**
+     * This function sends the intent for the updates on the connection status to the remote device.
+     * Note that multiple channels can be connected to the remote device by multiple applications.
+     * This sends an intent for the update to the device connection status and not the channel
+     * connection status. Only the following state transitions are possible:
+     *
+     * {@link BluetoothHealth#STATE_DISCONNECTED} to {@link BluetoothHealth#STATE_CONNECTING}
+     * {@link BluetoothHealth#STATE_CONNECTING} to {@link BluetoothHealth#STATE_CONNECTED}
+     * {@link BluetoothHealth#STATE_CONNECTED} to {@link BluetoothHealth#STATE_DISCONNECTING}
+     * {@link BluetoothHealth#STATE_DISCONNECTING} to {@link BluetoothHealth#STATE_DISCONNECTED}
+     * {@link BluetoothHealth#STATE_DISCONNECTED} to {@link BluetoothHealth#STATE_CONNECTED}
+     * {@link BluetoothHealth#STATE_CONNECTED} to {@link BluetoothHealth#STATE_DISCONNECTED}
+     * {@link BluetoothHealth#STATE_CONNECTING} to {{@link BluetoothHealth#STATE_DISCONNECTED}
+     *
+     * @param device
+     * @param prevChannelState
+     * @param newChannelState
+     * @hide
+     */
+    private void broadcastHealthDeviceStateChange(BluetoothDevice device, int prevChannelState,
+            int newChannelState) {
+        if (mHealthDevices.get(device) == null) {
+            mHealthDevices.put(device, BluetoothHealth.STATE_DISCONNECTED);
+        }
+
+        int currDeviceState = mHealthDevices.get(device);
+        int newDeviceState = convertState(newChannelState);
+
+        if (currDeviceState != newDeviceState) {
+            List<HealthChannel> chan;
+            switch (currDeviceState) {
+                case BluetoothHealth.STATE_DISCONNECTED:
+                    updateAndSendIntent(device, currDeviceState, newDeviceState);
+                    break;
+                case BluetoothHealth.STATE_CONNECTING:
+                    // Channel got connected.
+                    if (newDeviceState == BluetoothHealth.STATE_CONNECTED) {
+                        updateAndSendIntent(device, currDeviceState, newDeviceState);
+                    } else {
+                        // Channel got disconnected
+                        chan = findChannelByStates(device, new int [] {
+                                    BluetoothHealth.STATE_CHANNEL_CONNECTING,
+                                    BluetoothHealth.STATE_CHANNEL_DISCONNECTING});
+                        if (chan.isEmpty()) {
+                            updateAndSendIntent(device, currDeviceState, newDeviceState);
+                        }
+                    }
+                    break;
+                case BluetoothHealth.STATE_CONNECTED:
+                    // Channel got disconnected or is in disconnecting state.
+                    chan = findChannelByStates(device, new int [] {
+                                BluetoothHealth.STATE_CHANNEL_CONNECTING,
+                                BluetoothHealth.STATE_CHANNEL_CONNECTED});
+                    if (chan.isEmpty()) {
+                        updateAndSendIntent(device, currDeviceState, newDeviceState);
+                    }
+                    break;
+                case BluetoothHealth.STATE_DISCONNECTING:
+                    // Channel got disconnected.
+                    chan = findChannelByStates(device, new int [] {
+                                BluetoothHealth.STATE_CHANNEL_CONNECTING,
+                                BluetoothHealth.STATE_CHANNEL_DISCONNECTING});
+                    if (chan.isEmpty()) {
+                        updateAndSendIntent(device, currDeviceState, newDeviceState);
+                    }
+                    break;
+            }
+        }
+    }
+
+    private void updateAndSendIntent(BluetoothDevice device, int prevDeviceState,
+            int newDeviceState) {
+        mHealthDevices.put(device, newDeviceState);
+        mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.HEALTH,
+                                                    newDeviceState, prevDeviceState);
+    }
+
+    /**
+     * This function converts the channel connection state to device connection state.
+     *
+     * @param state
+     * @return
+     */
+    private int convertState(int state) {
+        switch (state) {
+            case BluetoothHealth.STATE_CHANNEL_CONNECTED:
+                return BluetoothHealth.STATE_CONNECTED;
+            case BluetoothHealth.STATE_CHANNEL_CONNECTING:
+                return BluetoothHealth.STATE_CONNECTING;
+            case BluetoothHealth.STATE_CHANNEL_DISCONNECTING:
+                return BluetoothHealth.STATE_DISCONNECTING;
+            case BluetoothHealth.STATE_CHANNEL_DISCONNECTED:
+                return BluetoothHealth.STATE_DISCONNECTED;
+        }
+        errorLog("Mismatch in Channel and Health Device State");
+        return -1;
+    }
+
+    private static void debugLog(String msg) {
+        if (DBG) Log.d(TAG, msg);
+    }
+
+    private static void errorLog(String msg) {
+        Log.e(TAG, msg);
+    }
+}
diff --git a/core/java/android/server/BluetoothInputProfileHandler.java b/core/java/android/server/BluetoothInputProfileHandler.java
new file mode 100644
index 0000000..f80d593
--- /dev/null
+++ b/core/java/android/server/BluetoothInputProfileHandler.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothDeviceProfileState;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothProfileState;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Message;
+import android.provider.Settings;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * This handles all the operations on the HID profile.
+ * All functions are called by BluetoothService, as Bluetooth Service
+ * is the Service handler for the HID profile.
+ */
+final class BluetoothInputProfileHandler {
+    private static final String TAG = "BluetoothInputProfileHandler";
+    private static final boolean DBG = true;
+
+    public static BluetoothInputProfileHandler sInstance;
+    private Context mContext;
+    private BluetoothService mBluetoothService;
+    private final HashMap<BluetoothDevice, Integer> mInputDevices;
+    private final BluetoothProfileState mHidProfileState;
+
+    private BluetoothInputProfileHandler(Context context, BluetoothService service) {
+        mContext = context;
+        mBluetoothService = service;
+        mInputDevices = new HashMap<BluetoothDevice, Integer>();
+        mHidProfileState = new BluetoothProfileState(mContext, BluetoothProfileState.HID);
+        mHidProfileState.start();
+    }
+
+    static synchronized BluetoothInputProfileHandler getInstance(Context context,
+            BluetoothService service) {
+        if (sInstance == null) sInstance = new BluetoothInputProfileHandler(context, service);
+        return sInstance;
+    }
+
+    boolean connectInputDevice(BluetoothDevice device,
+                                            BluetoothDeviceProfileState state) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (objectPath == null ||
+            getInputDeviceConnectionState(device) != BluetoothInputDevice.STATE_DISCONNECTED ||
+            getInputDevicePriority(device) == BluetoothInputDevice.PRIORITY_OFF) {
+            return false;
+        }
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.CONNECT_HID_OUTGOING;
+            msg.obj = state;
+            mHidProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    boolean connectInputDeviceInternal(BluetoothDevice device) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        handleInputDeviceStateChange(device, BluetoothInputDevice.STATE_CONNECTING);
+        if (!mBluetoothService.connectInputDeviceNative(objectPath)) {
+            handleInputDeviceStateChange(device, BluetoothInputDevice.STATE_DISCONNECTED);
+            return false;
+        }
+        return true;
+    }
+
+    boolean disconnectInputDevice(BluetoothDevice device,
+                                               BluetoothDeviceProfileState state) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (objectPath == null ||
+                getInputDeviceConnectionState(device) == BluetoothInputDevice.STATE_DISCONNECTED) {
+            return false;
+        }
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.DISCONNECT_HID_OUTGOING;
+            msg.obj = state;
+            mHidProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    boolean disconnectInputDeviceInternal(BluetoothDevice device) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        handleInputDeviceStateChange(device, BluetoothInputDevice.STATE_DISCONNECTING);
+        if (!mBluetoothService.disconnectInputDeviceNative(objectPath)) {
+            handleInputDeviceStateChange(device, BluetoothInputDevice.STATE_CONNECTED);
+            return false;
+        }
+        return true;
+    }
+
+    int getInputDeviceConnectionState(BluetoothDevice device) {
+        if (mInputDevices.get(device) == null) {
+            return BluetoothInputDevice.STATE_DISCONNECTED;
+        }
+        return mInputDevices.get(device);
+    }
+
+    List<BluetoothDevice> getConnectedInputDevices() {
+        List<BluetoothDevice> devices = lookupInputDevicesMatchingStates(
+            new int[] {BluetoothInputDevice.STATE_CONNECTED});
+        return devices;
+    }
+
+    List<BluetoothDevice> getInputDevicesMatchingConnectionStates(int[] states) {
+        List<BluetoothDevice> devices = lookupInputDevicesMatchingStates(states);
+        return devices;
+    }
+
+    int getInputDevicePriority(BluetoothDevice device) {
+        return Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.getBluetoothInputDevicePriorityKey(device.getAddress()),
+                BluetoothInputDevice.PRIORITY_UNDEFINED);
+    }
+
+    boolean setInputDevicePriority(BluetoothDevice device, int priority) {
+        if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {
+            return false;
+        }
+        return Settings.Global.putInt(mContext.getContentResolver(),
+                Settings.Global.getBluetoothInputDevicePriorityKey(device.getAddress()),
+                priority);
+    }
+
+    List<BluetoothDevice> lookupInputDevicesMatchingStates(int[] states) {
+        List<BluetoothDevice> inputDevices = new ArrayList<BluetoothDevice>();
+
+        for (BluetoothDevice device: mInputDevices.keySet()) {
+            int inputDeviceState = getInputDeviceConnectionState(device);
+            for (int state : states) {
+                if (state == inputDeviceState) {
+                    inputDevices.add(device);
+                    break;
+                }
+            }
+        }
+        return inputDevices;
+    }
+
+    private void handleInputDeviceStateChange(BluetoothDevice device, int state) {
+        int prevState;
+        if (mInputDevices.get(device) == null) {
+            prevState = BluetoothInputDevice.STATE_DISCONNECTED;
+        } else {
+            prevState = mInputDevices.get(device);
+        }
+        if (prevState == state) return;
+
+        mInputDevices.put(device, state);
+
+        if (getInputDevicePriority(device) >
+              BluetoothInputDevice.PRIORITY_OFF &&
+            state == BluetoothInputDevice.STATE_CONNECTING ||
+            state == BluetoothInputDevice.STATE_CONNECTED) {
+            // We have connected or attempting to connect.
+            // Bump priority
+            setInputDevicePriority(device, BluetoothInputDevice.PRIORITY_AUTO_CONNECT);
+        }
+
+        Intent intent = new Intent(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        intent.putExtra(BluetoothInputDevice.EXTRA_PREVIOUS_STATE, prevState);
+        intent.putExtra(BluetoothInputDevice.EXTRA_STATE, state);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
+
+        debugLog("InputDevice state : device: " + device + " State:" + prevState + "->" + state);
+        mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.INPUT_DEVICE, state,
+                                                    prevState);
+    }
+
+    void handleInputDevicePropertyChange(String address, boolean connected) {
+        int state = connected ? BluetoothInputDevice.STATE_CONNECTED :
+            BluetoothInputDevice.STATE_DISCONNECTED;
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        BluetoothDevice device = adapter.getRemoteDevice(address);
+        handleInputDeviceStateChange(device, state);
+    }
+
+    void setInitialInputDevicePriority(BluetoothDevice device, int state) {
+        switch (state) {
+            case BluetoothDevice.BOND_BONDED:
+                if (getInputDevicePriority(device) == BluetoothInputDevice.PRIORITY_UNDEFINED) {
+                    setInputDevicePriority(device, BluetoothInputDevice.PRIORITY_ON);
+                }
+                break;
+            case BluetoothDevice.BOND_NONE:
+                setInputDevicePriority(device, BluetoothInputDevice.PRIORITY_UNDEFINED);
+                break;
+        }
+    }
+
+    private static void debugLog(String msg) {
+        if (DBG) Log.d(TAG, msg);
+    }
+
+    private static void errorLog(String msg) {
+        Log.e(TAG, msg);
+    }
+}
diff --git a/core/java/android/server/BluetoothPanProfileHandler.java b/core/java/android/server/BluetoothPanProfileHandler.java
new file mode 100644
index 0000000..41bb87f
--- /dev/null
+++ b/core/java/android/server/BluetoothPanProfileHandler.java
@@ -0,0 +1,409 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothTetheringDataTracker;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources.NotFoundException;
+import android.net.ConnectivityManager;
+import android.net.InterfaceConfiguration;
+import android.net.LinkAddress;
+import android.net.NetworkUtils;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * This handles the PAN profile. All calls into this are made
+ * from Bluetooth Service.
+ */
+final class BluetoothPanProfileHandler {
+    private static final String TAG = "BluetoothPanProfileHandler";
+    private static final boolean DBG = true;
+
+    private ArrayList<String> mBluetoothIfaceAddresses;
+    private int mMaxPanDevices;
+
+    private static final String BLUETOOTH_IFACE_ADDR_START= "192.168.44.1";
+    private static final int BLUETOOTH_MAX_PAN_CONNECTIONS = 5;
+    private static final int BLUETOOTH_PREFIX_LENGTH        = 24;
+    public static BluetoothPanProfileHandler sInstance;
+    private final HashMap<BluetoothDevice, BluetoothPanDevice> mPanDevices;
+    private boolean mTetheringOn;
+    private Context mContext;
+    private BluetoothService mBluetoothService;
+
+    static final String NAP_ROLE = "nap";
+    static final String NAP_BRIDGE = "pan1";
+
+    private BluetoothPanProfileHandler(Context context, BluetoothService service) {
+        mContext = context;
+        mPanDevices = new HashMap<BluetoothDevice, BluetoothPanDevice>();
+        mBluetoothService = service;
+        mTetheringOn = false;
+        mBluetoothIfaceAddresses = new ArrayList<String>();
+        try {
+            mMaxPanDevices = context.getResources().getInteger(
+                            com.android.internal.R.integer.config_max_pan_devices);
+        } catch (NotFoundException e) {
+            mMaxPanDevices = BLUETOOTH_MAX_PAN_CONNECTIONS;
+        }
+    }
+
+    static BluetoothPanProfileHandler getInstance(Context context,
+            BluetoothService service) {
+        if (sInstance == null) sInstance = new BluetoothPanProfileHandler(context, service);
+        return sInstance;
+    }
+
+    boolean isTetheringOn() {
+        return mTetheringOn;
+    }
+
+    boolean allowIncomingTethering() {
+        if (isTetheringOn() && getConnectedPanDevices().size() < mMaxPanDevices)
+            return true;
+        return false;
+    }
+
+    private BroadcastReceiver mTetheringReceiver = null;
+
+    void setBluetoothTethering(boolean value) {
+        if (!value) {
+            disconnectPanServerDevices();
+        }
+
+        if (mBluetoothService.getBluetoothState() != BluetoothAdapter.STATE_ON && value) {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+            mTetheringReceiver = new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    if (intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF)
+                            == BluetoothAdapter.STATE_ON) {
+                        mTetheringOn = true;
+                        mContext.unregisterReceiver(mTetheringReceiver);
+                    }
+                }
+            };
+            mContext.registerReceiver(mTetheringReceiver, filter);
+        } else {
+            mTetheringOn = value;
+        }
+    }
+
+    int getPanDeviceConnectionState(BluetoothDevice device) {
+        BluetoothPanDevice panDevice = mPanDevices.get(device);
+        if (panDevice == null) {
+            return BluetoothPan.STATE_DISCONNECTED;
+        }
+        return panDevice.mState;
+    }
+
+    boolean connectPanDevice(BluetoothDevice device) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        if (DBG) Log.d(TAG, "connect PAN(" + objectPath + ")");
+        if (getPanDeviceConnectionState(device) != BluetoothPan.STATE_DISCONNECTED) {
+            errorLog(device + " already connected to PAN");
+        }
+
+        int connectedCount = 0;
+        for (BluetoothDevice panDevice: mPanDevices.keySet()) {
+            if (getPanDeviceConnectionState(panDevice) == BluetoothPan.STATE_CONNECTED) {
+                connectedCount ++;
+            }
+        }
+        if (connectedCount > 8) {
+            debugLog(device + " could not connect to PAN because 8 other devices are"
+                    + "already connected");
+            return false;
+        }
+
+        // Send interface as null as it is not known
+        handlePanDeviceStateChange(device, null, BluetoothPan.STATE_CONNECTING,
+                                           BluetoothPan.LOCAL_PANU_ROLE);
+        if (mBluetoothService.connectPanDeviceNative(objectPath, "nap")) {
+            debugLog("connecting to PAN");
+            return true;
+        } else {
+            handlePanDeviceStateChange(device, null, BluetoothPan.STATE_DISCONNECTED,
+                                                BluetoothPan.LOCAL_PANU_ROLE);
+            errorLog("could not connect to PAN");
+            return false;
+        }
+    }
+
+    private boolean disconnectPanServerDevices() {
+        debugLog("disconnect all PAN devices");
+
+        for (BluetoothDevice device: mPanDevices.keySet()) {
+            BluetoothPanDevice panDevice = mPanDevices.get(device);
+            int state = panDevice.mState;
+            if (state == BluetoothPan.STATE_CONNECTED &&
+                    panDevice.mLocalRole == BluetoothPan.LOCAL_NAP_ROLE) {
+                String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+
+                handlePanDeviceStateChange(device, panDevice.mIface,
+                        BluetoothPan.STATE_DISCONNECTING, panDevice.mLocalRole);
+
+                if (!mBluetoothService.disconnectPanServerDeviceNative(objectPath,
+                        device.getAddress(),
+                        panDevice.mIface)) {
+                    errorLog("could not disconnect Pan Server Device "+device.getAddress());
+
+                    // Restore prev state
+                    handlePanDeviceStateChange(device, panDevice.mIface, state,
+                            panDevice.mLocalRole);
+
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    List<BluetoothDevice> getConnectedPanDevices() {
+        List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
+
+        for (BluetoothDevice device: mPanDevices.keySet()) {
+            if (getPanDeviceConnectionState(device) == BluetoothPan.STATE_CONNECTED) {
+                devices.add(device);
+            }
+        }
+        return devices;
+    }
+
+    List<BluetoothDevice> getPanDevicesMatchingConnectionStates(int[] states) {
+        List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
+
+        for (BluetoothDevice device: mPanDevices.keySet()) {
+            int panDeviceState = getPanDeviceConnectionState(device);
+            for (int state : states) {
+                if (state == panDeviceState) {
+                    devices.add(device);
+                    break;
+                }
+            }
+        }
+        return devices;
+    }
+
+    boolean disconnectPanDevice(BluetoothDevice device) {
+        String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
+        debugLog("disconnect PAN(" + objectPath + ")");
+
+        int state = getPanDeviceConnectionState(device);
+        if (state != BluetoothPan.STATE_CONNECTED) {
+            debugLog(device + " already disconnected from PAN");
+            return false;
+        }
+
+        BluetoothPanDevice panDevice = mPanDevices.get(device);
+
+        if (panDevice == null) {
+            errorLog("No record for this Pan device:" + device);
+            return false;
+        }
+
+        handlePanDeviceStateChange(device, panDevice.mIface, BluetoothPan.STATE_DISCONNECTING,
+                                    panDevice.mLocalRole);
+        if (panDevice.mLocalRole == BluetoothPan.LOCAL_NAP_ROLE) {
+            if (!mBluetoothService.disconnectPanServerDeviceNative(objectPath, device.getAddress(),
+                    panDevice.mIface)) {
+                // Restore prev state, this shouldn't happen
+                handlePanDeviceStateChange(device, panDevice.mIface, state, panDevice.mLocalRole);
+                return false;
+            }
+        } else {
+            if (!mBluetoothService.disconnectPanDeviceNative(objectPath)) {
+                // Restore prev state, this shouldn't happen
+                handlePanDeviceStateChange(device, panDevice.mIface, state, panDevice.mLocalRole);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    void handlePanDeviceStateChange(BluetoothDevice device,
+                                                 String iface, int state, int role) {
+        int prevState;
+        String ifaceAddr = null;
+        BluetoothPanDevice panDevice = mPanDevices.get(device);
+
+        if (panDevice == null) {
+            prevState = BluetoothPan.STATE_DISCONNECTED;
+        } else {
+            prevState = panDevice.mState;
+            ifaceAddr = panDevice.mIfaceAddr;
+        }
+        if (prevState == state) return;
+
+        if (role == BluetoothPan.LOCAL_NAP_ROLE) {
+            if (state == BluetoothPan.STATE_CONNECTED) {
+                ifaceAddr = enableTethering(iface);
+                if (ifaceAddr == null) Log.e(TAG, "Error seting up tether interface");
+            } else if (state == BluetoothPan.STATE_DISCONNECTED) {
+                if (ifaceAddr != null) {
+                    mBluetoothIfaceAddresses.remove(ifaceAddr);
+                    ifaceAddr = null;
+                }
+            }
+        } else {
+            // PANU Role = reverse Tether
+            if (state == BluetoothPan.STATE_CONNECTED) {
+                BluetoothTetheringDataTracker.getInstance().startReverseTether(iface, device);
+            } else if (state == BluetoothPan.STATE_DISCONNECTED &&
+                  (prevState == BluetoothPan.STATE_CONNECTED ||
+                  prevState == BluetoothPan.STATE_DISCONNECTING)) {
+                BluetoothTetheringDataTracker.getInstance().stopReverseTether(panDevice.mIface);
+            }
+        }
+
+        if (panDevice == null) {
+            panDevice = new BluetoothPanDevice(state, ifaceAddr, iface, role);
+            mPanDevices.put(device, panDevice);
+        } else {
+            panDevice.mState = state;
+            panDevice.mIfaceAddr = ifaceAddr;
+            panDevice.mLocalRole = role;
+            panDevice.mIface = iface;
+        }
+
+        Intent intent = new Intent(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        intent.putExtra(BluetoothPan.EXTRA_PREVIOUS_STATE, prevState);
+        intent.putExtra(BluetoothPan.EXTRA_STATE, state);
+        intent.putExtra(BluetoothPan.EXTRA_LOCAL_ROLE, role);
+        mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
+
+        debugLog("Pan Device state : device: " + device + " State:" + prevState + "->" + state);
+        mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.PAN, state,
+                                                    prevState);
+    }
+
+    private class BluetoothPanDevice {
+        private int mState;
+        private String mIfaceAddr;
+        private String mIface;
+        private int mLocalRole; // Which local role is this PAN device bound to
+
+        BluetoothPanDevice(int state, String ifaceAddr, String iface, int localRole) {
+            mState = state;
+            mIfaceAddr = ifaceAddr;
+            mIface = iface;
+            mLocalRole = localRole;
+        }
+    }
+
+    private String createNewTetheringAddressLocked() {
+        if (getConnectedPanDevices().size() == mMaxPanDevices) {
+            debugLog ("Max PAN device connections reached");
+            return null;
+        }
+        String address = BLUETOOTH_IFACE_ADDR_START;
+        while (true) {
+            if (mBluetoothIfaceAddresses.contains(address)) {
+                String[] addr = address.split("\\.");
+                Integer newIp = Integer.parseInt(addr[2]) + 1;
+                address = address.replace(addr[2], newIp.toString());
+            } else {
+                break;
+            }
+        }
+        mBluetoothIfaceAddresses.add(address);
+        return address;
+    }
+
+    // configured when we start tethering
+    private String enableTethering(String iface) {
+        debugLog("updateTetherState:" + iface);
+
+        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
+        INetworkManagementService service = INetworkManagementService.Stub.asInterface(b);
+        ConnectivityManager cm =
+            (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+        String[] bluetoothRegexs = cm.getTetherableBluetoothRegexs();
+
+        // bring toggle the interfaces
+        String[] currentIfaces = new String[0];
+        try {
+            currentIfaces = service.listInterfaces();
+        } catch (Exception e) {
+            Log.e(TAG, "Error listing Interfaces :" + e);
+            return null;
+        }
+
+        boolean found = false;
+        for (String currIface: currentIfaces) {
+            if (currIface.equals(iface)) {
+                found = true;
+                break;
+            }
+        }
+
+        if (!found) return null;
+
+        String address = createNewTetheringAddressLocked();
+        if (address == null) return null;
+
+        InterfaceConfiguration ifcg = null;
+        try {
+            ifcg = service.getInterfaceConfig(iface);
+            if (ifcg != null) {
+                final LinkAddress linkAddr = ifcg.getLinkAddress();
+                InetAddress addr = null;
+                if (linkAddr == null || (addr = linkAddr.getAddress()) == null ||
+                        addr.equals(NetworkUtils.numericToInetAddress("0.0.0.0")) ||
+                        addr.equals(NetworkUtils.numericToInetAddress("::0"))) {
+                    addr = NetworkUtils.numericToInetAddress(address);
+                }
+                ifcg.setInterfaceUp();
+                ifcg.clearFlag("running");
+                ifcg.setLinkAddress(new LinkAddress(addr, BLUETOOTH_PREFIX_LENGTH));
+                service.setInterfaceConfig(iface, ifcg);
+                if (cm.tether(iface) != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+                    Log.e(TAG, "Error tethering "+iface);
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Error configuring interface " + iface + ", :" + e);
+            return null;
+        }
+        return address;
+    }
+
+    private static void debugLog(String msg) {
+        if (DBG) Log.d(TAG, msg);
+    }
+
+    private static void errorLog(String msg) {
+        Log.e(TAG, msg);
+    }
+}
diff --git a/core/java/android/server/BluetoothService.java b/core/java/android/server/BluetoothService.java
new file mode 100644
index 0000000..dfc14a0
--- /dev/null
+++ b/core/java/android/server/BluetoothService.java
@@ -0,0 +1,2926 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * TODO: Move this to
+ * java/services/com/android/server/BluetoothService.java
+ * and make the contructor package private again.
+ *
+ * @hide
+ */
+
+package android.server;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothDeviceProfileState;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothHealthAppConfiguration;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothProfileState;
+import android.bluetooth.BluetoothSocket;
+import android.bluetooth.BluetoothUuid;
+import android.bluetooth.IBluetooth;
+import android.bluetooth.IBluetoothCallback;
+import android.bluetooth.IBluetoothHealthCallback;
+import android.bluetooth.IBluetoothStateChangeCallback;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.content.res.Resources;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.ParcelFileDescriptor;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.util.Log;
+import android.util.Pair;
+
+import com.android.internal.app.IBatteryStats;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.io.RandomAccessFile;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class BluetoothService extends IBluetooth.Stub {
+    private static final String TAG = "BluetoothService";
+    private static final boolean DBG = true;
+
+    private int mNativeData;
+    private BluetoothEventLoop mEventLoop;
+    private BluetoothHeadset mHeadsetProxy;
+    private BluetoothInputDevice mInputDevice;
+    private BluetoothPan mPan;
+    private boolean mIsAirplaneSensitive;
+    private boolean mIsAirplaneToggleable;
+    private BluetoothAdapterStateMachine mBluetoothState;
+    private int[] mAdapterSdpHandles;
+    private ParcelUuid[] mAdapterUuids;
+
+    private BluetoothAdapter mAdapter;  // constant after init()
+    private final BluetoothBondState mBondState;  // local cache of bondings
+    private final IBatteryStats mBatteryStats;
+    private final Context mContext;
+    private Map<Integer, IBluetoothStateChangeCallback> mStateChangeTracker =
+        Collections.synchronizedMap(new HashMap<Integer, IBluetoothStateChangeCallback>());
+
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+
+    private static final String DOCK_ADDRESS_PATH = "/sys/class/switch/dock/bt_addr";
+    private static final String DOCK_PIN_PATH = "/sys/class/switch/dock/bt_pin";
+
+    private static final String SHARED_PREFERENCE_DOCK_ADDRESS = "dock_bluetooth_address";
+    private static final String SHARED_PREFERENCES_NAME = "bluetooth_service_settings";
+
+    private static final int MESSAGE_UUID_INTENT = 1;
+    private static final int MESSAGE_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY = 2;
+    private static final int MESSAGE_REMOVE_SERVICE_RECORD = 3;
+
+    private static final int RFCOMM_RECORD_REAPER = 10;
+    private static final int STATE_CHANGE_REAPER = 11;
+
+    // The time (in millisecs) to delay the pairing attempt after the first
+    // auto pairing attempt fails. We use an exponential delay with
+    // INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY as the initial value and
+    // MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY as the max value.
+    private static final long INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY = 3000;
+    private static final long MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY = 12000;
+
+    // The timeout used to sent the UUIDs Intent
+    // This timeout should be greater than the page timeout
+    private static final int UUID_INTENT_DELAY = 6000;
+
+    /** Always retrieve RFCOMM channel for these SDP UUIDs */
+    private static final ParcelUuid[] RFCOMM_UUIDS = {
+            BluetoothUuid.Handsfree,
+            BluetoothUuid.HSP,
+            BluetoothUuid.ObexObjectPush,
+	    BluetoothUuid.MessageNotificationServer };
+
+    private final BluetoothAdapterProperties mAdapterProperties;
+    private final BluetoothDeviceProperties mDeviceProperties;
+
+    private final HashMap<String, Map<ParcelUuid, Integer>> mDeviceServiceChannelCache;
+    private final ArrayList<String> mUuidIntentTracker;
+    private final HashMap<RemoteService, IBluetoothCallback> mUuidCallbackTracker;
+
+    private static class ServiceRecordClient {
+        int pid;
+        IBinder binder;
+        IBinder.DeathRecipient death;
+    }
+    private final HashMap<Integer, ServiceRecordClient> mServiceRecordToPid;
+
+    private final HashMap<String, BluetoothDeviceProfileState> mDeviceProfileState;
+    private final BluetoothProfileState mA2dpProfileState;
+    private final BluetoothProfileState mHfpProfileState;
+
+    private BluetoothA2dpService mA2dpService;
+    private final HashMap<String, Pair<byte[], byte[]>> mDeviceOobData;
+
+    private int mProfilesConnected = 0, mProfilesConnecting = 0, mProfilesDisconnecting = 0;
+
+    private static String mDockAddress;
+    private String mDockPin;
+
+    private boolean mAllowConnect = true;
+
+    private int mAdapterConnectionState = BluetoothAdapter.STATE_DISCONNECTED;
+    private BluetoothPanProfileHandler mBluetoothPanProfileHandler;
+    private BluetoothInputProfileHandler mBluetoothInputProfileHandler;
+    private BluetoothHealthProfileHandler mBluetoothHealthProfileHandler;
+    private static final String INCOMING_CONNECTION_FILE =
+      "/data/misc/bluetooth/incoming_connection.conf";
+    private HashMap<String, Pair<Integer, String>> mIncomingConnections;
+    private HashMap<Integer, Pair<Integer, Integer>> mProfileConnectionState;
+
+    private static class RemoteService {
+        public String address;
+        public ParcelUuid uuid;
+        public RemoteService(String address, ParcelUuid uuid) {
+            this.address = address;
+            this.uuid = uuid;
+        }
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof RemoteService) {
+                RemoteService service = (RemoteService)o;
+                return address.equals(service.address) && uuid.equals(service.uuid);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            int hash = 1;
+            hash = hash * 31 + (address == null ? 0 : address.hashCode());
+            hash = hash * 31 + (uuid == null ? 0 : uuid.hashCode());
+            return hash;
+        }
+    }
+
+    static {
+        classInitNative();
+    }
+
+    public BluetoothService(Context context) {
+        mContext = context;
+
+        // Need to do this in place of:
+        // mBatteryStats = BatteryStatsService.getService();
+        // Since we can not import BatteryStatsService from here. This class really needs to be
+        // moved to java/services/com/android/server/
+        mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService("batteryinfo"));
+
+        initializeNativeDataNative();
+
+        if (isEnabledNative() == 1) {
+            Log.w(TAG, "Bluetooth daemons already running - runtime restart? ");
+            disableNative();
+        }
+
+        mBondState = new BluetoothBondState(context, this);
+        mAdapterProperties = new BluetoothAdapterProperties(context, this);
+        mDeviceProperties = new BluetoothDeviceProperties(this);
+
+        mDeviceServiceChannelCache = new HashMap<String, Map<ParcelUuid, Integer>>();
+        mDeviceOobData = new HashMap<String, Pair<byte[], byte[]>>();
+        mUuidIntentTracker = new ArrayList<String>();
+        mUuidCallbackTracker = new HashMap<RemoteService, IBluetoothCallback>();
+        mServiceRecordToPid = new HashMap<Integer, ServiceRecordClient>();
+        mDeviceProfileState = new HashMap<String, BluetoothDeviceProfileState>();
+        mA2dpProfileState = new BluetoothProfileState(mContext, BluetoothProfileState.A2DP);
+        mHfpProfileState = new BluetoothProfileState(mContext, BluetoothProfileState.HFP);
+
+        mHfpProfileState.start();
+        mA2dpProfileState.start();
+
+        IntentFilter filter = new IntentFilter();
+        registerForAirplaneMode(filter);
+
+        filter.addAction(Intent.ACTION_DOCK_EVENT);
+        mContext.registerReceiver(mReceiver, filter);
+        mBluetoothInputProfileHandler = BluetoothInputProfileHandler.getInstance(mContext, this);
+        mBluetoothPanProfileHandler = BluetoothPanProfileHandler.getInstance(mContext, this);
+        mBluetoothHealthProfileHandler = BluetoothHealthProfileHandler.getInstance(mContext, this);
+        mIncomingConnections = new HashMap<String, Pair<Integer, String>>();
+        mProfileConnectionState = new HashMap<Integer, Pair<Integer, Integer>>();
+    }
+
+    public static synchronized String readDockBluetoothAddress() {
+        if (mDockAddress != null) return mDockAddress;
+
+        BufferedInputStream file = null;
+        String dockAddress;
+        try {
+            file = new BufferedInputStream(new FileInputStream(DOCK_ADDRESS_PATH));
+            byte[] address = new byte[17];
+            file.read(address);
+            dockAddress = new String(address);
+            dockAddress = dockAddress.toUpperCase();
+            if (BluetoothAdapter.checkBluetoothAddress(dockAddress)) {
+                mDockAddress = dockAddress;
+                return mDockAddress;
+            } else {
+                Log.e(TAG, "CheckBluetoothAddress failed for car dock address: "
+                        + dockAddress);
+            }
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException while trying to read dock address");
+        } catch (IOException e) {
+            Log.e(TAG, "IOException while trying to read dock address");
+        } finally {
+            if (file != null) {
+                try {
+                    file.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+        mDockAddress = null;
+        return null;
+    }
+
+    private synchronized boolean writeDockPin() {
+        BufferedWriter out = null;
+        try {
+            out = new BufferedWriter(new FileWriter(DOCK_PIN_PATH));
+
+            // Generate a random 4 digit pin between 0000 and 9999
+            // This is not truly random but good enough for our purposes.
+            int pin = (int) Math.floor(Math.random() * 10000);
+
+            mDockPin = String.format("%04d", pin);
+            out.write(mDockPin);
+            return true;
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException while trying to write dock pairing pin");
+        } catch (IOException e) {
+            Log.e(TAG, "IOException while while trying to write dock pairing pin");
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+        mDockPin = null;
+        return false;
+    }
+
+    /*package*/ synchronized String getDockPin() {
+        return mDockPin;
+    }
+
+    public synchronized void initAfterRegistration() {
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        mBluetoothState = new BluetoothAdapterStateMachine(mContext, this, mAdapter);
+        mBluetoothState.start();
+        if (mContext.getResources().getBoolean
+            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
+            mBluetoothState.sendMessage(BluetoothAdapterStateMachine.TURN_HOT);
+        }
+        mEventLoop = mBluetoothState.getBluetoothEventLoop();
+    }
+
+    public synchronized void initAfterA2dpRegistration() {
+        mEventLoop.getProfileProxy();
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        mContext.unregisterReceiver(mReceiver);
+        try {
+            cleanupNativeDataNative();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    public boolean isEnabled() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return isEnabledInternal();
+    }
+
+    private boolean isEnabledInternal() {
+        return (getBluetoothStateInternal() == BluetoothAdapter.STATE_ON);
+    }
+
+    public int getBluetoothState() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return getBluetoothStateInternal();
+    }
+
+    int getBluetoothStateInternal() {
+        return mBluetoothState.getBluetoothAdapterState();
+    }
+
+    /**
+     * Bring down bluetooth and disable BT in settings. Returns true on success.
+     */
+    public boolean disable() {
+        return disable(true);
+    }
+
+    /**
+     * Bring down bluetooth. Returns true on success.
+     *
+     * @param saveSetting If true, persist the new setting
+     */
+    public synchronized boolean disable(boolean saveSetting) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
+
+        int adapterState = getBluetoothStateInternal();
+
+        switch (adapterState) {
+        case BluetoothAdapter.STATE_OFF:
+            return true;
+        case BluetoothAdapter.STATE_ON:
+            break;
+        default:
+            return false;
+        }
+
+        mBluetoothState.sendMessage(BluetoothAdapterStateMachine.USER_TURN_OFF, saveSetting);
+        return true;
+    }
+
+    synchronized void disconnectDevices() {
+        // Disconnect devices handled by BluetoothService.
+        for (BluetoothDevice device: getConnectedInputDevices()) {
+            disconnectInputDevice(device);
+        }
+
+        for (BluetoothDevice device: getConnectedPanDevices()) {
+            disconnectPanDevice(device);
+        }
+    }
+
+    /**
+     * The Bluetooth has been turned off, but hot. Do bonding, profile cleanup
+     */
+    synchronized void finishDisable() {
+        // mark in progress bondings as cancelled
+        for (String address : mBondState.listInState(BluetoothDevice.BOND_BONDING)) {
+            mBondState.setBondState(address, BluetoothDevice.BOND_NONE,
+                                    BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
+        }
+
+        // Stop the profile state machine for bonded devices.
+        for (String address : mBondState.listInState(BluetoothDevice.BOND_BONDED)) {
+            removeProfileState(address);
+        }
+
+        // update mode
+        Intent intent = new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
+        intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, BluetoothAdapter.SCAN_MODE_NONE);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+    }
+
+    /**
+     * Local clean up after broadcasting STATE_OFF intent
+     */
+    synchronized void cleanupAfterFinishDisable() {
+        mAdapterProperties.clear();
+
+        for (Integer srHandle : mServiceRecordToPid.keySet()) {
+            removeServiceRecordNative(srHandle);
+        }
+        mServiceRecordToPid.clear();
+
+        mProfilesConnected = 0;
+        mProfilesConnecting = 0;
+        mProfilesDisconnecting = 0;
+        mAdapterConnectionState = BluetoothAdapter.STATE_DISCONNECTED;
+        mAdapterUuids = null;
+        mAdapterSdpHandles = null;
+
+        // Log bluetooth off to battery stats.
+        long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.noteBluetoothOff();
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    /**
+     * power off Bluetooth
+     */
+    synchronized void shutoffBluetooth() {
+        if (mAdapterSdpHandles != null) removeReservedServiceRecordsNative(mAdapterSdpHandles);
+        setBluetoothTetheringNative(false, BluetoothPanProfileHandler.NAP_ROLE,
+                BluetoothPanProfileHandler.NAP_BRIDGE);
+        tearDownNativeDataNative();
+    }
+
+    /**
+     * Data clean up after Bluetooth shutoff
+     */
+    synchronized void cleanNativeAfterShutoffBluetooth() {
+        // Ths method is called after shutdown of event loop in the Bluetooth shut down
+        // procedure
+
+        // the adapter property could be changed before event loop is stoped, clear it again
+        mAdapterProperties.clear();
+        disableNative();
+    }
+
+    /** Bring up BT and persist BT on in settings */
+    public boolean enable() {
+        return enable(true, true);
+    }
+
+    /**
+     * Enable this Bluetooth device, asynchronously.
+     * This turns on/off the underlying hardware.
+     *
+     * @param saveSetting If true, persist the new state of BT in settings
+     * @param allowConnect If true, auto-connects device when BT is turned on
+     *                     and allows incoming A2DP/HSP connections
+     * @return True on success (so far)
+     */
+    public synchronized boolean enable(boolean saveSetting, boolean allowConnect) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+
+        // Airplane mode can prevent Bluetooth radio from being turned on.
+        if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
+            return false;
+        }
+        mAllowConnect = allowConnect;
+        mBluetoothState.sendMessage(BluetoothAdapterStateMachine.USER_TURN_ON, saveSetting);
+        return true;
+    }
+
+    /**
+     * Enable this Bluetooth device, asynchronously, but does not
+     * auto-connect devices. In this state the Bluetooth adapter
+     * also does not allow incoming A2DP/HSP connections (that
+     * must go through this service), but does allow communication
+     * on RFCOMM sockets implemented outside of this service (ie BTOPP).
+     * This method is used to temporarily enable Bluetooth
+     * for data transfer, without changing
+     *
+     * This turns on/off the underlying hardware.
+     *
+     * @return True on success (so far)
+     */
+    public boolean enableNoAutoConnect() {
+        return enable(false, false);
+    }
+
+    /**
+     * Turn on Bluetooth Module, Load firmware, and do all the preparation
+     * needed to get the Bluetooth Module ready but keep it not discoverable
+     * and not connectable.
+     */
+    /* package */ synchronized boolean prepareBluetooth() {
+        if (!setupNativeDataNative()) {
+            return false;
+        }
+        switchConnectable(false);
+
+        // Bluetooth stack needs a small delay here before adding
+        // SDP records, otherwise dbus stalls for over 30 seconds 1 out of 50 runs
+        try {
+            Thread.sleep(50);
+        } catch (InterruptedException e) {}
+        updateSdpRecords();
+        return true;
+    }
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case MESSAGE_UUID_INTENT:
+                String address = (String)msg.obj;
+                if (address != null) {
+                    sendUuidIntent(address);
+                    makeServiceChannelCallbacks(address);
+                }
+                break;
+            case MESSAGE_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY:
+                address = (String)msg.obj;
+                if (address == null) return;
+                int attempt = mBondState.getAttempt(address);
+
+                // Try only if attemps are in progress and cap it 2 attempts
+                // The 2 attempts cap is a fail safe if the stack returns
+                // an incorrect error code for bonding failures and if the pin
+                // is entered wrongly twice we should abort.
+                if (attempt > 0 && attempt <= 2) {
+                    mBondState.attempt(address);
+                    createBond(address);
+                    return;
+                }
+                if (attempt > 0) mBondState.clearPinAttempts(address);
+                break;
+            case MESSAGE_REMOVE_SERVICE_RECORD:
+                Pair<Integer, Integer> pair = (Pair<Integer, Integer>) msg.obj;
+                checkAndRemoveRecord(pair.first, pair.second);
+                break;
+            }
+        }
+    };
+
+    private synchronized void addReservedSdpRecords(final ArrayList<ParcelUuid> uuids) {
+        //Register SDP records.
+        int[] svcIdentifiers = new int[uuids.size()];
+        for (int i = 0; i < uuids.size(); i++) {
+            svcIdentifiers[i] = BluetoothUuid.getServiceIdentifierFromParcelUuid(uuids.get(i));
+        }
+        mAdapterSdpHandles = addReservedServiceRecordsNative(svcIdentifiers);
+    }
+
+    private synchronized void updateSdpRecords() {
+        ArrayList<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
+
+        Resources R = mContext.getResources();
+
+        // Add the default records
+        if (R.getBoolean(com.android.internal.R.bool.config_bluetooth_default_profiles)) {
+            uuids.add(BluetoothUuid.HSP_AG);
+            uuids.add(BluetoothUuid.ObexObjectPush);
+	    uuids.add(BluetoothUuid.MessageAccessServer);
+        }
+
+        if (R.getBoolean(com.android.internal.R.bool.config_voice_capable)) {
+            uuids.add(BluetoothUuid.Handsfree_AG);
+            uuids.add(BluetoothUuid.PBAP_PSE);
+        }
+
+        // Add SDP records for profiles maintained by Android userspace
+        addReservedSdpRecords(uuids);
+
+        // Bluetooth stack need some a small delay here before adding more
+        // SDP records, otherwise dbus stalls for over 30 seconds 1 out of 50 runs
+        try {
+            Thread.sleep(50);
+        } catch (InterruptedException e) {}
+
+        if (R.getBoolean(com.android.internal.R.bool.config_bluetooth_default_profiles)) {
+            // Enable profiles maintained by Bluez userspace.
+            setBluetoothTetheringNative(true, BluetoothPanProfileHandler.NAP_ROLE,
+                   BluetoothPanProfileHandler.NAP_BRIDGE);
+
+            // Add SDP records for profiles maintained by Bluez userspace
+            uuids.add(BluetoothUuid.AudioSource);
+            uuids.add(BluetoothUuid.AvrcpTarget);
+            uuids.add(BluetoothUuid.NAP);
+        }
+
+        // Cannot cast uuids.toArray directly since ParcelUuid is parcelable
+        mAdapterUuids = new ParcelUuid[uuids.size()];
+        for (int i = 0; i < uuids.size(); i++) {
+            mAdapterUuids[i] = uuids.get(i);
+        }
+    }
+
+    /**
+     * This function is called from Bluetooth Event Loop when onPropertyChanged
+     * for adapter comes in with UUID property.
+     * @param uuidsThe uuids of adapter as reported by Bluez.
+     */
+    /*package*/ synchronized void updateBluetoothState(String uuids) {
+        ParcelUuid[] adapterUuids = convertStringToParcelUuid(uuids);
+
+        if (mAdapterUuids != null &&
+            BluetoothUuid.containsAllUuids(adapterUuids, mAdapterUuids)) {
+            mBluetoothState.sendMessage(BluetoothAdapterStateMachine.SERVICE_RECORD_LOADED);
+        }
+    }
+
+    /**
+     * This method is called immediately before Bluetooth module is turned on after
+     * the adapter became pariable.
+     * It inits bond state and profile state before STATE_ON intent is broadcasted.
+     */
+    /*package*/ void initBluetoothAfterTurningOn() {
+        String discoverable = getProperty("Discoverable", false);
+        String timeout = getProperty("DiscoverableTimeout", false);
+        if (timeout == null) {
+            Log.w(TAG, "Null DiscoverableTimeout property");
+            // assign a number, anything not 0
+            timeout = "1";
+        }
+        if (discoverable.equals("true") && Integer.valueOf(timeout) != 0) {
+            setAdapterPropertyBooleanNative("Discoverable", 0);
+        }
+        mBondState.initBondState();
+        initProfileState();
+        getProfileProxy();
+    }
+
+    /**
+     * This method is called immediately after Bluetooth module is turned on.
+     * It starts auto-connection and places bluetooth on sign onto the battery
+     * stats
+     */
+    /*package*/ void runBluetooth() {
+        autoConnect();
+
+        // Log bluetooth on to battery stats.
+        long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.noteBluetoothOn();
+        } catch (RemoteException e) {
+            Log.e(TAG, "", e);
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    /*package*/ synchronized boolean attemptAutoPair(String address) {
+        if (!mBondState.hasAutoPairingFailed(address) &&
+                !mBondState.isAutoPairingBlacklisted(address)) {
+            mBondState.attempt(address);
+            setPin(address, BluetoothDevice.convertPinToBytes("0000"));
+            return true;
+        }
+        return false;
+    }
+
+    /*package*/ synchronized boolean isFixedPinZerosAutoPairKeyboard(String address) {
+        // Check for keyboards which have fixed PIN 0000 as the pairing pin
+        return mBondState.isFixedPinZerosAutoPairKeyboard(address);
+    }
+
+    /*package*/ synchronized void onCreatePairedDeviceResult(String address, int result) {
+        if (result == BluetoothDevice.BOND_SUCCESS) {
+            setBondState(address, BluetoothDevice.BOND_BONDED);
+            if (mBondState.isAutoPairingAttemptsInProgress(address)) {
+                mBondState.clearPinAttempts(address);
+            }
+        } else if (result == BluetoothDevice.UNBOND_REASON_AUTH_FAILED &&
+                mBondState.getAttempt(address) == 1) {
+            mBondState.addAutoPairingFailure(address);
+            pairingAttempt(address, result);
+        } else if (result == BluetoothDevice.UNBOND_REASON_REMOTE_DEVICE_DOWN &&
+              mBondState.isAutoPairingAttemptsInProgress(address)) {
+            pairingAttempt(address, result);
+        } else {
+            setBondState(address, BluetoothDevice.BOND_NONE, result);
+            if (mBondState.isAutoPairingAttemptsInProgress(address)) {
+                mBondState.clearPinAttempts(address);
+            }
+        }
+    }
+
+    /*package*/ synchronized String getPendingOutgoingBonding() {
+        return mBondState.getPendingOutgoingBonding();
+    }
+
+    private void pairingAttempt(String address, int result) {
+        // This happens when our initial guess of "0000" as the pass key
+        // fails. Try to create the bond again and display the pin dialog
+        // to the user. Use back-off while posting the delayed
+        // message. The initial value is
+        // INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY and the max value is
+        // MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY. If the max value is
+        // reached, display an error to the user.
+        int attempt = mBondState.getAttempt(address);
+        if (attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY >
+                    MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY) {
+            mBondState.clearPinAttempts(address);
+            setBondState(address, BluetoothDevice.BOND_NONE, result);
+            return;
+        }
+
+        Message message = mHandler.obtainMessage(MESSAGE_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY);
+        message.obj = address;
+        boolean postResult =  mHandler.sendMessageDelayed(message,
+                                        attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY);
+        if (!postResult) {
+            mBondState.clearPinAttempts(address);
+            setBondState(address,
+                    BluetoothDevice.BOND_NONE, result);
+            return;
+        }
+    }
+
+    /*package*/ BluetoothDevice getRemoteDevice(String address) {
+        return mAdapter.getRemoteDevice(address);
+    }
+
+    private static String toBondStateString(int bondState) {
+        switch (bondState) {
+        case BluetoothDevice.BOND_NONE:
+            return "not bonded";
+        case BluetoothDevice.BOND_BONDING:
+            return "bonding";
+        case BluetoothDevice.BOND_BONDED:
+            return "bonded";
+        default:
+            return "??????";
+        }
+    }
+
+    public synchronized boolean setName(String name) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (name == null) {
+            return false;
+        }
+        return setPropertyString("Name", name);
+    }
+
+    //TODO(): setPropertyString, setPropertyInteger, setPropertyBoolean
+    // Either have a single property function with Object as the parameter
+    // or have a function for each property and then obfuscate in the JNI layer.
+    // The following looks dirty.
+    private boolean setPropertyString(String key, String value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+        return setAdapterPropertyStringNative(key, value);
+    }
+
+    private boolean setPropertyInteger(String key, int value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+        return setAdapterPropertyIntegerNative(key, value);
+    }
+
+    private boolean setPropertyBoolean(String key, boolean value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+        return setAdapterPropertyBooleanNative(key, value ? 1 : 0);
+    }
+
+    /**
+     * Set the discoverability window for the device.  A timeout of zero
+     * makes the device permanently discoverable (if the device is
+     * discoverable).  Setting the timeout to a nonzero value does not make
+     * a device discoverable; you need to call setMode() to make the device
+     * explicitly discoverable.
+     *
+     * @param timeout The discoverable timeout in seconds.
+     */
+    public synchronized boolean setDiscoverableTimeout(int timeout) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        return setPropertyInteger("DiscoverableTimeout", timeout);
+    }
+
+    public synchronized boolean setScanMode(int mode, int duration) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS,
+                                                "Need WRITE_SECURE_SETTINGS permission");
+        boolean pairable;
+        boolean discoverable;
+
+        switch (mode) {
+        case BluetoothAdapter.SCAN_MODE_NONE:
+            pairable = false;
+            discoverable = false;
+            break;
+        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
+            pairable = true;
+            discoverable = false;
+            break;
+        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
+            pairable = true;
+            discoverable = true;
+            if (DBG) Log.d(TAG, "BT Discoverable for " + duration + " seconds");
+            break;
+        default:
+            Log.w(TAG, "Requested invalid scan mode " + mode);
+            return false;
+        }
+
+        setPropertyBoolean("Discoverable", discoverable);
+        setPropertyBoolean("Pairable", pairable);
+        return true;
+    }
+
+    /**
+     * @param on true set the local Bluetooth module to be connectable
+     *                The dicoverability is recovered to what it was before
+     *                switchConnectable(false) call
+     *           false set the local Bluetooth module to be not connectable
+     *                 and not dicoverable
+     */
+    /*package*/ synchronized void switchConnectable(boolean on) {
+        setAdapterPropertyBooleanNative("Powered", on ? 1 : 0);
+    }
+
+    /*package*/ synchronized void setPairable() {
+        String pairableString = getProperty("Pairable", false);
+        if (pairableString == null) {
+            Log.e(TAG, "null pairableString");
+            return;
+        }
+        if (pairableString.equals("false")) {
+            setAdapterPropertyBooleanNative("Pairable", 1);
+        }
+    }
+
+    /*package*/ String getProperty(String name, boolean checkState) {
+        // If checkState is false, check if the event loop is running.
+        // before making the call to Bluez
+        if (checkState) {
+            if (!isEnabledInternal()) return null;
+        } else if (!mEventLoop.isEventLoopRunning()) {
+            return null;
+        }
+
+        return mAdapterProperties.getProperty(name);
+    }
+
+    BluetoothAdapterProperties getAdapterProperties() {
+        return mAdapterProperties;
+    }
+
+    BluetoothDeviceProperties getDeviceProperties() {
+        return mDeviceProperties;
+    }
+
+    boolean isRemoteDeviceInCache(String address) {
+        return mDeviceProperties.isInCache(address);
+    }
+
+    void setRemoteDeviceProperty(String address, String name, String value) {
+        mDeviceProperties.setProperty(address, name, value);
+    }
+
+    void updateRemoteDevicePropertiesCache(String address) {
+        mDeviceProperties.updateCache(address);
+    }
+
+    public synchronized String getAddress() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        // Don't check state since we want to provide address, even if BT is off
+        return getProperty("Address", false);
+    }
+
+    public synchronized String getName() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        // Don't check state since we want to provide name, even if BT is off
+        return getProperty("Name", false);
+    }
+
+    public ParcelUuid[] getUuids() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        String value =  getProperty("UUIDs", true);
+        if (value == null) return null;
+        return convertStringToParcelUuid(value);
+    }
+
+    private ParcelUuid[] convertStringToParcelUuid(String value) {
+        String[] uuidStrings = null;
+        // The UUIDs are stored as a "," separated string.
+        uuidStrings = value.split(",");
+        ParcelUuid[] uuids = new ParcelUuid[uuidStrings.length];
+
+        for (int i = 0; i < uuidStrings.length; i++) {
+            uuids[i] = ParcelUuid.fromString(uuidStrings[i]);
+        }
+        return uuids;
+    }
+
+    /**
+     * Returns the user-friendly name of a remote device.  This value is
+     * returned from our local cache, which is updated when onPropertyChange
+     * event is received.
+     * Do not expect to retrieve the updated remote name immediately after
+     * changing the name on the remote device.
+     *
+     * @param address Bluetooth address of remote device.
+     *
+     * @return The user-friendly name of the specified remote device.
+     */
+    public synchronized String getRemoteName(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return null;
+        }
+        return mDeviceProperties.getProperty(address, "Name");
+    }
+
+    /**
+     * Returns alias of a remote device.  This value is returned from our
+     * local cache, which is updated when onPropertyChange event is received.
+     *
+     * @param address Bluetooth address of remote device.
+     *
+     * @return The alias of the specified remote device.
+     */
+    public synchronized String getRemoteAlias(String address) {
+
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return null;
+        }
+        return mDeviceProperties.getProperty(address, "Alias");
+    }
+
+    /**
+     * Set the alias of a remote device.
+     *
+     * @param address Bluetooth address of remote device.
+     * @param alias new alias to change to
+     * @return true on success, false on error
+     */
+    public synchronized boolean setRemoteAlias(String address, String alias) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+
+        return setDevicePropertyStringNative(getObjectPathFromAddress(address),
+                                             "Alias", alias);
+    }
+
+    /**
+     * Get the discoverability window for the device.  A timeout of zero
+     * means that the device is permanently discoverable (if the device is
+     * in the discoverable mode).
+     *
+     * @return The discoverability window of the device, in seconds.  A negative
+     *         value indicates an error.
+     */
+    public int getDiscoverableTimeout() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        String timeout = getProperty("DiscoverableTimeout", true);
+        if (timeout != null)
+           return Integer.valueOf(timeout);
+        else
+            return -1;
+    }
+
+    public int getScanMode() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal())
+            return BluetoothAdapter.SCAN_MODE_NONE;
+
+        boolean pairable = getProperty("Pairable", true).equals("true");
+        boolean discoverable = getProperty("Discoverable", true).equals("true");
+        return bluezStringToScanMode (pairable, discoverable);
+    }
+
+    public synchronized boolean startDiscovery() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        return startDiscoveryNative();
+    }
+
+    public synchronized boolean cancelDiscovery() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        return stopDiscoveryNative();
+    }
+
+    public boolean isDiscovering() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        String discoveringProperty = getProperty("Discovering", false);
+        if (discoveringProperty == null) {
+            return false;
+        }
+
+        return discoveringProperty.equals("true");
+    }
+
+    private boolean isBondingFeasible(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        address = address.toUpperCase();
+
+        if (mBondState.getPendingOutgoingBonding() != null) {
+            Log.d(TAG, "Ignoring createBond(): another device is bonding");
+            // a different device is currently bonding, fail
+            return false;
+        }
+
+        // Check for bond state only if we are not performing auto
+        // pairing exponential back-off attempts.
+        if (!mBondState.isAutoPairingAttemptsInProgress(address) &&
+                mBondState.getBondState(address) != BluetoothDevice.BOND_NONE) {
+            Log.d(TAG, "Ignoring createBond(): this device is already bonding or bonded");
+            return false;
+        }
+
+        if (address.equals(mDockAddress)) {
+            if (!writeDockPin()) {
+                Log.e(TAG, "Error while writing Pin for the dock");
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public synchronized boolean createBond(String address) {
+        if (!isBondingFeasible(address)) return false;
+
+        if (!createPairedDeviceNative(address, 60000  /*1 minute*/ )) {
+            return false;
+        }
+
+        mBondState.setPendingOutgoingBonding(address);
+        mBondState.setBondState(address, BluetoothDevice.BOND_BONDING);
+
+        return true;
+    }
+
+    public synchronized boolean createBondOutOfBand(String address, byte[] hash,
+                                                    byte[] randomizer) {
+        if (!isBondingFeasible(address)) return false;
+
+        if (!createPairedDeviceOutOfBandNative(address, 60000 /* 1 minute */)) {
+            return false;
+        }
+
+        setDeviceOutOfBandData(address, hash, randomizer);
+        mBondState.setPendingOutgoingBonding(address);
+        mBondState.setBondState(address, BluetoothDevice.BOND_BONDING);
+
+        return true;
+    }
+
+    public synchronized boolean setDeviceOutOfBandData(String address, byte[] hash,
+            byte[] randomizer) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        Pair <byte[], byte[]> value = new Pair<byte[], byte[]>(hash, randomizer);
+
+        if (DBG) {
+            Log.d(TAG, "Setting out of band data for: " + address + ":" +
+                  Arrays.toString(hash) + ":" + Arrays.toString(randomizer));
+        }
+
+        mDeviceOobData.put(address, value);
+        return true;
+    }
+
+    Pair<byte[], byte[]> getDeviceOutOfBandData(BluetoothDevice device) {
+        return mDeviceOobData.get(device.getAddress());
+    }
+
+
+    public synchronized byte[] readOutOfBandData() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return null;
+
+        return readAdapterOutOfBandDataNative();
+    }
+
+    public synchronized boolean cancelBondProcess(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        address = address.toUpperCase();
+        if (mBondState.getBondState(address) != BluetoothDevice.BOND_BONDING) {
+            return false;
+        }
+
+        mBondState.setBondState(address, BluetoothDevice.BOND_NONE,
+                                BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
+        cancelDeviceCreationNative(address);
+        return true;
+    }
+
+    public synchronized boolean removeBond(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            state.sendMessage(BluetoothDeviceProfileState.UNPAIR);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public synchronized boolean removeBondInternal(String address) {
+        // Unset the trusted device state and then unpair
+        setTrust(address, false);
+        return removeDeviceNative(getObjectPathFromAddress(address));
+    }
+
+    public synchronized String[] listBonds() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        return mBondState.listInState(BluetoothDevice.BOND_BONDED);
+    }
+
+    /*package*/ synchronized String[] listInState(int state) {
+      return mBondState.listInState(state);
+    }
+
+    public synchronized int getBondState(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return BluetoothDevice.ERROR;
+        }
+        return mBondState.getBondState(address.toUpperCase());
+    }
+
+    /*package*/ synchronized boolean setBondState(String address, int state) {
+        return setBondState(address, state, 0);
+    }
+
+    /*package*/ synchronized boolean setBondState(String address, int state, int reason) {
+        mBondState.setBondState(address.toUpperCase(), state, reason);
+        return true;
+    }
+
+    public synchronized boolean isBluetoothDock(String address) {
+        SharedPreferences sp = mContext.getSharedPreferences(SHARED_PREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+
+        return sp.contains(SHARED_PREFERENCE_DOCK_ADDRESS + address);
+    }
+
+    /*package*/ String[] getRemoteDeviceProperties(String address) {
+        if (!isEnabledInternal()) return null;
+
+        String objectPath = getObjectPathFromAddress(address);
+        return (String [])getDevicePropertiesNative(objectPath);
+    }
+
+    /**
+     * Sets the remote device trust state.
+     *
+     * @return boolean to indicate operation success or fail
+     */
+    public synchronized boolean setTrust(String address, boolean value) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                    "Need BLUETOOTH_ADMIN permission");
+            return false;
+        }
+
+        if (!isEnabledInternal()) return false;
+
+        return setDevicePropertyBooleanNative(
+                getObjectPathFromAddress(address), "Trusted", value ? 1 : 0);
+    }
+
+    /**
+     * Gets the remote device trust state as boolean.
+     * Note: this value may be
+     * retrieved from cache if we retrieved the data before *
+     *
+     * @return boolean to indicate trusted or untrusted state
+     */
+    public synchronized boolean getTrustState(String address) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            return false;
+        }
+
+        String val = mDeviceProperties.getProperty(address, "Trusted");
+        if (val == null) {
+            return false;
+        } else {
+            return val.equals("true");
+        }
+    }
+
+    /**
+     * Gets the remote major, minor classes encoded as a 32-bit
+     * integer.
+     *
+     * Note: this value is retrieved from cache, because we get it during
+     *       remote-device discovery.
+     *
+     * @return 32-bit integer encoding the remote major, minor, and service
+     *         classes.
+     */
+    public synchronized int getRemoteClass(String address) {
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            return BluetoothClass.ERROR;
+        }
+        String val = mDeviceProperties.getProperty(address, "Class");
+        if (val == null)
+            return BluetoothClass.ERROR;
+        else {
+            return Integer.valueOf(val);
+        }
+    }
+
+
+    /**
+     * Gets the UUIDs supported by the remote device
+     *
+     * @return array of 128bit ParcelUuids
+     */
+    public synchronized ParcelUuid[] getRemoteUuids(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return null;
+        }
+        return getUuidFromCache(address);
+    }
+
+    ParcelUuid[] getUuidFromCache(String address) {
+        String value = mDeviceProperties.getProperty(address, "UUIDs");
+        if (value == null) return null;
+
+        String[] uuidStrings = null;
+        // The UUIDs are stored as a "," separated string.
+        uuidStrings = value.split(",");
+        ParcelUuid[] uuids = new ParcelUuid[uuidStrings.length];
+
+        for (int i = 0; i < uuidStrings.length; i++) {
+            uuids[i] = ParcelUuid.fromString(uuidStrings[i]);
+        }
+        return uuids;
+    }
+
+    /**
+     * Connect and fetch new UUID's using SDP.
+     * The UUID's found are broadcast as intents.
+     * Optionally takes a uuid and callback to fetch the RFCOMM channel for the
+     * a given uuid.
+     * TODO: Don't wait UUID_INTENT_DELAY to broadcast UUID intents on success
+     * TODO: Don't wait UUID_INTENT_DELAY to handle the failure case for
+     * callback and broadcast intents.
+     */
+    public synchronized boolean fetchRemoteUuids(String address, ParcelUuid uuid,
+            IBluetoothCallback callback) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+
+        RemoteService service = new RemoteService(address, uuid);
+        if (uuid != null && mUuidCallbackTracker.get(service) != null) {
+            // An SDP query for this address & uuid is already in progress
+            // Do not add this callback for the uuid
+            return false;
+        }
+
+        if (mUuidIntentTracker.contains(address)) {
+            // An SDP query for this address is already in progress
+            // Add this uuid onto the in-progress SDP query
+            if (uuid != null) {
+                mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
+            }
+            return true;
+        }
+
+        // If the device is already created, we will
+        // do the SDP on the callback of createDeviceNative.
+        boolean ret= createDeviceNative(address);
+
+        mUuidIntentTracker.add(address);
+        if (uuid != null) {
+            mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
+        }
+
+        Message message = mHandler.obtainMessage(MESSAGE_UUID_INTENT);
+        message.obj = address;
+        mHandler.sendMessageDelayed(message, UUID_INTENT_DELAY);
+        return ret;
+    }
+
+    /**
+     * Gets the rfcomm channel associated with the UUID.
+     * Pulls records from the cache only.
+     *
+     * @param address Address of the remote device
+     * @param uuid ParcelUuid of the service attribute
+     *
+     * @return rfcomm channel associated with the service attribute
+     *         -1 on error
+     */
+    public int getRemoteServiceChannel(String address, ParcelUuid uuid) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return -1;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return BluetoothDevice.ERROR;
+        }
+        // Check if we are recovering from a crash.
+        if (mDeviceProperties.isEmpty()) {
+            if (mDeviceProperties.updateCache(address) == null)
+                return -1;
+        }
+
+        Map<ParcelUuid, Integer> value = mDeviceServiceChannelCache.get(address);
+        if (value != null && value.containsKey(uuid))
+            return value.get(uuid);
+        return -1;
+    }
+
+    public synchronized boolean setPin(String address, byte[] pin) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (pin == null || pin.length <= 0 || pin.length > 16 ||
+            !BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "setPin(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+        // bluez API wants pin as a string
+        String pinString;
+        try {
+            pinString = new String(pin, "UTF8");
+        } catch (UnsupportedEncodingException uee) {
+            Log.e(TAG, "UTF8 not supported?!?");
+            return false;
+        }
+        return setPinNative(address, pinString, data.intValue());
+    }
+
+    public synchronized boolean setPasskey(String address, int passkey) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (passkey < 0 || passkey > 999999 || !BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "setPasskey(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+        return setPasskeyNative(address, passkey, data.intValue());
+    }
+
+    public synchronized boolean setPairingConfirmation(String address, boolean confirm) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "setPasskey(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+        return setPairingConfirmationNative(address, confirm, data.intValue());
+    }
+
+    public synchronized boolean setRemoteOutOfBandData(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "setRemoteOobData(" + address + ") called but no native data available, " +
+                  "ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device" +
+                  " or by bluez.\n");
+            return false;
+        }
+
+        Pair<byte[], byte[]> val = mDeviceOobData.get(address);
+        byte[] hash, randomizer;
+        if (val == null) {
+            // TODO: check what should be passed in this case.
+            hash = new byte[16];
+            randomizer = new byte[16];
+        } else {
+            hash = val.first;
+            randomizer = val.second;
+        }
+        return setRemoteOutOfBandDataNative(address, hash, randomizer, data.intValue());
+    }
+
+    public synchronized boolean cancelPairingUserInput(String address) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        if (!isEnabledInternal()) return false;
+
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+        mBondState.setBondState(address, BluetoothDevice.BOND_NONE,
+                BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
+        address = address.toUpperCase();
+        Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
+        if (data == null) {
+            Log.w(TAG, "cancelUserInputNative(" + address + ") called but no native data " +
+                "available, ignoring. Maybe the PasskeyAgent Request was already cancelled " +
+                "by the remote or by bluez.\n");
+            return false;
+        }
+        return cancelPairingUserInputNative(address, data.intValue());
+    }
+
+    /*package*/ void updateDeviceServiceChannelCache(String address) {
+        if (DBG) Log.d(TAG, "updateDeviceServiceChannelCache(" + address + ")");
+
+        // We are storing the rfcomm channel numbers only for the uuids
+        // we are interested in.
+        ParcelUuid[] deviceUuids = getRemoteUuids(address);
+
+        ArrayList<ParcelUuid> applicationUuids = new ArrayList<ParcelUuid>();
+
+        synchronized (this) {
+            for (RemoteService service : mUuidCallbackTracker.keySet()) {
+                if (service.address.equals(address)) {
+                    applicationUuids.add(service.uuid);
+                }
+            }
+        }
+
+        Map <ParcelUuid, Integer> uuidToChannelMap = new HashMap<ParcelUuid, Integer>();
+
+        // Retrieve RFCOMM channel for default uuids
+        for (ParcelUuid uuid : RFCOMM_UUIDS) {
+            if (BluetoothUuid.isUuidPresent(deviceUuids, uuid)) {
+                int channel = getDeviceServiceChannelForUuid(address, uuid);
+                uuidToChannelMap.put(uuid, channel);
+                if (DBG) Log.d(TAG, "\tuuid(system): " + uuid + " " + channel);
+            }
+        }
+        // Retrieve RFCOMM channel for application requested uuids
+        for (ParcelUuid uuid : applicationUuids) {
+            if (BluetoothUuid.isUuidPresent(deviceUuids, uuid)) {
+                int channel = getDeviceServiceChannelForUuid(address, uuid);
+                uuidToChannelMap.put(uuid, channel);
+                if (DBG) Log.d(TAG, "\tuuid(application): " + uuid + " " + channel);
+            }
+        }
+
+        synchronized (this) {
+            // Make application callbacks
+            for (Iterator<RemoteService> iter = mUuidCallbackTracker.keySet().iterator();
+                    iter.hasNext();) {
+                RemoteService service = iter.next();
+                if (service.address.equals(address)) {
+                    if (uuidToChannelMap.containsKey(service.uuid)) {
+                        int channel = uuidToChannelMap.get(service.uuid);
+
+                        if (DBG) Log.d(TAG, "Making callback for " + service.uuid +
+                                    " with result " + channel);
+                        IBluetoothCallback callback = mUuidCallbackTracker.get(service);
+                        if (callback != null) {
+                            try {
+                                callback.onRfcommChannelFound(channel);
+                            } catch (RemoteException e) {Log.e(TAG, "", e);}
+                        }
+
+                        iter.remove();
+                    }
+                }
+            }
+
+            // Update cache
+            mDeviceServiceChannelCache.put(address, uuidToChannelMap);
+        }
+    }
+
+    private int getDeviceServiceChannelForUuid(String address,
+            ParcelUuid uuid) {
+        return getDeviceServiceChannelNative(getObjectPathFromAddress(address),
+                uuid.toString(), 0x0004);
+    }
+
+    /**
+     * b is a handle to a Binder instance, so that this service can be notified
+     * for Applications that terminate unexpectedly, to clean there service
+     * records
+     */
+    public synchronized int addRfcommServiceRecord(String serviceName, ParcelUuid uuid,
+            int channel, IBinder b) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if (!isEnabledInternal()) return -1;
+
+        if (serviceName == null || uuid == null || channel < 1 ||
+                channel > BluetoothSocket.MAX_RFCOMM_CHANNEL) {
+            return -1;
+        }
+        if (BluetoothUuid.isUuidPresent(BluetoothUuid.RESERVED_UUIDS, uuid)) {
+            Log.w(TAG, "Attempted to register a reserved UUID: " + uuid);
+            return -1;
+        }
+        int handle = addRfcommServiceRecordNative(serviceName,
+                uuid.getUuid().getMostSignificantBits(), uuid.getUuid().getLeastSignificantBits(),
+                (short)channel);
+        if (DBG) Log.d(TAG, "new handle " + Integer.toHexString(handle));
+        if (handle == -1) {
+            return -1;
+        }
+
+        ServiceRecordClient client = new ServiceRecordClient();
+        client.pid = Binder.getCallingPid();
+        client.binder = b;
+        client.death = new Reaper(handle, client.pid, RFCOMM_RECORD_REAPER);
+        mServiceRecordToPid.put(new Integer(handle), client);
+        try {
+            b.linkToDeath(client.death, 0);
+        } catch (RemoteException e) {
+            Log.e(TAG, "", e);
+            client.death = null;
+        }
+        return handle;
+    }
+
+    public void removeServiceRecord(int handle) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        // Since this is a binder call check if Bluetooth is off
+        if (getBluetoothStateInternal() == BluetoothAdapter.STATE_OFF) return;
+        Message message = mHandler.obtainMessage(MESSAGE_REMOVE_SERVICE_RECORD);
+        message.obj = new Pair<Integer, Integer>(handle, Binder.getCallingPid());
+        mHandler.sendMessage(message);
+    }
+
+    private synchronized void checkAndRemoveRecord(int handle, int pid) {
+        ServiceRecordClient client = mServiceRecordToPid.get(handle);
+        if (client != null && pid == client.pid) {
+            if (DBG) Log.d(TAG, "Removing service record " +
+                Integer.toHexString(handle) + " for pid " + pid);
+
+            if (client.death != null) {
+                client.binder.unlinkToDeath(client.death, 0);
+            }
+
+            mServiceRecordToPid.remove(handle);
+            removeServiceRecordNative(handle);
+        }
+    }
+
+    private class Reaper implements IBinder.DeathRecipient {
+        int mPid;
+        int mHandle;
+        int mType;
+
+        Reaper(int handle, int pid, int type) {
+            mPid = pid;
+            mHandle = handle;
+            mType = type;
+        }
+
+        Reaper(int pid, int type) {
+            mPid = pid;
+            mType = type;
+        }
+
+        @Override
+        public void binderDied() {
+            synchronized (BluetoothService.this) {
+                if (DBG) Log.d(TAG, "Tracked app " + mPid + " died" + "Type:" + mType);
+                if (mType == RFCOMM_RECORD_REAPER) {
+                    checkAndRemoveRecord(mHandle, mPid);
+                } else if (mType == STATE_CHANGE_REAPER) {
+                    mStateChangeTracker.remove(mPid);
+                }
+            }
+        }
+    }
+
+
+    @Override
+    public boolean changeApplicationBluetoothState(boolean on,
+            IBluetoothStateChangeCallback callback, IBinder binder) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        int pid = Binder.getCallingPid();
+        //mStateChangeTracker is a synchronized map
+        if (!mStateChangeTracker.containsKey(pid)) {
+            if (on) {
+                mStateChangeTracker.put(pid, callback);
+            } else {
+                return false;
+            }
+        } else if (!on) {
+            mStateChangeTracker.remove(pid);
+        }
+
+        if (binder != null) {
+            try {
+                binder.linkToDeath(new Reaper(pid, STATE_CHANGE_REAPER), 0);
+            } catch (RemoteException e) {
+                Log.e(TAG, "", e);
+                return false;
+            }
+        }
+
+        int type;
+        if (on) {
+            type = BluetoothAdapterStateMachine.PER_PROCESS_TURN_ON;
+        } else {
+            type = BluetoothAdapterStateMachine.PER_PROCESS_TURN_OFF;
+        }
+
+        mBluetoothState.sendMessage(type, callback);
+        return true;
+    }
+
+    boolean isApplicationStateChangeTrackerEmpty() {
+        return mStateChangeTracker.isEmpty();
+    }
+
+    void clearApplicationStateChangeTracker() {
+        mStateChangeTracker.clear();
+    }
+
+    Collection<IBluetoothStateChangeCallback> getApplicationStateChangeCallbacks() {
+        return mStateChangeTracker.values();
+    }
+
+    int getNumberOfApplicationStateChangeTrackers() {
+        return mStateChangeTracker.size();
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) return;
+
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+                ContentResolver resolver = context.getContentResolver();
+                // Query the airplane mode from Settings.System just to make sure that
+                // some random app is not sending this intent and disabling bluetooth
+                if (isAirplaneModeOn()) {
+                    mBluetoothState.sendMessage(BluetoothAdapterStateMachine.AIRPLANE_MODE_ON);
+                } else {
+                    mBluetoothState.sendMessage(BluetoothAdapterStateMachine.AIRPLANE_MODE_OFF);
+                }
+            } else if (Intent.ACTION_DOCK_EVENT.equals(action)) {
+                int state = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
+                        Intent.EXTRA_DOCK_STATE_UNDOCKED);
+                if (DBG) Log.v(TAG, "Received ACTION_DOCK_EVENT with State:" + state);
+                if (state == Intent.EXTRA_DOCK_STATE_UNDOCKED) {
+                    mDockAddress = null;
+                    mDockPin = null;
+                } else {
+                    SharedPreferences.Editor editor =
+                        mContext.getSharedPreferences(SHARED_PREFERENCES_NAME,
+                                mContext.MODE_PRIVATE).edit();
+                    editor.putBoolean(SHARED_PREFERENCE_DOCK_ADDRESS + mDockAddress, true);
+                    editor.apply();
+                }
+            }
+        }
+    };
+
+    private void registerForAirplaneMode(IntentFilter filter) {
+        final ContentResolver resolver = mContext.getContentResolver();
+        final String airplaneModeRadios = Settings.System.getString(resolver,
+                Settings.System.AIRPLANE_MODE_RADIOS);
+        final String toggleableRadios = Settings.System.getString(resolver,
+                Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
+
+        mIsAirplaneSensitive = airplaneModeRadios == null ? true :
+                airplaneModeRadios.contains(Settings.System.RADIO_BLUETOOTH);
+        mIsAirplaneToggleable = toggleableRadios == null ? false :
+                toggleableRadios.contains(Settings.System.RADIO_BLUETOOTH);
+
+        if (mIsAirplaneSensitive) {
+            filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        }
+    }
+
+    /* Returns true if airplane mode is currently on */
+    /*package*/ final boolean isAirplaneModeOn() {
+        return Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.AIRPLANE_MODE_ON, 0) == 1;
+    }
+
+    /* Broadcast the Uuid intent */
+    /*package*/ synchronized void sendUuidIntent(String address) {
+        ParcelUuid[] uuid = getUuidFromCache(address);
+        Intent intent = new Intent(BluetoothDevice.ACTION_UUID);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
+        intent.putExtra(BluetoothDevice.EXTRA_UUID, uuid);
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+        mUuidIntentTracker.remove(address);
+    }
+
+    /*package*/ synchronized void makeServiceChannelCallbacks(String address) {
+        for (Iterator<RemoteService> iter = mUuidCallbackTracker.keySet().iterator();
+                iter.hasNext();) {
+            RemoteService service = iter.next();
+            if (service.address.equals(address)) {
+                if (DBG) Log.d(TAG, "Cleaning up failed UUID channel lookup: "
+                    + service.address + " " + service.uuid);
+                IBluetoothCallback callback = mUuidCallbackTracker.get(service);
+                if (callback != null) {
+                    try {
+                        callback.onRfcommChannelFound(-1);
+                    } catch (RemoteException e) {Log.e(TAG, "", e);}
+                }
+
+                iter.remove();
+            }
+        }
+    }
+
+    @Override
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
+
+        if (getBluetoothStateInternal() != BluetoothAdapter.STATE_ON) {
+            return;
+        }
+
+        pw.println("mIsAirplaneSensitive = " + mIsAirplaneSensitive);
+        pw.println("mIsAirplaneToggleable = " + mIsAirplaneToggleable);
+
+        pw.println("Local address = " + getAddress());
+        pw.println("Local name = " + getName());
+        pw.println("isDiscovering() = " + isDiscovering());
+
+        mAdapter.getProfileProxy(mContext,
+                                 mBluetoothProfileServiceListener, BluetoothProfile.HEADSET);
+        mAdapter.getProfileProxy(mContext,
+                mBluetoothProfileServiceListener, BluetoothProfile.INPUT_DEVICE);
+        mAdapter.getProfileProxy(mContext,
+                mBluetoothProfileServiceListener, BluetoothProfile.PAN);
+
+        dumpKnownDevices(pw);
+        dumpAclConnectedDevices(pw);
+        dumpHeadsetService(pw);
+        dumpInputDeviceProfile(pw);
+        dumpPanProfile(pw);
+        dumpApplicationServiceRecords(pw);
+        dumpProfileState(pw);
+    }
+
+    private void dumpProfileState(PrintWriter pw) {
+        pw.println("\n--Profile State dump--");
+        pw.println("\n Headset profile state:" +
+                mAdapter.getProfileConnectionState(BluetoothProfile.HEADSET));
+        pw.println("\n A2dp profile state:" +
+                mAdapter.getProfileConnectionState(BluetoothProfile.A2DP));
+        pw.println("\n HID profile state:" +
+                mAdapter.getProfileConnectionState(BluetoothProfile.INPUT_DEVICE));
+        pw.println("\n PAN profile state:" +
+                mAdapter.getProfileConnectionState(BluetoothProfile.PAN));
+    }
+
+    private void dumpHeadsetService(PrintWriter pw) {
+        pw.println("\n--Headset Service--");
+        if (mHeadsetProxy != null) {
+            List<BluetoothDevice> deviceList = mHeadsetProxy.getConnectedDevices();
+            if (deviceList.size() == 0) {
+                pw.println("No headsets connected");
+            } else {
+                BluetoothDevice device = deviceList.get(0);
+                pw.println("\ngetConnectedDevices[0] = " + device);
+                dumpHeadsetConnectionState(pw, device);
+                pw.println("getBatteryUsageHint() = " +
+                             mHeadsetProxy.getBatteryUsageHint(device));
+            }
+
+            deviceList.clear();
+            deviceList = mHeadsetProxy.getDevicesMatchingConnectionStates(new int[] {
+                     BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED});
+            pw.println("--Connected and Disconnected Headsets");
+            for (BluetoothDevice device: deviceList) {
+                pw.println(device);
+                if (mHeadsetProxy.isAudioConnected(device)) {
+                    pw.println("SCO audio connected to device:" + device);
+                }
+            }
+        }
+    }
+
+    private void dumpInputDeviceProfile(PrintWriter pw) {
+        pw.println("\n--Bluetooth Service- Input Device Profile");
+        if (mInputDevice != null) {
+            List<BluetoothDevice> deviceList = mInputDevice.getConnectedDevices();
+            if (deviceList.size() == 0) {
+                pw.println("No input devices connected");
+            } else {
+                pw.println("Number of connected devices:" + deviceList.size());
+                BluetoothDevice device = deviceList.get(0);
+                pw.println("getConnectedDevices[0] = " + device);
+                pw.println("Priority of Connected device = " + mInputDevice.getPriority(device));
+
+                switch (mInputDevice.getConnectionState(device)) {
+                    case BluetoothInputDevice.STATE_CONNECTING:
+                        pw.println("getConnectionState() = STATE_CONNECTING");
+                        break;
+                    case BluetoothInputDevice.STATE_CONNECTED:
+                        pw.println("getConnectionState() = STATE_CONNECTED");
+                        break;
+                    case BluetoothInputDevice.STATE_DISCONNECTING:
+                        pw.println("getConnectionState() = STATE_DISCONNECTING");
+                        break;
+                }
+            }
+            deviceList.clear();
+            deviceList = mInputDevice.getDevicesMatchingConnectionStates(new int[] {
+                     BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED});
+            pw.println("--Connected and Disconnected input devices");
+            for (BluetoothDevice device: deviceList) {
+                pw.println(device);
+            }
+        }
+    }
+
+    private void dumpPanProfile(PrintWriter pw) {
+        pw.println("\n--Bluetooth Service- Pan Profile");
+        if (mPan != null) {
+            List<BluetoothDevice> deviceList = mPan.getConnectedDevices();
+            if (deviceList.size() == 0) {
+                pw.println("No Pan devices connected");
+            } else {
+                pw.println("Number of connected devices:" + deviceList.size());
+                BluetoothDevice device = deviceList.get(0);
+                pw.println("getConnectedDevices[0] = " + device);
+
+                switch (mPan.getConnectionState(device)) {
+                    case BluetoothInputDevice.STATE_CONNECTING:
+                        pw.println("getConnectionState() = STATE_CONNECTING");
+                        break;
+                    case BluetoothInputDevice.STATE_CONNECTED:
+                        pw.println("getConnectionState() = STATE_CONNECTED");
+                        break;
+                    case BluetoothInputDevice.STATE_DISCONNECTING:
+                        pw.println("getConnectionState() = STATE_DISCONNECTING");
+                        break;
+                }
+            }
+            deviceList.clear();
+            deviceList = mPan.getDevicesMatchingConnectionStates(new int[] {
+                     BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED});
+            pw.println("--Connected and Disconnected Pan devices");
+            for (BluetoothDevice device: deviceList) {
+                pw.println(device);
+            }
+        }
+    }
+
+    private void dumpHeadsetConnectionState(PrintWriter pw,
+            BluetoothDevice device) {
+        switch (mHeadsetProxy.getConnectionState(device)) {
+            case BluetoothHeadset.STATE_CONNECTING:
+                pw.println("getConnectionState() = STATE_CONNECTING");
+                break;
+            case BluetoothHeadset.STATE_CONNECTED:
+                pw.println("getConnectionState() = STATE_CONNECTED");
+                break;
+            case BluetoothHeadset.STATE_DISCONNECTING:
+                pw.println("getConnectionState() = STATE_DISCONNECTING");
+                break;
+            case BluetoothHeadset.STATE_AUDIO_CONNECTED:
+                pw.println("getConnectionState() = STATE_AUDIO_CONNECTED");
+                break;
+        }
+    }
+
+    private void dumpApplicationServiceRecords(PrintWriter pw) {
+        pw.println("\n--Application Service Records--");
+        for (Integer handle : mServiceRecordToPid.keySet()) {
+            Integer pid = mServiceRecordToPid.get(handle).pid;
+            pw.println("\tpid " + pid + " handle " + Integer.toHexString(handle));
+        }
+    }
+
+    private void dumpAclConnectedDevices(PrintWriter pw) {
+        String[] devicesObjectPath = getKnownDevices();
+        pw.println("\n--ACL connected devices--");
+        if (devicesObjectPath != null) {
+            for (String device : devicesObjectPath) {
+                pw.println(getAddressFromObjectPath(device));
+            }
+        }
+    }
+
+    private void dumpKnownDevices(PrintWriter pw) {
+        pw.println("\n--Known devices--");
+        for (String address : mDeviceProperties.keySet()) {
+            int bondState = mBondState.getBondState(address);
+            pw.printf("%s %10s (%d) %s\n", address,
+                       toBondStateString(bondState),
+                       mBondState.getAttempt(address),
+                       getRemoteName(address));
+
+            Map<ParcelUuid, Integer> uuidChannels = mDeviceServiceChannelCache.get(address);
+            if (uuidChannels == null) {
+                pw.println("\tuuids = null");
+            } else {
+                for (ParcelUuid uuid : uuidChannels.keySet()) {
+                    Integer channel = uuidChannels.get(uuid);
+                    if (channel == null) {
+                        pw.println("\t" + uuid);
+                    } else {
+                        pw.println("\t" + uuid + " RFCOMM channel = " + channel);
+                    }
+                }
+            }
+            for (RemoteService service : mUuidCallbackTracker.keySet()) {
+                if (service.address.equals(address)) {
+                    pw.println("\tPENDING CALLBACK: " + service.uuid);
+                }
+            }
+        }
+    }
+
+    private void getProfileProxy() {
+        mAdapter.getProfileProxy(mContext,
+                                 mBluetoothProfileServiceListener, BluetoothProfile.HEADSET);
+    }
+
+    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            if (profile == BluetoothProfile.HEADSET) {
+                mHeadsetProxy = (BluetoothHeadset) proxy;
+            } else if (profile == BluetoothProfile.INPUT_DEVICE) {
+                mInputDevice = (BluetoothInputDevice) proxy;
+            } else if (profile == BluetoothProfile.PAN) {
+                mPan = (BluetoothPan) proxy;
+            }
+        }
+        public void onServiceDisconnected(int profile) {
+            if (profile == BluetoothProfile.HEADSET) {
+                mHeadsetProxy = null;
+            } else if (profile == BluetoothProfile.INPUT_DEVICE) {
+                mInputDevice = null;
+            } else if (profile == BluetoothProfile.PAN) {
+                mPan = null;
+            }
+        }
+    };
+
+    /* package */ static int bluezStringToScanMode(boolean pairable, boolean discoverable) {
+        if (pairable && discoverable)
+            return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;
+        else if (pairable && !discoverable)
+            return BluetoothAdapter.SCAN_MODE_CONNECTABLE;
+        else
+            return BluetoothAdapter.SCAN_MODE_NONE;
+    }
+
+    /* package */ static String scanModeToBluezString(int mode) {
+        switch (mode) {
+        case BluetoothAdapter.SCAN_MODE_NONE:
+            return "off";
+        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
+            return "connectable";
+        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
+            return "discoverable";
+        }
+        return null;
+    }
+
+    /*package*/ String getAddressFromObjectPath(String objectPath) {
+        String adapterObjectPath = mAdapterProperties.getObjectPath();
+        if (adapterObjectPath == null || objectPath == null) {
+            Log.e(TAG, "getAddressFromObjectPath: AdapterObjectPath:" + adapterObjectPath +
+                    "  or deviceObjectPath:" + objectPath + " is null");
+            return null;
+        }
+        if (!objectPath.startsWith(adapterObjectPath)) {
+            Log.e(TAG, "getAddressFromObjectPath: AdapterObjectPath:" + adapterObjectPath +
+                    "  is not a prefix of deviceObjectPath:" + objectPath +
+                    "bluetoothd crashed ?");
+            return null;
+        }
+        String address = objectPath.substring(adapterObjectPath.length());
+        if (address != null) return address.replace('_', ':');
+
+        Log.e(TAG, "getAddressFromObjectPath: Address being returned is null");
+        return null;
+    }
+
+    /*package*/ String getObjectPathFromAddress(String address) {
+        String path = mAdapterProperties.getObjectPath();
+        if (path == null) {
+            Log.e(TAG, "Error: Object Path is null");
+            return null;
+        }
+        path = path + address.replace(":", "_");
+        return path;
+    }
+
+    /*package */ void setLinkTimeout(String address, int num_slots) {
+        String path = getObjectPathFromAddress(address);
+        boolean result = setLinkTimeoutNative(path, num_slots);
+
+        if (!result) Log.d(TAG, "Set Link Timeout to " + num_slots + " slots failed");
+    }
+
+    /**** Handlers for PAN  Profile ****/
+    // TODO: This needs to be converted to a state machine.
+
+    public boolean isTetheringOn() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.isTetheringOn();
+        }
+    }
+
+    /*package*/boolean allowIncomingTethering() {
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.allowIncomingTethering();
+        }
+    }
+
+    public void setBluetoothTethering(boolean value) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            mBluetoothPanProfileHandler.setBluetoothTethering(value);
+        }
+    }
+
+    public int getPanDeviceConnectionState(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.getPanDeviceConnectionState(device);
+        }
+    }
+
+    public boolean connectPanDevice(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+            "Need BLUETOOTH_ADMIN permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.connectPanDevice(device);
+        }
+    }
+
+    public List<BluetoothDevice> getConnectedPanDevices() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.getConnectedPanDevices();
+        }
+    }
+
+    public List<BluetoothDevice> getPanDevicesMatchingConnectionStates(
+            int[] states) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.getPanDevicesMatchingConnectionStates(states);
+        }
+    }
+
+    public boolean disconnectPanDevice(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+            "Need BLUETOOTH_ADMIN permission");
+        synchronized (mBluetoothPanProfileHandler) {
+            return mBluetoothPanProfileHandler.disconnectPanDevice(device);
+        }
+    }
+
+    /*package*/void handlePanDeviceStateChange(BluetoothDevice device,
+                                                             String iface,
+                                                             int state,
+                                                             int role) {
+        synchronized (mBluetoothPanProfileHandler) {
+            mBluetoothPanProfileHandler.handlePanDeviceStateChange(device, iface, state, role);
+        }
+    }
+
+    /*package*/void handlePanDeviceStateChange(BluetoothDevice device,
+                                                             int state, int role) {
+        synchronized (mBluetoothPanProfileHandler) {
+            mBluetoothPanProfileHandler.handlePanDeviceStateChange(device, null, state, role);
+        }
+    }
+
+    /**** Handlers for Input Device Profile ****/
+    // This needs to be converted to state machine
+
+    public boolean connectInputDevice(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(device.getAddress());
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.connectInputDevice(device, state);
+        }
+    }
+
+    public boolean connectInputDeviceInternal(BluetoothDevice device) {
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.connectInputDeviceInternal(device);
+        }
+    }
+
+    public boolean disconnectInputDevice(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(device.getAddress());
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.disconnectInputDevice(device, state);
+        }
+    }
+
+    public boolean disconnectInputDeviceInternal(BluetoothDevice device) {
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.disconnectInputDeviceInternal(device);
+        }
+    }
+
+    public int getInputDeviceConnectionState(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.getInputDeviceConnectionState(device);
+        }
+    }
+
+    public List<BluetoothDevice> getConnectedInputDevices() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.getConnectedInputDevices();
+        }
+    }
+
+    public List<BluetoothDevice> getInputDevicesMatchingConnectionStates(
+            int[] states) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.getInputDevicesMatchingConnectionStates(states);
+        }
+    }
+
+
+    public int getInputDevicePriority(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.getInputDevicePriority(device);
+        }
+    }
+
+    public boolean setInputDevicePriority(BluetoothDevice device, int priority) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.setInputDevicePriority(device, priority);
+        }
+    }
+
+    /**
+     * Handle incoming profile acceptance for profiles handled by Bluetooth Service,
+     * currently PAN and HID. This also is the catch all for all rejections for profiles
+     * that is not supported.
+     *
+     * @param device - Bluetooth Device
+     * @param allow - true / false
+     * @return
+     */
+    public boolean allowIncomingProfileConnect(BluetoothDevice device, boolean allow) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                                "Need BLUETOOTH_ADMIN permission");
+        String address = device.getAddress();
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            return false;
+        }
+
+        Integer data = getAuthorizationAgentRequestData(address);
+        if (data == null) {
+            Log.w(TAG, "allowIncomingProfileConnect(" + device +
+                  ") called but no native data available");
+            return false;
+        }
+        if (DBG) log("allowIncomingProfileConnect: " + device + " : " + allow + " : " + data);
+        return setAuthorizationNative(address, allow, data.intValue());
+    }
+
+    /*package*/List<BluetoothDevice> lookupInputDevicesMatchingStates(int[] states) {
+        synchronized (mBluetoothInputProfileHandler) {
+            return mBluetoothInputProfileHandler.lookupInputDevicesMatchingStates(states);
+        }
+    }
+
+    /*package*/void handleInputDevicePropertyChange(String address, boolean connected) {
+        synchronized (mBluetoothInputProfileHandler) {
+            mBluetoothInputProfileHandler.handleInputDevicePropertyChange(address, connected);
+        }
+    }
+
+    /**** Handlers for Health Device Profile ****/
+    // TODO: All these need to be converted to a state machine.
+
+    public boolean registerAppConfiguration(BluetoothHealthAppConfiguration config,
+                                            IBluetoothHealthCallback callback) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+                return mBluetoothHealthProfileHandler.registerAppConfiguration(config, callback);
+        }
+    }
+
+    public boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration config) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+                return mBluetoothHealthProfileHandler.unregisterAppConfiguration(config);
+        }
+    }
+
+
+    public boolean connectChannelToSource(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.connectChannelToSource(device,
+                    config);
+        }
+    }
+
+    public boolean connectChannelToSink(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int channelType) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.connectChannel(device, config,
+                    channelType);
+        }
+    }
+
+    public boolean disconnectChannel(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config, int id) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.disconnectChannel(device, config, id);
+        }
+    }
+
+    public ParcelFileDescriptor getMainChannelFd(BluetoothDevice device,
+            BluetoothHealthAppConfiguration config) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.getMainChannelFd(device, config);
+        }
+    }
+
+    /*package*/ void onHealthDevicePropertyChanged(String devicePath,
+            String channelPath) {
+        synchronized (mBluetoothHealthProfileHandler) {
+            mBluetoothHealthProfileHandler.onHealthDevicePropertyChanged(devicePath,
+                    channelPath);
+        }
+    }
+
+    /*package*/ void onHealthDeviceChannelChanged(String devicePath,
+            String channelPath, boolean exists) {
+        synchronized(mBluetoothHealthProfileHandler) {
+            mBluetoothHealthProfileHandler.onHealthDeviceChannelChanged(devicePath,
+                    channelPath, exists);
+        }
+    }
+
+    /*package*/ void onHealthDeviceChannelConnectionError(int channelCode,
+            int newState) {
+        synchronized(mBluetoothHealthProfileHandler) {
+            mBluetoothHealthProfileHandler.onHealthDeviceChannelConnectionError(channelCode,
+                                                                                newState);
+        }
+    }
+
+    public int getHealthDeviceConnectionState(BluetoothDevice device) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.getHealthDeviceConnectionState(device);
+        }
+    }
+
+    public List<BluetoothDevice> getConnectedHealthDevices() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.getConnectedHealthDevices();
+        }
+    }
+
+    public List<BluetoothDevice> getHealthDevicesMatchingConnectionStates(
+            int[] states) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                "Need BLUETOOTH permission");
+        synchronized (mBluetoothHealthProfileHandler) {
+            return mBluetoothHealthProfileHandler.
+                    getHealthDevicesMatchingConnectionStates(states);
+        }
+    }
+
+    /*package*/boolean notifyIncomingHidConnection(String address) {
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state == null) {
+            return false;
+        }
+        Message msg = new Message();
+        msg.what = BluetoothDeviceProfileState.CONNECT_HID_INCOMING;
+        state.sendMessage(msg);
+        return true;
+    }
+
+    public boolean connectHeadset(String address) {
+        if (getBondState(address) != BluetoothDevice.BOND_BONDED) return false;
+
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.CONNECT_HFP_OUTGOING;
+            msg.obj = state;
+            mHfpProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    public boolean disconnectHeadset(String address) {
+        if (getBondState(address) != BluetoothDevice.BOND_BONDED) return false;
+
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.DISCONNECT_HFP_OUTGOING;
+            msg.obj = state;
+            mHfpProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    public boolean connectSink(String address) {
+        if (getBondState(address) != BluetoothDevice.BOND_BONDED) return false;
+
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.CONNECT_A2DP_OUTGOING;
+            msg.obj = state;
+            mA2dpProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    public boolean disconnectSink(String address) {
+        if (getBondState(address) != BluetoothDevice.BOND_BONDED) return false;
+
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            msg.arg1 = BluetoothDeviceProfileState.DISCONNECT_A2DP_OUTGOING;
+            msg.obj = state;
+            mA2dpProfileState.sendMessage(msg);
+            return true;
+        }
+        return false;
+    }
+
+    BluetoothDeviceProfileState addProfileState(String address, boolean setTrust) {
+        BluetoothDeviceProfileState state =
+            new BluetoothDeviceProfileState(mContext, address, this, mA2dpService, setTrust);
+        mDeviceProfileState.put(address, state);
+        state.start();
+        return state;
+    }
+
+    void removeProfileState(String address) {
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state == null) return;
+
+        state.quit();
+        mDeviceProfileState.remove(address);
+    }
+
+    String[] getKnownDevices() {
+        String[] bonds = null;
+        String val = getProperty("Devices", true);
+        if (val != null) {
+            bonds = val.split(",");
+        }
+        return bonds;
+    }
+
+    private void initProfileState() {
+        String[] bonds = null;
+        String val = getProperty("Devices", false);
+        if (val != null) {
+            bonds = val.split(",");
+        }
+        if (bonds == null) {
+            return;
+        }
+        for (String path : bonds) {
+            String address = getAddressFromObjectPath(path);
+            BluetoothDeviceProfileState state = addProfileState(address, false);
+        }
+    }
+
+    private void autoConnect() {
+        synchronized (this) {
+            if (!mAllowConnect) {
+                Log.d(TAG, "Not auto-connecting devices because of temporary BT on state.");
+                return;
+            }
+        }
+
+        String[] bonds = getKnownDevices();
+        if (bonds == null) {
+            return;
+        }
+        for (String path : bonds) {
+            String address = getAddressFromObjectPath(path);
+            BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+            if (state != null) {
+                Message msg = new Message();
+                msg.what = BluetoothDeviceProfileState.AUTO_CONNECT_PROFILES;
+                state.sendMessage(msg);
+            }
+        }
+    }
+
+    public boolean notifyIncomingConnection(String address, boolean rejected) {
+        synchronized (this) {
+            if (!mAllowConnect) {
+                Log.d(TAG, "Not allowing incoming connection because of temporary BT on state.");
+                return false;
+            }
+        }
+        BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+        if (state != null) {
+            Message msg = new Message();
+            if (rejected) {
+                if (mA2dpService.getPriority(getRemoteDevice(address)) >=
+                    BluetoothProfile.PRIORITY_ON) {
+                    msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
+                    msg.arg1 = BluetoothDeviceProfileState.CONNECT_A2DP_OUTGOING;
+                    state.sendMessageDelayed(msg,
+                        BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES_DELAY);
+                }
+            } else {
+                msg.what = BluetoothDeviceProfileState.CONNECT_HFP_INCOMING;
+                state.sendMessage(msg);
+            }
+            return true;
+        }
+        return false;
+    }
+
+    /*package*/ boolean notifyIncomingA2dpConnection(String address, boolean rejected) {
+        synchronized (this) {
+            if (!mAllowConnect) {
+                Log.d(TAG, "Not allowing a2dp connection because of temporary BT on state.");
+                return false;
+            }
+        }
+
+       BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
+       if (state != null) {
+           Message msg = new Message();
+           if (rejected) {
+               if (mHeadsetProxy.getPriority(getRemoteDevice(address)) >=
+                   BluetoothProfile.PRIORITY_ON) {
+                   msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
+                   msg.arg1 = BluetoothDeviceProfileState.CONNECT_HFP_OUTGOING;
+                   state.sendMessageDelayed(msg,
+                             BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES_DELAY);
+               }
+           } else {
+               msg.what = BluetoothDeviceProfileState.CONNECT_A2DP_INCOMING;
+               state.sendMessage(msg);
+           }
+           return true;
+       }
+       return false;
+    }
+
+    /*package*/ void setA2dpService(BluetoothA2dpService a2dpService) {
+        mA2dpService = a2dpService;
+    }
+
+    /*package*/ Integer getAuthorizationAgentRequestData(String address) {
+        Integer data = mEventLoop.getAuthorizationAgentRequestData().remove(address);
+        return data;
+    }
+
+    public void sendProfileStateMessage(int profile, int cmd) {
+        Message msg = new Message();
+        msg.what = cmd;
+        if (profile == BluetoothProfileState.HFP) {
+            mHfpProfileState.sendMessage(msg);
+        } else if (profile == BluetoothProfileState.A2DP) {
+            mA2dpProfileState.sendMessage(msg);
+        }
+    }
+
+    public int getAdapterConnectionState() {
+        return mAdapterConnectionState;
+    }
+
+    public int getProfileConnectionState(int profile) {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        Pair<Integer, Integer> state = mProfileConnectionState.get(profile);
+        if (state == null) return BluetoothProfile.STATE_DISCONNECTED;
+
+        return state.first;
+    }
+
+    private void updateProfileConnectionState(int profile, int newState, int oldState) {
+        // mProfileConnectionState is a hashmap -
+        // <Integer, Pair<Integer, Integer>>
+        // The key is the profile, the value is a pair. first element
+        // is the state and the second element is the number of devices
+        // in that state.
+        int numDev = 1;
+        int newHashState = newState;
+        boolean update = true;
+
+        // The following conditions are considered in this function:
+        // 1. If there is no record of profile and state - update
+        // 2. If a new device's state is current hash state - increment
+        //    number of devices in the state.
+        // 3. If a state change has happened to Connected or Connecting
+        //    (if current state is not connected), update.
+        // 4. If numDevices is 1 and that device state is being updated, update
+        // 5. If numDevices is > 1 and one of the devices is changing state,
+        //    decrement numDevices but maintain oldState if it is Connected or
+        //    Connecting
+        Pair<Integer, Integer> stateNumDev = mProfileConnectionState.get(profile);
+        if (stateNumDev != null) {
+            int currHashState = stateNumDev.first;
+            numDev = stateNumDev.second;
+
+            if (newState == currHashState) {
+                numDev ++;
+            } else if (newState == BluetoothProfile.STATE_CONNECTED ||
+                   (newState == BluetoothProfile.STATE_CONNECTING &&
+                    currHashState != BluetoothProfile.STATE_CONNECTED)) {
+                 numDev = 1;
+            } else if (numDev == 1 && oldState == currHashState) {
+                 update = true;
+            } else if (numDev > 1 && oldState == currHashState) {
+                 numDev --;
+
+                 if (currHashState == BluetoothProfile.STATE_CONNECTED ||
+                     currHashState == BluetoothProfile.STATE_CONNECTING) {
+                    newHashState = currHashState;
+                 }
+            } else {
+                 update = false;
+            }
+        }
+
+        if (update) {
+            mProfileConnectionState.put(profile, new Pair<Integer, Integer>(newHashState,
+                    numDev));
+        }
+    }
+
+    public synchronized void sendConnectionStateChange(BluetoothDevice
+            device, int profile, int state, int prevState) {
+        // Since this is a binder call check if Bluetooth is on still
+        if (getBluetoothStateInternal() == BluetoothAdapter.STATE_OFF) return;
+
+        if (!validateProfileConnectionState(state) ||
+                !validateProfileConnectionState(prevState)) {
+            // Previously, an invalid state was broadcast anyway,
+            // with the invalid state converted to -1 in the intent.
+            // Better to log an error and not send an intent with
+            // invalid contents or set mAdapterConnectionState to -1.
+            Log.e(TAG, "Error in sendConnectionStateChange: "
+                    + "prevState " + prevState + " state " + state);
+            return;
+        }
+
+        updateProfileConnectionState(profile, state, prevState);
+
+        if (updateCountersAndCheckForConnectionStateChange(state, prevState)) {
+            mAdapterConnectionState = state;
+
+            if (state == BluetoothProfile.STATE_DISCONNECTED) {
+                mBluetoothState.sendMessage(BluetoothAdapterStateMachine.ALL_DEVICES_DISCONNECTED);
+            }
+
+            Intent intent = new Intent(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            intent.putExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,
+                    convertToAdapterState(state));
+            intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_CONNECTION_STATE,
+                    convertToAdapterState(prevState));
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+            Log.d(TAG, "CONNECTION_STATE_CHANGE: " + device + ": "
+                    + prevState + " -> " + state);
+        }
+    }
+
+    private boolean validateProfileConnectionState(int state) {
+        return (state == BluetoothProfile.STATE_DISCONNECTED ||
+                state == BluetoothProfile.STATE_CONNECTING ||
+                state == BluetoothProfile.STATE_CONNECTED ||
+                state == BluetoothProfile.STATE_DISCONNECTING);
+    }
+
+    private int convertToAdapterState(int state) {
+        switch (state) {
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return BluetoothAdapter.STATE_DISCONNECTED;
+            case BluetoothProfile.STATE_DISCONNECTING:
+                return BluetoothAdapter.STATE_DISCONNECTING;
+            case BluetoothProfile.STATE_CONNECTED:
+                return BluetoothAdapter.STATE_CONNECTED;
+            case BluetoothProfile.STATE_CONNECTING:
+                return BluetoothAdapter.STATE_CONNECTING;
+        }
+        Log.e(TAG, "Error in convertToAdapterState");
+        return -1;
+    }
+
+    private boolean updateCountersAndCheckForConnectionStateChange(int state, int prevState) {
+        switch (prevState) {
+            case BluetoothProfile.STATE_CONNECTING:
+                mProfilesConnecting--;
+                break;
+
+            case BluetoothProfile.STATE_CONNECTED:
+                mProfilesConnected--;
+                break;
+
+            case BluetoothProfile.STATE_DISCONNECTING:
+                mProfilesDisconnecting--;
+                break;
+        }
+
+        switch (state) {
+            case BluetoothProfile.STATE_CONNECTING:
+                mProfilesConnecting++;
+                return (mProfilesConnected == 0 && mProfilesConnecting == 1);
+
+            case BluetoothProfile.STATE_CONNECTED:
+                mProfilesConnected++;
+                return (mProfilesConnected == 1);
+
+            case BluetoothProfile.STATE_DISCONNECTING:
+                mProfilesDisconnecting++;
+                return (mProfilesConnected == 0 && mProfilesDisconnecting == 1);
+
+            case BluetoothProfile.STATE_DISCONNECTED:
+                return (mProfilesConnected == 0 && mProfilesConnecting == 0);
+
+            default:
+                return true;
+        }
+    }
+
+    private void createIncomingConnectionStateFile() {
+        File f = new File(INCOMING_CONNECTION_FILE);
+        if (!f.exists()) {
+            try {
+                f.createNewFile();
+            } catch (IOException e) {
+                Log.e(TAG, "IOException: cannot create file");
+            }
+        }
+    }
+
+    /** @hide */
+    public Pair<Integer, String> getIncomingState(String address) {
+        if (mIncomingConnections.isEmpty()) {
+            createIncomingConnectionStateFile();
+            readIncomingConnectionState();
+        }
+        return mIncomingConnections.get(address);
+    }
+
+    private void readIncomingConnectionState() {
+        synchronized(mIncomingConnections) {
+            FileInputStream fstream = null;
+            try {
+              fstream = new FileInputStream(INCOMING_CONNECTION_FILE);
+              DataInputStream in = new DataInputStream(fstream);
+              BufferedReader file = new BufferedReader(new InputStreamReader(in));
+              String line;
+              while((line = file.readLine()) != null) {
+                  line = line.trim();
+                  if (line.length() == 0) continue;
+                  String[] value = line.split(",");
+                  if (value != null && value.length == 3) {
+                      Integer val1 = Integer.parseInt(value[1]);
+                      Pair<Integer, String> val = new Pair(val1, value[2]);
+                      mIncomingConnections.put(value[0], val);
+                  }
+              }
+            } catch (FileNotFoundException e) {
+                log("FileNotFoundException: readIncomingConnectionState" + e.toString());
+            } catch (IOException e) {
+                log("IOException: readIncomingConnectionState" + e.toString());
+            } finally {
+                if (fstream != null) {
+                    try {
+                        fstream.close();
+                    } catch (IOException e) {
+                        // Ignore
+                    }
+                }
+            }
+        }
+    }
+
+    private void truncateIncomingConnectionFile() {
+        RandomAccessFile r = null;
+        try {
+            r = new RandomAccessFile(INCOMING_CONNECTION_FILE, "rw");
+            r.setLength(0);
+        } catch (FileNotFoundException e) {
+            log("FileNotFoundException: truncateIncomingConnectionState" + e.toString());
+        } catch (IOException e) {
+            log("IOException: truncateIncomingConnectionState" + e.toString());
+        } finally {
+            if (r != null) {
+                try {
+                    r.close();
+                } catch (IOException e) {
+                    // ignore
+                 }
+            }
+        }
+    }
+
+    /** @hide */
+    public void writeIncomingConnectionState(String address, Pair<Integer, String> data) {
+        synchronized(mIncomingConnections) {
+            mIncomingConnections.put(address, data);
+
+            truncateIncomingConnectionFile();
+            BufferedWriter out = null;
+            StringBuilder value = new StringBuilder();
+            try {
+                out = new BufferedWriter(new FileWriter(INCOMING_CONNECTION_FILE, true));
+                for (String devAddress: mIncomingConnections.keySet()) {
+                  Pair<Integer, String> val = mIncomingConnections.get(devAddress);
+                  value.append(devAddress);
+                  value.append(",");
+                  value.append(val.first.toString());
+                  value.append(",");
+                  value.append(val.second);
+                  value.append("\n");
+                }
+                out.write(value.toString());
+            } catch (FileNotFoundException e) {
+                log("FileNotFoundException: writeIncomingConnectionState" + e.toString());
+            } catch (IOException e) {
+                log("IOException: writeIncomingConnectionState" + e.toString());
+            } finally {
+                if (out != null) {
+                    try {
+                        out.close();
+                    } catch (IOException e) {
+                        // Ignore
+                    }
+                }
+            }
+        }
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+
+    private native static void classInitNative();
+    private native void initializeNativeDataNative();
+    private native boolean setupNativeDataNative();
+    private native boolean tearDownNativeDataNative();
+    private native void cleanupNativeDataNative();
+    /*package*/ native String getAdapterPathNative();
+
+    private native int isEnabledNative();
+    /*package*/ native int enableNative();
+    /*package*/ native int disableNative();
+
+    /*package*/ native Object[] getAdapterPropertiesNative();
+    private native Object[] getDevicePropertiesNative(String objectPath);
+    private native boolean setAdapterPropertyStringNative(String key, String value);
+    private native boolean setAdapterPropertyIntegerNative(String key, int value);
+    private native boolean setAdapterPropertyBooleanNative(String key, int value);
+
+    private native boolean startDiscoveryNative();
+    private native boolean stopDiscoveryNative();
+
+    private native boolean createPairedDeviceNative(String address, int timeout_ms);
+    private native boolean createPairedDeviceOutOfBandNative(String address, int timeout_ms);
+    private native byte[] readAdapterOutOfBandDataNative();
+
+    private native boolean cancelDeviceCreationNative(String address);
+    private native boolean removeDeviceNative(String objectPath);
+    private native int getDeviceServiceChannelNative(String objectPath, String uuid,
+            int attributeId);
+
+    private native boolean cancelPairingUserInputNative(String address, int nativeData);
+    private native boolean setPinNative(String address, String pin, int nativeData);
+    private native boolean setPasskeyNative(String address, int passkey, int nativeData);
+    private native boolean setPairingConfirmationNative(String address, boolean confirm,
+            int nativeData);
+    private native boolean setRemoteOutOfBandDataNative(String address, byte[] hash,
+                                                        byte[] randomizer, int nativeData);
+
+    private native boolean setDevicePropertyBooleanNative(String objectPath, String key,
+            int value);
+    private native boolean setDevicePropertyStringNative(String objectPath, String key,
+            String value);
+    private native boolean createDeviceNative(String address);
+    /*package*/ native boolean discoverServicesNative(String objectPath, String pattern);
+
+    private native int addRfcommServiceRecordNative(String name, long uuidMsb, long uuidLsb,
+            short channel);
+    private native boolean removeServiceRecordNative(int handle);
+    private native boolean setLinkTimeoutNative(String path, int num_slots);
+
+    native boolean connectInputDeviceNative(String path);
+    native boolean disconnectInputDeviceNative(String path);
+
+    native boolean setBluetoothTetheringNative(boolean value, String nap, String bridge);
+    native boolean connectPanDeviceNative(String path, String dstRole);
+    native boolean disconnectPanDeviceNative(String path);
+    native boolean disconnectPanServerDeviceNative(String path,
+            String address, String iface);
+
+    private native int[] addReservedServiceRecordsNative(int[] uuuids);
+    private native boolean removeReservedServiceRecordsNative(int[] handles);
+
+    // Health API
+    native String registerHealthApplicationNative(int dataType, String role, String name,
+            String channelType);
+    native String registerHealthApplicationNative(int dataType, String role, String name);
+    native boolean unregisterHealthApplicationNative(String path);
+    native boolean createChannelNative(String devicePath, String appPath, String channelType,
+                                       int code);
+    native boolean destroyChannelNative(String devicePath, String channelpath, int code);
+    native String getMainChannelNative(String path);
+    native String getChannelApplicationNative(String channelPath);
+    native ParcelFileDescriptor getChannelFdNative(String channelPath);
+    native boolean releaseChannelFdNative(String channelPath);
+    native boolean setAuthorizationNative(String address, boolean value, int data);
+}
diff --git a/core/java/com/android/internal/util/StateMachine.java b/core/java/com/android/internal/util/StateMachine.java
index 0ea7b83..86a9eb4 100644
--- a/core/java/com/android/internal/util/StateMachine.java
+++ b/core/java/com/android/internal/util/StateMachine.java
@@ -423,7 +423,7 @@ public class StateMachine {
     private String mName;
 
     /** Message.what value when quitting */
-    private static final int SM_QUIT_CMD = -1;
+    public static final int SM_QUIT_CMD = -1;
 
     /** Message.what value when initializing */
     private static final int SM_INIT_CMD = -2;
@@ -1150,7 +1150,7 @@ public class StateMachine {
         }
 
         /** @see StateMachine#quit() */
-        private final void quit() {
+        public final void quit() {
             if (mDbg) Log.d(TAG, "quit:");
             sendMessage(obtainMessage(SM_QUIT_CMD, mSmHandlerObj));
         }
@@ -1587,7 +1587,7 @@ public class StateMachine {
     /**
      * Quit the state machine after all currently queued up messages are processed.
      */
-    protected final void quit() {
+    public final void quit() {
         // mSmHandler can be null if the state machine is already stopped.
         if (mSmHandler == null) return;
 
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index 33f690a..b72ea83 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -140,6 +140,14 @@ LOCAL_SRC_FILES:= \
 	android_util_FileObserver.cpp \
 	android/opengl/poly_clip.cpp.arm \
 	android/opengl/util.cpp.arm \
+	android_bluetooth_HeadsetBase.cpp \
+	android_bluetooth_common.cpp \
+	android_bluetooth_BluetoothAudioGateway.cpp \
+	android_bluetooth_BluetoothSocket.cpp \
+	android_bluetooth_c.c \
+	android_server_BluetoothService.cpp \
+	android_server_BluetoothEventLoop.cpp \
+	android_server_BluetoothA2dpService.cpp \
 	android_server_NetworkManagementSocketTagger.cpp \
 	android_server_Watchdog.cpp \
 	android_ddm_DdmHandleNativeHeap.cpp \
@@ -223,6 +231,14 @@ LOCAL_SHARED_LIBRARIES := \
 	libharfbuzz \
 	libz
 
+ifeq ($(BOARD_HAVE_BLUETOOTH),true)
+LOCAL_C_INCLUDES += \
+	external/dbus \
+	system/bluetooth/bluez-clean-headers
+LOCAL_CFLAGS += -DHAVE_BLUETOOTH
+LOCAL_SHARED_LIBRARIES += libbluedroid libdbus
+endif
+
 ifeq ($(HAVE_SELINUX),true)
 LOCAL_C_INCLUDES += external/libselinux/include
 LOCAL_SHARED_LIBRARIES += libselinux
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index 7dd1987..ac808e7 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -151,6 +151,14 @@ extern int register_android_net_wifi_WifiManager(JNIEnv* env);
 extern int register_android_text_AndroidCharacter(JNIEnv *env);
 extern int register_android_text_AndroidBidi(JNIEnv *env);
 extern int register_android_opengl_classes(JNIEnv *env);
+//vuk
+extern int register_android_bluetooth_HeadsetBase(JNIEnv* env);
+extern int register_android_bluetooth_BluetoothAudioGateway(JNIEnv* env);
+extern int register_android_bluetooth_BluetoothSocket(JNIEnv *env);
+extern int register_android_server_BluetoothService(JNIEnv* env);
+extern int register_android_server_BluetoothEventLoop(JNIEnv *env);
+extern int register_android_server_BluetoothA2dpService(JNIEnv* env);
+
 extern int register_android_server_NetworkManagementSocketTagger(JNIEnv* env);
 extern int register_android_server_Watchdog(JNIEnv* env);
 extern int register_android_ddm_DdmHandleNativeHeap(JNIEnv *env);
@@ -1197,6 +1205,13 @@ static const RegJNIRec gRegJNI[] = {
     REG_JNI(register_android_media_ToneGenerator),
 
     REG_JNI(register_android_opengl_classes),
+    REG_JNI(register_android_bluetooth_HeadsetBase),
+    REG_JNI(register_android_bluetooth_BluetoothAudioGateway),
+    REG_JNI(register_android_bluetooth_BluetoothSocket),
+    REG_JNI(register_android_server_BluetoothService),
+    REG_JNI(register_android_server_BluetoothEventLoop),
+    REG_JNI(register_android_server_BluetoothA2dpService),
+
     REG_JNI(register_android_server_NetworkManagementSocketTagger),
     REG_JNI(register_android_server_Watchdog),
     REG_JNI(register_android_ddm_DdmHandleNativeHeap),
diff --git a/core/jni/android_bluetooth_BluetoothAudioGateway.cpp b/core/jni/android_bluetooth_BluetoothAudioGateway.cpp
new file mode 100644
index 0000000..294c626
--- /dev/null
+++ b/core/jni/android_bluetooth_BluetoothAudioGateway.cpp
@@ -0,0 +1,553 @@
+/*
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "BluetoothAudioGateway.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_bluetooth_c.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#define USE_ACCEPT_DIRECTLY (0)
+#define USE_SELECT (0) /* 1 for select(), 0 for poll(); used only when
+                          USE_ACCEPT_DIRECTLY == 0 */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/uio.h>
+#include <ctype.h>
+
+#if USE_SELECT
+#include <sys/select.h>
+#else
+#include <sys/poll.h>
+#endif
+
+#ifdef HAVE_BLUETOOTH
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/rfcomm.h>
+#include <bluetooth/sco.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+static jfieldID field_mNativeData;
+    /* in */
+static jfieldID field_mHandsfreeAgRfcommChannel;
+static jfieldID field_mHeadsetAgRfcommChannel;
+    /* out */
+static jfieldID field_mTimeoutRemainingMs; /* out */
+
+static jfieldID field_mConnectingHeadsetAddress;
+static jfieldID field_mConnectingHeadsetRfcommChannel; /* -1 when not connected */
+static jfieldID field_mConnectingHeadsetSocketFd;
+
+static jfieldID field_mConnectingHandsfreeAddress;
+static jfieldID field_mConnectingHandsfreeRfcommChannel; /* -1 when not connected */
+static jfieldID field_mConnectingHandsfreeSocketFd;
+
+
+typedef struct {
+    int hcidev;
+    int hf_ag_rfcomm_channel;
+    int hs_ag_rfcomm_channel;
+    int hf_ag_rfcomm_sock;
+    int hs_ag_rfcomm_sock;
+} native_data_t;
+
+static inline native_data_t * get_native_data(JNIEnv *env, jobject object) {
+    return (native_data_t *)(env->GetIntField(object,
+                                                 field_mNativeData));
+}
+
+static int setup_listening_socket(int dev, int channel);
+#endif
+
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+
+    /* in */
+    field_mNativeData = get_field(env, clazz, "mNativeData", "I");
+    field_mHandsfreeAgRfcommChannel =
+        get_field(env, clazz, "mHandsfreeAgRfcommChannel", "I");
+    field_mHeadsetAgRfcommChannel =
+        get_field(env, clazz, "mHeadsetAgRfcommChannel", "I");
+
+    /* out */
+    field_mConnectingHeadsetAddress =
+        get_field(env, clazz,
+                  "mConnectingHeadsetAddress", "Ljava/lang/String;");
+    field_mConnectingHeadsetRfcommChannel =
+        get_field(env, clazz, "mConnectingHeadsetRfcommChannel", "I");
+    field_mConnectingHeadsetSocketFd =
+        get_field(env, clazz, "mConnectingHeadsetSocketFd", "I");
+
+    field_mConnectingHandsfreeAddress =
+        get_field(env, clazz,
+                  "mConnectingHandsfreeAddress", "Ljava/lang/String;");
+    field_mConnectingHandsfreeRfcommChannel =
+        get_field(env, clazz, "mConnectingHandsfreeRfcommChannel", "I");
+    field_mConnectingHandsfreeSocketFd =
+        get_field(env, clazz, "mConnectingHandsfreeSocketFd", "I");
+
+    field_mTimeoutRemainingMs =
+        get_field(env, clazz, "mTimeoutRemainingMs", "I");
+#endif
+}
+
+static void initializeNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return;
+    }
+
+    nat->hcidev = BLUETOOTH_ADAPTER_HCI_NUM;
+
+    env->SetIntField(object, field_mNativeData, (jint)nat);
+    nat->hf_ag_rfcomm_channel =
+        env->GetIntField(object, field_mHandsfreeAgRfcommChannel);
+    nat->hs_ag_rfcomm_channel =
+        env->GetIntField(object, field_mHeadsetAgRfcommChannel);
+    ALOGV("HF RFCOMM channel = %d.", nat->hf_ag_rfcomm_channel);
+    ALOGV("HS RFCOMM channel = %d.", nat->hs_ag_rfcomm_channel);
+
+    /* Set the default values of these to -1. */
+    env->SetIntField(object, field_mConnectingHeadsetRfcommChannel, -1);
+    env->SetIntField(object, field_mConnectingHandsfreeRfcommChannel, -1);
+
+    nat->hf_ag_rfcomm_sock = -1;
+    nat->hs_ag_rfcomm_sock = -1;
+#endif
+}
+
+static void cleanupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        free(nat);
+    }
+#endif
+}
+
+#ifdef HAVE_BLUETOOTH
+
+#if USE_ACCEPT_DIRECTLY==0
+static int set_nb(int sk, bool nb) {
+    int flags = fcntl(sk, F_GETFL);
+    if (flags < 0) {
+        ALOGE("Can't get socket flags with fcntl(): %s (%d)",
+             strerror(errno), errno);
+        close(sk);
+        return -1;
+    }
+    flags &= ~O_NONBLOCK;
+    if (nb) flags |= O_NONBLOCK;
+    int status = fcntl(sk, F_SETFL, flags);
+    if (status < 0) {
+        ALOGE("Can't set socket to nonblocking mode with fcntl(): %s (%d)",
+             strerror(errno), errno);
+        close(sk);
+        return -1;
+    }
+    return 0;
+}
+#endif /*USE_ACCEPT_DIRECTLY==0*/
+
+static int do_accept(JNIEnv* env, jobject object, int ag_fd,
+                     jfieldID out_fd,
+                     jfieldID out_address,
+                     jfieldID out_channel) {
+
+#if USE_ACCEPT_DIRECTLY==0
+    if (set_nb(ag_fd, true) < 0)
+        return -1;
+#endif
+
+    struct sockaddr_rc raddr;
+    int alen = sizeof(raddr);
+    int nsk = TEMP_FAILURE_RETRY(accept(ag_fd, (struct sockaddr *) &raddr, &alen));
+    if (nsk < 0) {
+        ALOGE("Error on accept from socket fd %d: %s (%d).",
+             ag_fd,
+             strerror(errno),
+             errno);
+#if USE_ACCEPT_DIRECTLY==0
+        set_nb(ag_fd, false);
+#endif
+        return -1;
+    }
+
+    env->SetIntField(object, out_fd, nsk);
+    env->SetIntField(object, out_channel, raddr.rc_channel);
+
+    char addr[BTADDR_SIZE];
+    get_bdaddr_as_string(&raddr.rc_bdaddr, addr);
+    env->SetObjectField(object, out_address, env->NewStringUTF(addr));
+
+    ALOGI("Successful accept() on AG socket %d: new socket %d, address %s, RFCOMM channel %d",
+         ag_fd,
+         nsk,
+         addr,
+         raddr.rc_channel);
+#if USE_ACCEPT_DIRECTLY==0
+    set_nb(ag_fd, false);
+#endif
+    return 0;
+}
+
+#if USE_SELECT
+static inline int on_accept_set_fields(JNIEnv* env, jobject object,
+                                       fd_set *rset, int ag_fd,
+                                       jfieldID out_fd,
+                                       jfieldID out_address,
+                                       jfieldID out_channel) {
+
+    env->SetIntField(object, out_channel, -1);
+
+    if (ag_fd >= 0 && FD_ISSET(ag_fd, &rset)) {
+        return do_accept(env, object, ag_fd,
+                         out_fd, out_address, out_channel);
+    }
+    else {
+        ALOGI("fd = %d, FD_ISSET() = %d",
+             ag_fd,
+             FD_ISSET(ag_fd, &rset));
+        if (ag_fd >= 0 && !FD_ISSET(ag_fd, &rset)) {
+            ALOGE("WTF???");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+#endif
+#endif /* HAVE_BLUETOOTH */
+
+static jboolean waitForHandsfreeConnectNative(JNIEnv* env, jobject object,
+                                              jint timeout_ms) {
+//    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+
+    env->SetIntField(object, field_mTimeoutRemainingMs, timeout_ms);
+
+    int n = 0;
+    native_data_t *nat = get_native_data(env, object);
+#if USE_ACCEPT_DIRECTLY
+    if (nat->hf_ag_rfcomm_channel > 0) {
+        ALOGI("Setting HF AG server socket to RFCOMM port %d!",
+             nat->hf_ag_rfcomm_channel);
+        struct timeval tv;
+        int len = sizeof(tv);
+        if (getsockopt(nat->hf_ag_rfcomm_channel,
+                       SOL_SOCKET, SO_RCVTIMEO, &tv, &len) < 0) {
+            ALOGE("getsockopt(%d, SOL_SOCKET, SO_RCVTIMEO): %s (%d)",
+                 nat->hf_ag_rfcomm_channel,
+                 strerror(errno),
+                 errno);
+            return JNI_FALSE;
+        }
+        ALOGI("Current HF AG server socket RCVTIMEO is (%d(s), %d(us))!",
+             (int)tv.tv_sec, (int)tv.tv_usec);
+        if (timeout_ms >= 0) {
+            tv.tv_sec = timeout_ms / 1000;
+            tv.tv_usec = 1000 * (timeout_ms % 1000);
+            if (setsockopt(nat->hf_ag_rfcomm_channel,
+                           SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
+                ALOGE("setsockopt(%d, SOL_SOCKET, SO_RCVTIMEO): %s (%d)",
+                     nat->hf_ag_rfcomm_channel,
+                     strerror(errno),
+                     errno);
+                return JNI_FALSE;
+            }
+            ALOGI("Changed HF AG server socket RCVTIMEO to (%d(s), %d(us))!",
+                 (int)tv.tv_sec, (int)tv.tv_usec);
+        }
+
+        if (!do_accept(env, object, nat->hf_ag_rfcomm_sock,
+                       field_mConnectingHandsfreeSocketFd,
+                       field_mConnectingHandsfreeAddress,
+                       field_mConnectingHandsfreeRfcommChannel))
+        {
+            env->SetIntField(object, field_mTimeoutRemainingMs, 0);
+            return JNI_TRUE;
+        }
+        return JNI_FALSE;
+    }
+#else
+#if USE_SELECT
+    fd_set rset;
+    FD_ZERO(&rset);
+    int cnt = 0;
+    if (nat->hf_ag_rfcomm_channel > 0) {
+        ALOGI("Setting HF AG server socket to RFCOMM port %d!",
+             nat->hf_ag_rfcomm_channel);
+        cnt++;
+        FD_SET(nat->hf_ag_rfcomm_sock, &rset);
+    }
+    if (nat->hs_ag_rfcomm_channel > 0) {
+        ALOGI("Setting HS AG server socket to RFCOMM port %d!",
+             nat->hs_ag_rfcomm_channel);
+        cnt++;
+        FD_SET(nat->hs_ag_rfcomm_sock, &rset);
+    }
+    if (cnt == 0) {
+        ALOGE("Neither HF nor HS listening sockets are open!");
+        return JNI_FALSE;
+    }
+
+    struct timeval to;
+    if (timeout_ms >= 0) {
+        to.tv_sec = timeout_ms / 1000;
+        to.tv_usec = 1000 * (timeout_ms % 1000);
+    }
+    n = TEMP_FAILURE_RETRY(select(
+                   MAX(nat->hf_ag_rfcomm_sock, nat->hs_ag_rfcomm_sock) + 1,
+                   &rset,
+                   NULL,
+                   NULL,
+                   (timeout_ms < 0 ? NULL : &to)));
+    if (timeout_ms > 0) {
+        jint remaining = to.tv_sec*1000 + to.tv_usec/1000;
+        ALOGI("Remaining time %ldms", (long)remaining);
+        env->SetIntField(object, field_mTimeoutRemainingMs,
+                         remaining);
+    }
+
+    ALOGI("listening select() returned %d", n);
+
+    if (n <= 0) {
+        if (n < 0)  {
+            ALOGE("listening select() on RFCOMM sockets: %s (%d)",
+                 strerror(errno),
+                 errno);
+        }
+        return JNI_FALSE;
+    }
+
+    n = on_accept_set_fields(env, object,
+                             &rset, nat->hf_ag_rfcomm_sock,
+                             field_mConnectingHandsfreeSocketFd,
+                             field_mConnectingHandsfreeAddress,
+                             field_mConnectingHandsfreeRfcommChannel);
+
+    n += on_accept_set_fields(env, object,
+                              &rset, nat->hs_ag_rfcomm_sock,
+                              field_mConnectingHeadsetSocketFd,
+                              field_mConnectingHeadsetAddress,
+                              field_mConnectingHeadsetRfcommChannel);
+
+    return !n ? JNI_TRUE : JNI_FALSE;
+#else
+    struct pollfd fds[2];
+    int cnt = 0;
+    if (nat->hf_ag_rfcomm_channel > 0) {
+//        ALOGI("Setting HF AG server socket %d to RFCOMM port %d!",
+//             nat->hf_ag_rfcomm_sock,
+//             nat->hf_ag_rfcomm_channel);
+        fds[cnt].fd = nat->hf_ag_rfcomm_sock;
+        fds[cnt].events = POLLIN | POLLPRI | POLLOUT | POLLERR;
+        cnt++;
+    }
+    if (nat->hs_ag_rfcomm_channel > 0) {
+//        ALOGI("Setting HS AG server socket %d to RFCOMM port %d!",
+//             nat->hs_ag_rfcomm_sock,
+//             nat->hs_ag_rfcomm_channel);
+        fds[cnt].fd = nat->hs_ag_rfcomm_sock;
+        fds[cnt].events = POLLIN | POLLPRI | POLLOUT | POLLERR;
+        cnt++;
+    }
+    if (cnt == 0) {
+        ALOGE("Neither HF nor HS listening sockets are open!");
+        return JNI_FALSE;
+    }
+    n = TEMP_FAILURE_RETRY(poll(fds, cnt, timeout_ms));
+    if (n <= 0) {
+        if (n < 0)  {
+            ALOGE("listening poll() on RFCOMM sockets: %s (%d)",
+                 strerror(errno),
+                 errno);
+        }
+        else {
+            env->SetIntField(object, field_mTimeoutRemainingMs, 0);
+//            ALOGI("listening poll() on RFCOMM socket timed out");
+        }
+        return JNI_FALSE;
+    }
+
+    //ALOGI("listening poll() on RFCOMM socket returned %d", n);
+    int err = 0;
+    for (cnt = 0; cnt < (int)(sizeof(fds)/sizeof(fds[0])); cnt++) {
+        //ALOGI("Poll on fd %d revent = %d.", fds[cnt].fd, fds[cnt].revents);
+        if (fds[cnt].fd == nat->hf_ag_rfcomm_sock) {
+            if (fds[cnt].revents & (POLLIN | POLLPRI | POLLOUT)) {
+                ALOGI("Accepting HF connection.\n");
+                err += do_accept(env, object, fds[cnt].fd,
+                               field_mConnectingHandsfreeSocketFd,
+                               field_mConnectingHandsfreeAddress,
+                               field_mConnectingHandsfreeRfcommChannel);
+                n--;
+            }
+        }
+        else if (fds[cnt].fd == nat->hs_ag_rfcomm_sock) {
+            if (fds[cnt].revents & (POLLIN | POLLPRI | POLLOUT)) {
+                ALOGI("Accepting HS connection.\n");
+                err += do_accept(env, object, fds[cnt].fd,
+                               field_mConnectingHeadsetSocketFd,
+                               field_mConnectingHeadsetAddress,
+                               field_mConnectingHeadsetRfcommChannel);
+                n--;
+            }
+        }
+    } /* for */
+
+    if (n != 0) {
+        ALOGI("Bogus poll(): %d fake pollfd entrie(s)!", n);
+        return JNI_FALSE;
+    }
+
+    return !err ? JNI_TRUE : JNI_FALSE;
+#endif /* USE_SELECT */
+#endif /* USE_ACCEPT_DIRECTLY */
+#else
+    return JNI_FALSE;
+#endif /* HAVE_BLUETOOTH */
+}
+
+static jboolean setUpListeningSocketsNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+
+    nat->hf_ag_rfcomm_sock =
+        setup_listening_socket(nat->hcidev, nat->hf_ag_rfcomm_channel);
+    if (nat->hf_ag_rfcomm_sock < 0)
+        return JNI_FALSE;
+
+    nat->hs_ag_rfcomm_sock =
+        setup_listening_socket(nat->hcidev, nat->hs_ag_rfcomm_channel);
+    if (nat->hs_ag_rfcomm_sock < 0) {
+        close(nat->hf_ag_rfcomm_sock);
+        nat->hf_ag_rfcomm_sock = -1;
+        return JNI_FALSE;
+    }
+
+    return JNI_TRUE;
+#else
+    return JNI_FALSE;
+#endif /* HAVE_BLUETOOTH */
+}
+
+#ifdef HAVE_BLUETOOTH
+static int setup_listening_socket(int dev, int channel) {
+    struct sockaddr_rc laddr;
+    int sk, lm;
+
+    sk = socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
+    if (sk < 0) {
+        ALOGE("Can't create RFCOMM socket");
+        return -1;
+    }
+
+    if (debug_no_encrypt()) {
+        lm = RFCOMM_LM_AUTH;
+    } else {
+        lm = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
+    }
+
+    if (lm && setsockopt(sk, SOL_RFCOMM, RFCOMM_LM, &lm, sizeof(lm)) < 0) {
+        ALOGE("Can't set RFCOMM link mode");
+        close(sk);
+        return -1;
+    }
+
+    laddr.rc_family = AF_BLUETOOTH;
+    bdaddr_t any = android_bluetooth_bdaddr_any();
+    memcpy(&laddr.rc_bdaddr, &any, sizeof(bdaddr_t));
+    laddr.rc_channel = channel;
+
+    if (bind(sk, (struct sockaddr *)&laddr, sizeof(laddr)) < 0) {
+        ALOGE("Can't bind RFCOMM socket");
+        close(sk);
+        return -1;
+    }
+
+    listen(sk, 10);
+    return sk;
+}
+#endif /* HAVE_BLUETOOTH */
+
+/*
+    private native void tearDownListeningSocketsNative();
+*/
+static void tearDownListeningSocketsNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+
+    if (nat->hf_ag_rfcomm_sock > 0) {
+        if (close(nat->hf_ag_rfcomm_sock) < 0) {
+            ALOGE("Could not close HF server socket: %s (%d)\n",
+                 strerror(errno), errno);
+        }
+        nat->hf_ag_rfcomm_sock = -1;
+    }
+    if (nat->hs_ag_rfcomm_sock > 0) {
+        if (close(nat->hs_ag_rfcomm_sock) < 0) {
+            ALOGE("Could not close HS server socket: %s (%d)\n",
+                 strerror(errno), errno);
+        }
+        nat->hs_ag_rfcomm_sock = -1;
+    }
+#endif /* HAVE_BLUETOOTH */
+}
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+
+    {"classInitNative", "()V", (void*)classInitNative},
+    {"initializeNativeDataNative", "()V", (void *)initializeNativeDataNative},
+    {"cleanupNativeDataNative", "()V", (void *)cleanupNativeDataNative},
+
+    {"setUpListeningSocketsNative", "()Z", (void *)setUpListeningSocketsNative},
+    {"tearDownListeningSocketsNative", "()V", (void *)tearDownListeningSocketsNative},
+    {"waitForHandsfreeConnectNative", "(I)Z", (void *)waitForHandsfreeConnectNative},
+};
+
+int register_android_bluetooth_BluetoothAudioGateway(JNIEnv *env) {
+    return AndroidRuntime::registerNativeMethods(env,
+            "android/bluetooth/BluetoothAudioGateway", sMethods,
+            NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/jni/android_bluetooth_BluetoothSocket.cpp b/core/jni/android_bluetooth_BluetoothSocket.cpp
new file mode 100644
index 0000000..d9ff36a
--- /dev/null
+++ b/core/jni/android_bluetooth_BluetoothSocket.cpp
@@ -0,0 +1,588 @@
+/*
+ * Copyright 2009, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "BluetoothSocket.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_bluetooth_c.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "JNIHelp.h"
+#include "utils/Log.h"
+#include "cutils/abort_socket.h"
+
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/rfcomm.h>
+#include <bluetooth/l2cap.h>
+#include <bluetooth/sco.h>
+#endif
+
+#define TYPE_AS_STR(t) \
+    ((t) == TYPE_RFCOMM ? "RFCOMM" : ((t) == TYPE_SCO ? "SCO" : "L2CAP"))
+
+namespace android {
+
+static jfieldID  field_mAuth;     /* read-only */
+static jfieldID  field_mEncrypt;  /* read-only */
+static jfieldID  field_mType;     /* read-only */
+static jfieldID  field_mAddress;  /* read-only */
+static jfieldID  field_mPort;     /* read-only */
+static jfieldID  field_mSocketData;
+static jmethodID method_BluetoothSocket_ctor;
+static jclass    class_BluetoothSocket;
+
+/* Keep TYPE_RFCOMM etc in sync with BluetoothSocket.java */
+static const int TYPE_RFCOMM = 1;
+static const int TYPE_SCO = 2;
+static const int TYPE_L2CAP = 3;  // TODO: Test l2cap code paths
+
+static const int RFCOMM_SO_SNDBUF = 70 * 1024;  // 70 KB send buffer
+
+static void abortNative(JNIEnv *env, jobject obj);
+static void destroyNative(JNIEnv *env, jobject obj);
+
+static struct asocket *get_socketData(JNIEnv *env, jobject obj) {
+    struct asocket *s =
+            (struct asocket *) env->GetIntField(obj, field_mSocketData);
+    if (!s)
+        jniThrowException(env, "java/io/IOException", "null socketData");
+    return s;
+}
+
+static void initSocketFromFdNative(JNIEnv *env, jobject obj, jint fd) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    struct asocket *s = asocket_init(fd);
+
+    if (!s) {
+        ALOGV("asocket_init() failed, throwing");
+        jniThrowIOException(env, errno);
+        return;
+    }
+
+    env->SetIntField(obj, field_mSocketData, (jint)s);
+
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static void initSocketNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int fd;
+    int lm = 0;
+    int sndbuf;
+    jboolean auth;
+    jboolean encrypt;
+    jint type;
+
+    type = env->GetIntField(obj, field_mType);
+
+    switch (type) {
+    case TYPE_RFCOMM:
+        fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
+        break;
+    case TYPE_SCO:
+        fd = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_SCO);
+        break;
+    case TYPE_L2CAP:
+        fd = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);
+        break;
+    default:
+        jniThrowIOException(env, ENOSYS);
+        return;
+    }
+
+    if (fd < 0) {
+        ALOGV("socket() failed, throwing");
+        jniThrowIOException(env, errno);
+        return;
+    }
+
+    auth = env->GetBooleanField(obj, field_mAuth);
+    encrypt = env->GetBooleanField(obj, field_mEncrypt);
+
+    /* kernel does not yet support LM for SCO */
+    switch (type) {
+    case TYPE_RFCOMM:
+        lm |= auth ? RFCOMM_LM_AUTH : 0;
+        lm |= encrypt ? RFCOMM_LM_ENCRYPT : 0;
+        lm |= (auth && encrypt) ? RFCOMM_LM_SECURE : 0;
+        break;
+    case TYPE_L2CAP:
+        lm |= auth ? L2CAP_LM_AUTH : 0;
+        lm |= encrypt ? L2CAP_LM_ENCRYPT : 0;
+        lm |= (auth && encrypt) ? L2CAP_LM_SECURE : 0;
+        break;
+    }
+
+    if (lm) {
+        if (setsockopt(fd, SOL_RFCOMM, RFCOMM_LM, &lm, sizeof(lm))) {
+            ALOGV("setsockopt(RFCOMM_LM) failed, throwing");
+            jniThrowIOException(env, errno);
+            return;
+        }
+    }
+
+    if (type == TYPE_RFCOMM) {
+        sndbuf = RFCOMM_SO_SNDBUF;
+        if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &sndbuf, sizeof(sndbuf))) {
+            ALOGV("setsockopt(SO_SNDBUF) failed, throwing");
+            jniThrowIOException(env, errno);
+            return;
+        }
+    }
+
+    ALOGV("...fd %d created (%s, lm = %x)", fd, TYPE_AS_STR(type), lm);
+
+    initSocketFromFdNative(env, obj, fd);
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static void connectNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int ret;
+    jint type;
+    const char *c_address;
+    jstring address;
+    bdaddr_t bdaddress;
+    socklen_t addr_sz;
+    struct sockaddr *addr;
+    struct asocket *s = get_socketData(env, obj);
+    int retry = 0;
+
+    if (!s)
+        return;
+
+    type = env->GetIntField(obj, field_mType);
+
+    /* parse address into bdaddress */
+    address = (jstring) env->GetObjectField(obj, field_mAddress);
+    c_address = env->GetStringUTFChars(address, NULL);
+    if (get_bdaddr(c_address, &bdaddress)) {
+        env->ReleaseStringUTFChars(address, c_address);
+        jniThrowIOException(env, EINVAL);
+        return;
+    }
+    env->ReleaseStringUTFChars(address, c_address);
+
+    switch (type) {
+    case TYPE_RFCOMM:
+        struct sockaddr_rc addr_rc;
+        addr = (struct sockaddr *)&addr_rc;
+        addr_sz = sizeof(addr_rc);
+
+        memset(addr, 0, addr_sz);
+        addr_rc.rc_family = AF_BLUETOOTH;
+        addr_rc.rc_channel = env->GetIntField(obj, field_mPort);
+        memcpy(&addr_rc.rc_bdaddr, &bdaddress, sizeof(bdaddr_t));
+
+        break;
+    case TYPE_SCO:
+        struct sockaddr_sco addr_sco;
+        addr = (struct sockaddr *)&addr_sco;
+        addr_sz = sizeof(addr_sco);
+
+        memset(addr, 0, addr_sz);
+        addr_sco.sco_family = AF_BLUETOOTH;
+        memcpy(&addr_sco.sco_bdaddr, &bdaddress, sizeof(bdaddr_t));
+
+        break;
+    case TYPE_L2CAP:
+        struct sockaddr_l2 addr_l2;
+        addr = (struct sockaddr *)&addr_l2;
+        addr_sz = sizeof(addr_l2);
+
+        memset(addr, 0, addr_sz);
+        addr_l2.l2_family = AF_BLUETOOTH;
+        addr_l2.l2_psm = env->GetIntField(obj, field_mPort);
+        memcpy(&addr_l2.l2_bdaddr, &bdaddress, sizeof(bdaddr_t));
+
+        break;
+    default:
+        jniThrowIOException(env, ENOSYS);
+        return;
+    }
+
+connect:
+    ret = asocket_connect(s, addr, addr_sz, -1);
+    ALOGV("...connect(%d, %s) = %d (errno %d)",
+            s->fd, TYPE_AS_STR(type), ret, errno);
+
+    if (ret && errno == EALREADY && retry < 2) {
+        /* workaround for bug 5082381 (EALREADY on ACL collision):
+         * retry the connect. Unfortunately we have to create a new fd.
+         * It's not ideal to switch the fd underneath the object, but
+         * is currently safe */
+        ALOGD("Hit bug 5082381 (EALREADY on ACL collision), trying workaround");
+        usleep(100000);
+        retry++;
+        abortNative(env, obj);
+        destroyNative(env, obj);
+        initSocketNative(env, obj);
+        if (env->ExceptionOccurred()) {
+            return;
+        }
+        goto connect;
+    }
+    if (!ret && retry > 0)
+        ALOGD("...workaround ok");
+
+    if (ret)
+        jniThrowIOException(env, errno);
+
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+/* Returns errno instead of throwing, so java can check errno */
+static int bindListenNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    jint type;
+    socklen_t addr_sz;
+    struct sockaddr *addr;
+    bdaddr_t bdaddr = android_bluetooth_bdaddr_any();
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return EINVAL;
+
+    type = env->GetIntField(obj, field_mType);
+
+    switch (type) {
+    case TYPE_RFCOMM:
+        struct sockaddr_rc addr_rc;
+        addr = (struct sockaddr *)&addr_rc;
+        addr_sz = sizeof(addr_rc);
+
+        memset(addr, 0, addr_sz);
+        addr_rc.rc_family = AF_BLUETOOTH;
+        addr_rc.rc_channel = env->GetIntField(obj, field_mPort);
+        memcpy(&addr_rc.rc_bdaddr, &bdaddr, sizeof(bdaddr_t));
+        break;
+    case TYPE_SCO:
+        struct sockaddr_sco addr_sco;
+        addr = (struct sockaddr *)&addr_sco;
+        addr_sz = sizeof(addr_sco);
+
+        memset(addr, 0, addr_sz);
+        addr_sco.sco_family = AF_BLUETOOTH;
+        memcpy(&addr_sco.sco_bdaddr, &bdaddr, sizeof(bdaddr_t));
+        break;
+    case TYPE_L2CAP:
+        struct sockaddr_l2 addr_l2;
+        addr = (struct sockaddr *)&addr_l2;
+        addr_sz = sizeof(addr_l2);
+
+        memset(addr, 0, addr_sz);
+        addr_l2.l2_family = AF_BLUETOOTH;
+        addr_l2.l2_psm = env->GetIntField(obj, field_mPort);
+        memcpy(&addr_l2.l2_bdaddr, &bdaddr, sizeof(bdaddr_t));
+        break;
+    default:
+        return ENOSYS;
+    }
+
+    if (bind(s->fd, addr, addr_sz)) {
+        ALOGV("...bind(%d) gave errno %d", s->fd, errno);
+        return errno;
+    }
+
+    if (listen(s->fd, 1)) {
+        ALOGV("...listen(%d) gave errno %d", s->fd, errno);
+        return errno;
+    }
+
+    ALOGV("...bindListenNative(%d) success", s->fd);
+
+    return 0;
+
+#endif
+    return ENOSYS;
+}
+
+static jobject acceptNative(JNIEnv *env, jobject obj, int timeout) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int fd;
+    jint type;
+    struct sockaddr *addr;
+    socklen_t addr_sz;
+    jstring addr_jstr;
+    char addr_cstr[BTADDR_SIZE];
+    bdaddr_t *bdaddr;
+    jboolean auth;
+    jboolean encrypt;
+
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return NULL;
+
+    type = env->GetIntField(obj, field_mType);
+
+    switch (type) {
+    case TYPE_RFCOMM:
+        struct sockaddr_rc addr_rc;
+        addr = (struct sockaddr *)&addr_rc;
+        addr_sz = sizeof(addr_rc);
+        bdaddr = &addr_rc.rc_bdaddr;
+        memset(addr, 0, addr_sz);
+        break;
+    case TYPE_SCO:
+        struct sockaddr_sco addr_sco;
+        addr = (struct sockaddr *)&addr_sco;
+        addr_sz = sizeof(addr_sco);
+        bdaddr = &addr_sco.sco_bdaddr;
+        memset(addr, 0, addr_sz);
+        break;
+    case TYPE_L2CAP:
+        struct sockaddr_l2 addr_l2;
+        addr = (struct sockaddr *)&addr_l2;
+        addr_sz = sizeof(addr_l2);
+        bdaddr = &addr_l2.l2_bdaddr;
+        memset(addr, 0, addr_sz);
+        break;
+    default:
+        jniThrowIOException(env, ENOSYS);
+        return NULL;
+    }
+
+    fd = asocket_accept(s, addr, &addr_sz, timeout);
+
+    ALOGV("...accept(%d, %s) = %d (errno %d)",
+            s->fd, TYPE_AS_STR(type), fd, errno);
+
+    if (fd < 0) {
+        jniThrowIOException(env, errno);
+        return NULL;
+    }
+
+    /* Connected - return new BluetoothSocket */
+    auth = env->GetBooleanField(obj, field_mAuth);
+    encrypt = env->GetBooleanField(obj, field_mEncrypt);
+
+    get_bdaddr_as_string(bdaddr, addr_cstr);
+
+    addr_jstr = env->NewStringUTF(addr_cstr);
+    return env->NewObject(class_BluetoothSocket, method_BluetoothSocket_ctor,
+            type, fd, auth, encrypt, addr_jstr, -1);
+
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return NULL;
+}
+
+static jint availableNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int available;
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return -1;
+
+    if (ioctl(s->fd, FIONREAD, &available) < 0) {
+        jniThrowIOException(env, errno);
+        return -1;
+    }
+
+    return available;
+
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return -1;
+}
+
+static jint readNative(JNIEnv *env, jobject obj, jbyteArray jb, jint offset,
+        jint length) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int ret;
+    jbyte *b;
+    int sz;
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return -1;
+    if (jb == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+    sz = env->GetArrayLength(jb);
+    if (offset < 0 || length < 0 || offset + length > sz) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    b = env->GetByteArrayElements(jb, NULL);
+    if (b == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    ret = asocket_read(s, &b[offset], length, -1);
+    if (ret < 0) {
+        jniThrowIOException(env, errno);
+        env->ReleaseByteArrayElements(jb, b, JNI_ABORT);
+        return -1;
+    }
+
+    env->ReleaseByteArrayElements(jb, b, 0);
+    return (jint)ret;
+
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return -1;
+}
+
+static jint writeNative(JNIEnv *env, jobject obj, jbyteArray jb, jint offset,
+        jint length) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+
+    int ret, total;
+    jbyte *b;
+    int sz;
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return -1;
+    if (jb == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+    sz = env->GetArrayLength(jb);
+    if (offset < 0 || length < 0 || offset + length > sz) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    b = env->GetByteArrayElements(jb, NULL);
+    if (b == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    total = 0;
+    while (length > 0) {
+        ret = asocket_write(s, &b[offset], length, -1);
+        if (ret < 0) {
+            jniThrowIOException(env, errno);
+            env->ReleaseByteArrayElements(jb, b, JNI_ABORT);
+            return -1;
+        }
+        offset += ret;
+        total += ret;
+        length -= ret;
+    }
+
+    env->ReleaseByteArrayElements(jb, b, JNI_ABORT);  // no need to commit
+    return (jint)total;
+
+#endif
+    jniThrowIOException(env, ENOSYS);
+    return -1;
+}
+
+static void abortNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    struct asocket *s = get_socketData(env, obj);
+
+    if (!s)
+        return;
+
+    asocket_abort(s);
+
+    ALOGV("...asocket_abort(%d) complete", s->fd);
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static void destroyNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    struct asocket *s = get_socketData(env, obj);
+    int fd = s->fd;
+
+    if (!s)
+        return;
+
+    asocket_destroy(s);
+
+    ALOGV("...asocket_destroy(%d) complete", fd);
+    return;
+#endif
+    jniThrowIOException(env, ENOSYS);
+}
+
+static void throwErrnoNative(JNIEnv *env, jobject obj, jint err) {
+    jniThrowIOException(env, err);
+}
+
+static JNINativeMethod sMethods[] = {
+    {"initSocketNative", "()V",  (void*) initSocketNative},
+    {"initSocketFromFdNative", "(I)V",  (void*) initSocketFromFdNative},
+    {"connectNative", "()V", (void *) connectNative},
+    {"bindListenNative", "()I", (void *) bindListenNative},
+    {"acceptNative", "(I)Landroid/bluetooth/BluetoothSocket;", (void *) acceptNative},
+    {"availableNative", "()I",    (void *) availableNative},
+    {"readNative", "([BII)I",    (void *) readNative},
+    {"writeNative", "([BII)I",    (void *) writeNative},
+    {"abortNative", "()V",    (void *) abortNative},
+    {"destroyNative", "()V",    (void *) destroyNative},
+    {"throwErrnoNative", "(I)V",    (void *) throwErrnoNative},
+};
+
+int register_android_bluetooth_BluetoothSocket(JNIEnv *env) {
+    jclass clazz = env->FindClass("android/bluetooth/BluetoothSocket");
+    if (clazz == NULL)
+        return -1;
+    class_BluetoothSocket = (jclass) env->NewGlobalRef(clazz);
+    field_mType = env->GetFieldID(clazz, "mType", "I");
+    field_mAddress = env->GetFieldID(clazz, "mAddress", "Ljava/lang/String;");
+    field_mPort = env->GetFieldID(clazz, "mPort", "I");
+    field_mAuth = env->GetFieldID(clazz, "mAuth", "Z");
+    field_mEncrypt = env->GetFieldID(clazz, "mEncrypt", "Z");
+    field_mSocketData = env->GetFieldID(clazz, "mSocketData", "I");
+    method_BluetoothSocket_ctor = env->GetMethodID(clazz, "<init>", "(IIZZLjava/lang/String;I)V");
+    return AndroidRuntime::registerNativeMethods(env,
+        "android/bluetooth/BluetoothSocket", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
+
diff --git a/core/jni/android_bluetooth_HeadsetBase.cpp b/core/jni/android_bluetooth_HeadsetBase.cpp
new file mode 100644
index 0000000..a773008
--- /dev/null
+++ b/core/jni/android_bluetooth_HeadsetBase.cpp
@@ -0,0 +1,697 @@
+/*
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "BT HSHFP"
+
+#include "android_bluetooth_common.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/poll.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/rfcomm.h>
+#include <bluetooth/sco.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+static jfieldID field_mNativeData;
+static jfieldID field_mAddress;
+static jfieldID field_mRfcommChannel;
+static jfieldID field_mTimeoutRemainingMs;
+
+typedef struct {
+    jstring address;
+    const char *c_address;
+    int rfcomm_channel;
+    int last_read_err;
+    int rfcomm_sock;
+    int rfcomm_connected; // -1 in progress, 0 not connected, 1 connected
+    int rfcomm_sock_flags;
+} native_data_t;
+
+static inline native_data_t * get_native_data(JNIEnv *env, jobject object) {
+    return (native_data_t *)(env->GetIntField(object, field_mNativeData));
+}
+
+static const char CRLF[] = "\xd\xa";
+static const int CRLF_LEN = 2;
+
+static inline int write_error_check(int fd, const char* line, int len) {
+    int ret;
+    errno = 0;
+    ret = write(fd, line, len);
+    if (ret < 0) {
+        ALOGE("%s: write() failed: %s (%d)", __FUNCTION__, strerror(errno),
+             errno);
+        return -1;
+    }
+    if (ret != len) {
+        ALOGE("%s: write() only wrote %d of %d bytes", __FUNCTION__, ret, len);
+        return -1;
+    }
+    return 0;
+}
+
+static int send_line(int fd, const char* line) {
+    int nw;
+    int len = strlen(line);
+    int llen = len + CRLF_LEN * 2 + 1;
+    char *buffer = (char *)calloc(llen, sizeof(char));
+
+    snprintf(buffer, llen, "%s%s%s", CRLF, line, CRLF);
+
+    if (write_error_check(fd, buffer, llen - 1)) {
+        free(buffer);
+        return -1;
+    }
+    free(buffer);
+    return 0;
+}
+
+static int send_chars(int fd, const char* line) {
+    int nw;
+    int len = strlen(line);
+    int llen = len + 1;
+    char *buffer = (char *)calloc(llen, sizeof(char));
+
+    snprintf(buffer, llen, "%s", line);
+
+    if (write_error_check(fd, buffer, llen - 1)) {
+        free(buffer);
+        return -1;
+    }
+    free(buffer);
+    return 0;
+}
+
+static void mask_eighth_bit(char *line)
+{
+   for (;;line++) {
+     if (0 == *line) return;
+     *line &= 0x7F;
+   }
+}
+
+static const char* get_line(int fd, char *buf, int len, int timeout_ms,
+                            int *err) {
+    char *bufit=buf;
+    int fd_flags = fcntl(fd, F_GETFL, 0);
+    struct pollfd pfd;
+
+again:
+    *bufit = 0;
+    pfd.fd = fd;
+    pfd.events = POLLIN;
+    *err = errno = 0;
+    int ret = TEMP_FAILURE_RETRY(poll(&pfd, 1, timeout_ms));
+    if (ret < 0) {
+        ALOGE("poll() error\n");
+        *err = errno;
+        return NULL;
+    }
+    if (ret == 0) {
+        return NULL;
+    }
+
+    if (pfd.revents & (POLLHUP | POLLERR | POLLNVAL)) {
+        ALOGW("RFCOMM poll() returned  success (%d), "
+             "but with an unexpected revents bitmask: %#x\n", ret, pfd.revents);
+        errno = EIO;
+        *err = errno;
+        return NULL;
+    }
+
+    while ((int)(bufit - buf) < (len - 1))
+    {
+        errno = 0;
+        int rc = TEMP_FAILURE_RETRY(read(fd, bufit, 1));
+
+        if (!rc)
+            break;
+
+        if (rc < 0) {
+            if (errno == EBUSY) {
+                ALOGI("read() error %s (%d): repeating read()...",
+                     strerror(errno), errno);
+                goto again;
+            }
+            *err = errno;
+            ALOGE("read() error %s (%d)", strerror(errno), errno);
+            return NULL;
+        }
+
+
+        if (*bufit=='\xd') {
+            break;
+        }
+
+        if (*bufit=='\xa')
+            bufit = buf;
+        else
+            bufit++;
+    }
+
+    *bufit = 0;
+
+    // According to ITU V.250 section 5.1, IA5 7 bit chars are used, 
+    //   the eighth bit or higher bits are ignored if they exists
+    // We mask out only eighth bit, no higher bit, since we do char
+    // string here, not wide char.
+    // We added this processing due to 2 real world problems.
+    // 1 BMW 2005 E46 which sends binary junk
+    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number 
+    //   formater, which was rejected by the AT handler
+    mask_eighth_bit(buf);
+
+    return buf;
+}
+
+// specialized version of get_line that terminates on ESC(abort) or Ctrl-Z
+
+static const char* get_PDUline(int fd, char *buf, int len, int timeout_ms,
+                            int *err) {
+    char *bufit=buf;
+    int fd_flags = fcntl(fd, F_GETFL, 0);
+    struct pollfd pfd;
+
+again:
+    *bufit = 0;
+    pfd.fd = fd;
+    pfd.events = POLLIN;
+    *err = errno = 0;
+    int ret = TEMP_FAILURE_RETRY(poll(&pfd, 1, timeout_ms));
+    if (ret < 0) {
+        ALOGE("poll() error\n");
+        *err = errno;
+        return NULL;
+    }
+    if (ret == 0) {
+        return NULL;
+    }
+
+    if (pfd.revents & (POLLHUP | POLLERR | POLLNVAL)) {
+        ALOGW("RFCOMM poll() returned  success (%d), "
+             "but with an unexpected revents bitmask: %#x\n", ret, pfd.revents);
+        errno = EIO;
+        *err = errno;
+        return NULL;
+    }
+
+    while ((int)(bufit - buf) < (len - 1))
+    {
+        errno = 0;
+        int rc = TEMP_FAILURE_RETRY(read(fd, bufit, 1));
+
+        if (!rc)
+            break;
+
+        if (rc < 0) {
+            if (errno == EBUSY) {
+                ALOGI("read() error %s (%d): repeating read()...",
+                     strerror(errno), errno);
+                goto again;
+            }
+            *err = errno;
+            ALOGE("read() error %s (%d)", strerror(errno), errno);
+            return NULL;
+        }
+
+        if (*bufit == '\x1b') { // ESC  - cause a string containing only ESC to be returned
+            *buf = '\x1b';
+            bufit = buf+1;
+            break;
+        }
+
+        if (*bufit=='\x1a') { // ctrl-z
+            break;
+        }
+
+        bufit++;
+    }
+
+    *bufit = 0;
+
+    // According to ITU V.250 section 5.1, IA5 7 bit chars are used,
+    //   the eighth bit or higher bits are ignored if they exists
+    // We mask out only eighth bit, no higher bit, since we do char
+    // string here, not wide char.
+    // We added this processing due to 2 real world problems.
+    // 1 BMW 2005 E46 which sends binary junk
+    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number
+    //   formater, which was rejected by the AT handler
+    mask_eighth_bit(buf);
+
+    return buf;
+}
+
+#endif
+
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    field_mNativeData = get_field(env, clazz, "mNativeData", "I");
+    field_mAddress = get_field(env, clazz, "mAddress", "Ljava/lang/String;");
+    field_mTimeoutRemainingMs = get_field(env, clazz, "mTimeoutRemainingMs", "I");
+    field_mRfcommChannel = get_field(env, clazz, "mRfcommChannel", "I");
+#endif
+}
+
+static void initializeNativeDataNative(JNIEnv* env, jobject object,
+                                       jint socketFd) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return;
+    }
+
+    env->SetIntField(object, field_mNativeData, (jint)nat);
+    nat->address =
+        (jstring)env->NewGlobalRef(env->GetObjectField(object,
+                                                       field_mAddress));
+    nat->c_address = env->GetStringUTFChars(nat->address, NULL);
+    nat->rfcomm_channel = env->GetIntField(object, field_mRfcommChannel);
+    nat->rfcomm_sock = socketFd;
+    nat->rfcomm_connected = socketFd >= 0;
+    if (nat->rfcomm_connected)
+        ALOGI("%s: ALREADY CONNECTED!", __FUNCTION__);
+#endif
+}
+
+static void cleanupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+        (native_data_t *)env->GetIntField(object, field_mNativeData);
+    env->ReleaseStringUTFChars(nat->address, nat->c_address);
+    env->DeleteGlobalRef(nat->address);
+    if (nat)
+        free(nat);
+#endif
+}
+
+static jboolean connectNative(JNIEnv *env, jobject obj)
+{
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    int lm;
+    struct sockaddr_rc addr;
+    native_data_t *nat = get_native_data(env, obj);
+
+    nat->rfcomm_sock = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
+
+    if (nat->rfcomm_sock < 0) {
+        ALOGE("%s: Could not create RFCOMM socket: %s\n", __FUNCTION__,
+             strerror(errno));
+        return JNI_FALSE;
+    }
+
+    if (debug_no_encrypt()) {
+        lm = RFCOMM_LM_AUTH;
+    } else {
+        lm = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
+    }
+
+    if (lm && setsockopt(nat->rfcomm_sock, SOL_RFCOMM, RFCOMM_LM, &lm,
+                sizeof(lm)) < 0) {
+        ALOGE("%s: Can't set RFCOMM link mode", __FUNCTION__);
+        close(nat->rfcomm_sock);
+        return JNI_FALSE;
+    }
+
+    memset(&addr, 0, sizeof(struct sockaddr_rc));
+    get_bdaddr(nat->c_address, &addr.rc_bdaddr);
+    addr.rc_channel = nat->rfcomm_channel;
+    addr.rc_family = AF_BLUETOOTH;
+    nat->rfcomm_connected = 0;
+    while (nat->rfcomm_connected == 0) {
+        if (connect(nat->rfcomm_sock, (struct sockaddr *)&addr,
+                      sizeof(addr)) < 0) {
+            if (errno == EINTR) continue;
+            ALOGE("%s: connect() failed: %s\n", __FUNCTION__, strerror(errno));
+            close(nat->rfcomm_sock);
+            nat->rfcomm_sock = -1;
+            return JNI_FALSE;
+        } else {
+            nat->rfcomm_connected = 1;
+        }
+    }
+
+    return JNI_TRUE;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jint connectAsyncNative(JNIEnv *env, jobject obj) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    struct sockaddr_rc addr;
+    native_data_t *nat = get_native_data(env, obj);
+
+    if (nat->rfcomm_connected) {
+        ALOGV("RFCOMM socket is already connected or connection is in progress.");
+        return 0;
+    }
+
+    if (nat->rfcomm_sock < 0) {
+        int lm;
+
+        nat->rfcomm_sock = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
+        if (nat->rfcomm_sock < 0) {
+            ALOGE("%s: Could not create RFCOMM socket: %s\n", __FUNCTION__,
+                 strerror(errno));
+            return -1;
+        }
+
+        if (debug_no_encrypt()) {
+            lm = RFCOMM_LM_AUTH;
+        } else {
+            lm = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
+        }
+
+        if (lm && setsockopt(nat->rfcomm_sock, SOL_RFCOMM, RFCOMM_LM, &lm,
+                    sizeof(lm)) < 0) {
+            ALOGE("%s: Can't set RFCOMM link mode", __FUNCTION__);
+            close(nat->rfcomm_sock);
+            return -1;
+        }
+        ALOGI("Created RFCOMM socket fd %d.", nat->rfcomm_sock);
+    }
+
+    memset(&addr, 0, sizeof(struct sockaddr_rc));
+    get_bdaddr(nat->c_address, &addr.rc_bdaddr);
+    addr.rc_channel = nat->rfcomm_channel;
+    addr.rc_family = AF_BLUETOOTH;
+    if (nat->rfcomm_sock_flags >= 0) {
+        nat->rfcomm_sock_flags = fcntl(nat->rfcomm_sock, F_GETFL, 0);
+        if (fcntl(nat->rfcomm_sock,
+                  F_SETFL, nat->rfcomm_sock_flags | O_NONBLOCK) >= 0) {
+            int rc;
+            nat->rfcomm_connected = 0;
+            errno = 0;
+            rc = connect(nat->rfcomm_sock,
+                        (struct sockaddr *)&addr,
+                         sizeof(addr));
+
+            if (rc >= 0) {
+                nat->rfcomm_connected = 1;
+                ALOGI("async connect successful");
+                return 0;
+            }
+            else if (rc < 0) {
+                if (errno == EINPROGRESS || errno == EAGAIN)
+                {
+                    ALOGI("async connect is in progress (%s)",
+                         strerror(errno));
+                    nat->rfcomm_connected = -1;
+                    return 0;
+                }
+                else
+                {
+                    ALOGE("async connect error: %s (%d)", strerror(errno), errno);
+                    close(nat->rfcomm_sock);
+                    nat->rfcomm_sock = -1;
+                    return -errno;
+                }
+            }
+        } // fcntl(nat->rfcomm_sock ...)
+    } // if (nat->rfcomm_sock_flags >= 0)
+#endif
+    return -1;
+}
+
+static jint waitForAsyncConnectNative(JNIEnv *env, jobject obj,
+                                           jint timeout_ms) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    struct sockaddr_rc addr;
+    native_data_t *nat = get_native_data(env, obj);
+
+    env->SetIntField(obj, field_mTimeoutRemainingMs, timeout_ms);
+
+    if (nat->rfcomm_connected > 0) {
+        ALOGI("RFCOMM is already connected!");
+        return 1;
+    }
+
+    if (nat->rfcomm_sock >= 0 && nat->rfcomm_connected == 0) {
+        ALOGI("Re-opening RFCOMM socket.");
+        close(nat->rfcomm_sock);
+        nat->rfcomm_sock = -1;
+    }
+    int ret = connectAsyncNative(env, obj);
+
+    if (ret < 0) {
+        ALOGI("Failed to re-open RFCOMM socket!");
+        return ret;
+    }
+
+    if (nat->rfcomm_sock >= 0) {
+        /* Do an asynchronous select() */
+        int n;
+        fd_set rset, wset;
+        struct timeval to;
+
+        FD_ZERO(&rset);
+        FD_ZERO(&wset);
+        FD_SET(nat->rfcomm_sock, &rset);
+        FD_SET(nat->rfcomm_sock, &wset);
+        if (timeout_ms >= 0) {
+            to.tv_sec = timeout_ms / 1000;
+            to.tv_usec = 1000 * (timeout_ms % 1000);
+        }
+        n = select(nat->rfcomm_sock + 1,
+                   &rset,
+                   &wset,
+                   NULL,
+                   (timeout_ms < 0 ? NULL : &to));
+
+        if (timeout_ms > 0) {
+            jint remaining = to.tv_sec*1000 + to.tv_usec/1000;
+            ALOGV("Remaining time %ldms", (long)remaining);
+            env->SetIntField(obj, field_mTimeoutRemainingMs,
+                             remaining);
+        }
+
+        if (n <= 0) {
+            if (n < 0)  {
+                ALOGE("select() on RFCOMM socket: %s (%d)",
+                     strerror(errno),
+                     errno);
+                return -errno;
+            }
+            return 0;
+        }
+        /* n must be equal to 1 and either rset or wset must have the
+           file descriptor set. */
+        ALOGV("select() returned %d.", n);
+        if (FD_ISSET(nat->rfcomm_sock, &rset) ||
+            FD_ISSET(nat->rfcomm_sock, &wset))
+        {
+            /* A trial async read() will tell us if everything is OK. */
+            {
+                char ch;
+                errno = 0;
+                int nr = TEMP_FAILURE_RETRY(read(nat->rfcomm_sock, &ch, 1));
+                /* It should be that nr != 1 because we just opened a socket
+                   and we haven't sent anything over it for the other side to
+                   respond... but one can't be paranoid enough.
+                */
+                if (nr >= 0 || errno != EAGAIN) {
+                    ALOGE("RFCOMM async connect() error: %s (%d), nr = %d\n",
+                         strerror(errno),
+                         errno,
+                         nr);
+                    /* Clear the rfcomm_connected flag to cause this function
+                       to re-create the socket and re-attempt the connect()
+                       the next time it is called.
+                    */
+                    nat->rfcomm_connected = 0;
+                    /* Restore the blocking properties of the socket. */
+                    fcntl(nat->rfcomm_sock, F_SETFL, nat->rfcomm_sock_flags);
+                    close(nat->rfcomm_sock);
+                    nat->rfcomm_sock = -1;
+                    return -errno;
+                }
+            }
+            /* Restore the blocking properties of the socket. */
+            fcntl(nat->rfcomm_sock, F_SETFL, nat->rfcomm_sock_flags);
+            ALOGI("Successful RFCOMM socket connect.");
+            nat->rfcomm_connected = 1;
+            return 1;
+        }
+    }
+    else ALOGE("RFCOMM socket file descriptor %d is bad!",
+              nat->rfcomm_sock);
+#endif
+    return -1;
+}
+
+static void disconnectNative(JNIEnv *env, jobject obj) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, obj);
+    if (nat->rfcomm_sock >= 0) {
+        close(nat->rfcomm_sock);
+        nat->rfcomm_sock = -1;
+        nat->rfcomm_connected = 0;
+    }
+#endif
+}
+
+static void pretty_log_urc(const char *urc) {
+    size_t i;
+    bool in_line_break = false;
+    char *buf = (char *)calloc(strlen(urc) + 1, sizeof(char));
+
+    strcpy(buf, urc);
+    for (i = 0; i < strlen(buf); i++) {
+        switch(buf[i]) {
+        case '\r':
+        case '\n':
+            in_line_break = true;
+            buf[i] = ' ';
+            break;
+        default:
+            if (in_line_break) {
+                in_line_break = false;
+                buf[i-1] = '\n';
+            }
+        }
+    }
+    IF_ALOGV() ALOG(LOG_VERBOSE, "Bluetooth AT sent", "%s", buf);
+
+    free(buf);
+}
+
+static jboolean sendURCNative(JNIEnv *env, jobject obj, jstring urc) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, obj);
+    if (nat->rfcomm_connected) {
+        const char *c_urc = env->GetStringUTFChars(urc, NULL);
+        jboolean ret = send_line(nat->rfcomm_sock, c_urc) == 0 ? JNI_TRUE : JNI_FALSE;
+        if (ret == JNI_TRUE) pretty_log_urc(c_urc);
+        env->ReleaseStringUTFChars(urc, c_urc);
+        return ret;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sendURCNativeChars(JNIEnv *env, jobject obj, jstring urc) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, obj);
+    if (nat->rfcomm_connected) {
+        const char *c_urc = env->GetStringUTFChars(urc, NULL);
+        jboolean ret = send_chars(nat->rfcomm_sock, c_urc) == 0 ? JNI_TRUE : JNI_FALSE;
+        if (ret == JNI_TRUE) pretty_log_urc(c_urc);
+        env->ReleaseStringUTFChars(urc, c_urc);
+        return ret;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jstring readNative(JNIEnv *env, jobject obj, jint timeout_ms) {
+#ifdef HAVE_BLUETOOTH
+    {
+        native_data_t *nat = get_native_data(env, obj);
+        if (nat->rfcomm_connected) {
+            char buf[256];
+            const char *ret = get_line(nat->rfcomm_sock,
+                                       buf, sizeof(buf),
+                                       timeout_ms,
+                                       &nat->last_read_err);
+            return ret ? env->NewStringUTF(ret) : NULL;
+        }
+        return NULL;
+    }
+#else
+    return NULL;
+#endif
+}
+
+static jstring readNativePDUStream(JNIEnv *env, jobject obj, jint timeout_ms) {
+#ifdef HAVE_BLUETOOTH
+    {
+        native_data_t *nat = get_native_data(env, obj);
+        if (nat->rfcomm_connected) {
+            char buf[256];
+            const char *ret = get_PDUline(nat->rfcomm_sock,
+                                       buf, sizeof(buf),
+                                       timeout_ms,
+                                       &nat->last_read_err);
+            return ret ? env->NewStringUTF(ret) : NULL;
+        }
+        return NULL;
+    }
+#else
+    return NULL;
+#endif
+}
+
+static jint getLastReadStatusNative(JNIEnv *env, jobject obj) {
+#ifdef HAVE_BLUETOOTH
+    {
+        native_data_t *nat = get_native_data(env, obj);
+        if (nat->rfcomm_connected)
+            return (jint)nat->last_read_err;
+        return 0;
+    }
+#else
+    return 0;
+#endif
+}
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"classInitNative", "()V", (void*)classInitNative},
+    {"initializeNativeDataNative", "(I)V", (void *)initializeNativeDataNative},
+    {"cleanupNativeDataNative", "()V", (void *)cleanupNativeDataNative},
+    {"connectNative", "()Z", (void *)connectNative},
+    {"connectAsyncNative", "()I", (void *)connectAsyncNative},
+    {"waitForAsyncConnectNative", "(I)I", (void *)waitForAsyncConnectNative},
+    {"disconnectNative", "()V", (void *)disconnectNative},
+    {"sendURCNative", "(Ljava/lang/String;)Z", (void *)sendURCNative},
+    {"sendURCNativeChars", "(Ljava/lang/String;)Z", (void *)sendURCNativeChars},
+    {"readNative", "(I)Ljava/lang/String;", (void *)readNative},
+    {"readNativePDUStream", "(I)Ljava/lang/String;", (void *)readNativePDUStream},
+    {"getLastReadStatusNative", "()I", (void *)getLastReadStatusNative},
+};
+
+int register_android_bluetooth_HeadsetBase(JNIEnv *env) {
+    return AndroidRuntime::registerNativeMethods(env,
+            "android/bluetooth/HeadsetBase", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/jni/android_bluetooth_c.c b/core/jni/android_bluetooth_c.c
new file mode 100644
index 0000000..b4c6727
--- /dev/null
+++ b/core/jni/android_bluetooth_c.c
@@ -0,0 +1,31 @@
+/*
+** Copyright 2011, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifdef HAVE_BLUETOOTH
+
+#include "android_bluetooth_c.h"
+
+/*
+ * A C helper for creating a bdaddr_t object with the value BDADDR_ANY.
+ * We have to do this in C because the macro BDADDR_ANY in bluetooth.h
+ * is not valid C++ code.
+ */
+bdaddr_t android_bluetooth_bdaddr_any(void)
+{
+  bdaddr_t any = *BDADDR_ANY;
+  return any;
+}
+#endif
diff --git a/core/jni/android_bluetooth_c.h b/core/jni/android_bluetooth_c.h
new file mode 100644
index 0000000..e890244
--- /dev/null
+++ b/core/jni/android_bluetooth_c.h
@@ -0,0 +1,39 @@
+/*
+** Copyright 2010, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef ANDROID_BLUETOOTH_C_H
+#define ANDROID_BLUETOOTH_C_H
+#ifdef HAVE_BLUETOOTH
+
+#include <bluetooth/bluetooth.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * A C helper for creating a bdaddr_t object with the value BDADDR_ANY.
+ * We have to do this in C because the macro BDADDR_ANY in bluetooth.h
+ * is not valid C++ code.
+ */
+bdaddr_t android_bluetooth_bdaddr_any(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*HAVE_BLUETOOTH*/
+#endif /*ANDROID_BLUETOOTH_C_H*/
diff --git a/core/jni/android_bluetooth_common.cpp b/core/jni/android_bluetooth_common.cpp
new file mode 100644
index 0000000..5cdaa6c
--- /dev/null
+++ b/core/jni/android_bluetooth_common.cpp
@@ -0,0 +1,867 @@
+/*
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "bluetooth_common.cpp"
+
+#include "android_bluetooth_common.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <cutils/properties.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+
+static Properties remote_device_properties[] = {
+    {"Address",  DBUS_TYPE_STRING},
+    {"Name", DBUS_TYPE_STRING},
+    {"Icon", DBUS_TYPE_STRING},
+    {"Class", DBUS_TYPE_UINT32},
+    {"UUIDs", DBUS_TYPE_ARRAY},
+    {"Services", DBUS_TYPE_ARRAY},
+    {"Paired", DBUS_TYPE_BOOLEAN},
+    {"Connected", DBUS_TYPE_BOOLEAN},
+    {"Trusted", DBUS_TYPE_BOOLEAN},
+    {"Blocked", DBUS_TYPE_BOOLEAN},
+    {"Alias", DBUS_TYPE_STRING},
+    {"Nodes", DBUS_TYPE_ARRAY},
+    {"Adapter", DBUS_TYPE_OBJECT_PATH},
+    {"LegacyPairing", DBUS_TYPE_BOOLEAN},
+    {"RSSI", DBUS_TYPE_INT16},
+    {"TX", DBUS_TYPE_UINT32},
+    {"Broadcaster", DBUS_TYPE_BOOLEAN}
+};
+
+static Properties adapter_properties[] = {
+    {"Address", DBUS_TYPE_STRING},
+    {"Name", DBUS_TYPE_STRING},
+    {"Class", DBUS_TYPE_UINT32},
+    {"Powered", DBUS_TYPE_BOOLEAN},
+    {"Discoverable", DBUS_TYPE_BOOLEAN},
+    {"DiscoverableTimeout", DBUS_TYPE_UINT32},
+    {"Pairable", DBUS_TYPE_BOOLEAN},
+    {"PairableTimeout", DBUS_TYPE_UINT32},
+    {"Discovering", DBUS_TYPE_BOOLEAN},
+    {"Devices", DBUS_TYPE_ARRAY},
+    {"UUIDs", DBUS_TYPE_ARRAY},
+};
+
+static Properties input_properties[] = {
+    {"Connected", DBUS_TYPE_BOOLEAN},
+};
+
+static Properties pan_properties[] = {
+    {"Connected", DBUS_TYPE_BOOLEAN},
+    {"Interface", DBUS_TYPE_STRING},
+    {"UUID", DBUS_TYPE_STRING},
+};
+
+static Properties health_device_properties[] = {
+    {"MainChannel", DBUS_TYPE_OBJECT_PATH},
+};
+
+static Properties health_channel_properties[] = {
+    {"Type", DBUS_TYPE_STRING},
+    {"Device", DBUS_TYPE_OBJECT_PATH},
+    {"Application", DBUS_TYPE_OBJECT_PATH},
+};
+
+typedef union {
+    char *str_val;
+    int int_val;
+    char **array_val;
+} property_value;
+
+jfieldID get_field(JNIEnv *env, jclass clazz, const char *member,
+                   const char *mtype) {
+    jfieldID field = env->GetFieldID(clazz, member, mtype);
+    if (field == NULL) {
+        ALOGE("Can't find member %s", member);
+    }
+    return field;
+}
+
+typedef struct {
+    void (*user_cb)(DBusMessage *, void *, void *);
+    void *user;
+    void *nat;
+    JNIEnv *env;
+} dbus_async_call_t;
+
+void dbus_func_args_async_callback(DBusPendingCall *call, void *data) {
+
+    dbus_async_call_t *req = (dbus_async_call_t *)data;
+    DBusMessage *msg;
+
+    /* This is guaranteed to be non-NULL, because this function is called only
+       when once the remote method invokation returns. */
+    msg = dbus_pending_call_steal_reply(call);
+
+    if (msg) {
+        if (req->user_cb) {
+            // The user may not deref the message object.
+            req->user_cb(msg, req->user, req->nat);
+        }
+        dbus_message_unref(msg);
+    }
+
+    //dbus_message_unref(req->method);
+    dbus_pending_call_cancel(call);
+    dbus_pending_call_unref(call);
+    free(req);
+}
+
+static dbus_bool_t dbus_func_args_async_valist(JNIEnv *env,
+                                        DBusConnection *conn,
+                                        int timeout_ms,
+                                        void (*user_cb)(DBusMessage *,
+                                                        void *,
+                                                        void*),
+                                        void *user,
+                                        void *nat,
+                                        const char *path,
+                                        const char *ifc,
+                                        const char *func,
+                                        int first_arg_type,
+                                        va_list args) {
+    DBusMessage *msg = NULL;
+    const char *name;
+    dbus_async_call_t *pending;
+    dbus_bool_t reply = FALSE;
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC, path, ifc, func);
+
+    if (msg == NULL) {
+        ALOGE("Could not allocate D-Bus message object!");
+        goto done;
+    }
+
+    /* append arguments */
+    if (!dbus_message_append_args_valist(msg, first_arg_type, args)) {
+        ALOGE("Could not append argument to method call!");
+        goto done;
+    }
+
+    /* Make the call. */
+    pending = (dbus_async_call_t *)malloc(sizeof(dbus_async_call_t));
+    if (pending) {
+        DBusPendingCall *call;
+
+        pending->env = env;
+        pending->user_cb = user_cb;
+        pending->user = user;
+        pending->nat = nat;
+        //pending->method = msg;
+
+        reply = dbus_connection_send_with_reply(conn, msg,
+                                                &call,
+                                                timeout_ms);
+        if (reply == TRUE) {
+            dbus_pending_call_set_notify(call,
+                                         dbus_func_args_async_callback,
+                                         pending,
+                                         NULL);
+        }
+    }
+
+done:
+    if (msg) dbus_message_unref(msg);
+    return reply;
+}
+
+dbus_bool_t dbus_func_args_async(JNIEnv *env,
+                                 DBusConnection *conn,
+                                 int timeout_ms,
+                                 void (*reply)(DBusMessage *, void *, void*),
+                                 void *user,
+                                 void *nat,
+                                 const char *path,
+                                 const char *ifc,
+                                 const char *func,
+                                 int first_arg_type,
+                                 ...) {
+    dbus_bool_t ret;
+    va_list lst;
+    va_start(lst, first_arg_type);
+
+    ret = dbus_func_args_async_valist(env, conn,
+                                      timeout_ms,
+                                      reply, user, nat,
+                                      path, ifc, func,
+                                      first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+// If err is NULL, then any errors will be ALOGE'd, and free'd and the reply
+// will be NULL.
+// If err is not NULL, then it is assumed that dbus_error_init was already
+// called, and error's will be returned to the caller without logging. The
+// return value is NULL iff an error was set. The client must free the error if
+// set.
+DBusMessage * dbus_func_args_timeout_valist(JNIEnv *env,
+                                            DBusConnection *conn,
+                                            int timeout_ms,
+                                            DBusError *err,
+                                            const char *path,
+                                            const char *ifc,
+                                            const char *func,
+                                            int first_arg_type,
+                                            va_list args) {
+
+    DBusMessage *msg = NULL, *reply = NULL;
+    const char *name;
+    bool return_error = (err != NULL);
+
+    if (!return_error) {
+        err = (DBusError*)malloc(sizeof(DBusError));
+        dbus_error_init(err);
+    }
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC, path, ifc, func);
+
+    if (msg == NULL) {
+        ALOGE("Could not allocate D-Bus message object!");
+        goto done;
+    }
+
+    /* append arguments */
+    if (!dbus_message_append_args_valist(msg, first_arg_type, args)) {
+        ALOGE("Could not append argument to method call!");
+        goto done;
+    }
+
+    /* Make the call. */
+    reply = dbus_connection_send_with_reply_and_block(conn, msg, timeout_ms, err);
+    if (!return_error && dbus_error_is_set(err)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(err, msg);
+    }
+
+done:
+    if (!return_error) {
+        free(err);
+    }
+    if (msg) dbus_message_unref(msg);
+    return reply;
+}
+
+DBusMessage * dbus_func_args_timeout(JNIEnv *env,
+                                     DBusConnection *conn,
+                                     int timeout_ms,
+                                     const char *path,
+                                     const char *ifc,
+                                     const char *func,
+                                     int first_arg_type,
+                                     ...) {
+    DBusMessage *ret;
+    va_list lst;
+    va_start(lst, first_arg_type);
+    ret = dbus_func_args_timeout_valist(env, conn, timeout_ms, NULL,
+                                        path, ifc, func,
+                                        first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+DBusMessage * dbus_func_args(JNIEnv *env,
+                             DBusConnection *conn,
+                             const char *path,
+                             const char *ifc,
+                             const char *func,
+                             int first_arg_type,
+                             ...) {
+    DBusMessage *ret;
+    va_list lst;
+    va_start(lst, first_arg_type);
+    ret = dbus_func_args_timeout_valist(env, conn, -1, NULL,
+                                        path, ifc, func,
+                                        first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+DBusMessage * dbus_func_args_error(JNIEnv *env,
+                                   DBusConnection *conn,
+                                   DBusError *err,
+                                   const char *path,
+                                   const char *ifc,
+                                   const char *func,
+                                   int first_arg_type,
+                                   ...) {
+    DBusMessage *ret;
+    va_list lst;
+    va_start(lst, first_arg_type);
+    ret = dbus_func_args_timeout_valist(env, conn, -1, err,
+                                        path, ifc, func,
+                                        first_arg_type, lst);
+    va_end(lst);
+    return ret;
+}
+
+jint dbus_returns_unixfd(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    jint ret = -1;
+
+    dbus_error_init(&err);
+    if (!dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_UNIX_FD, &ret,
+                               DBUS_TYPE_INVALID)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+    dbus_message_unref(reply);
+    return ret;
+}
+
+
+jint dbus_returns_int32(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    jint ret = -1;
+
+    dbus_error_init(&err);
+    if (!dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_INT32, &ret,
+                               DBUS_TYPE_INVALID)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+    dbus_message_unref(reply);
+    return ret;
+}
+
+jint dbus_returns_uint32(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    jint ret = -1;
+
+    dbus_error_init(&err);
+    if (!dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_UINT32, &ret,
+                               DBUS_TYPE_INVALID)) {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+    dbus_message_unref(reply);
+    return ret;
+}
+
+jstring dbus_returns_string(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    jstring ret = NULL;
+    const char *name;
+
+    dbus_error_init(&err);
+    if (dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_STRING, &name,
+                               DBUS_TYPE_INVALID)) {
+        ret = env->NewStringUTF(name);
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+    dbus_message_unref(reply);
+
+    return ret;
+}
+
+jboolean dbus_returns_boolean(JNIEnv *env, DBusMessage *reply) {
+    DBusError err;
+    jboolean ret = JNI_FALSE;
+    dbus_bool_t val = FALSE;
+
+    dbus_error_init(&err);
+
+    /* Check the return value. */
+    if (dbus_message_get_args(reply, &err,
+                               DBUS_TYPE_BOOLEAN, &val,
+                               DBUS_TYPE_INVALID)) {
+        ret = val == TRUE ? JNI_TRUE : JNI_FALSE;
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+
+    dbus_message_unref(reply);
+    return ret;
+}
+
+static void set_object_array_element(JNIEnv *env, jobjectArray strArray,
+                                     const char *value, int index) {
+    jstring obj;
+    obj = env->NewStringUTF(value);
+    env->SetObjectArrayElement(strArray, index, obj);
+    env->DeleteLocalRef(obj);
+}
+
+jobjectArray dbus_returns_array_of_object_path(JNIEnv *env,
+                                               DBusMessage *reply) {
+
+    DBusError err;
+    char **list;
+    int i, len;
+    jobjectArray strArray = NULL;
+
+    dbus_error_init(&err);
+    if (dbus_message_get_args (reply,
+                               &err,
+                               DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+                               &list, &len,
+                               DBUS_TYPE_INVALID)) {
+        jclass stringClass;
+        jstring classNameStr;
+
+        stringClass = env->FindClass("java/lang/String");
+        strArray = env->NewObjectArray(len, stringClass, NULL);
+
+        for (i = 0; i < len; i++)
+            set_object_array_element(env, strArray, list[i], i);
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+
+    dbus_message_unref(reply);
+    return strArray;
+}
+
+jobjectArray dbus_returns_array_of_strings(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    char **list;
+    int i, len;
+    jobjectArray strArray = NULL;
+
+    dbus_error_init(&err);
+    if (dbus_message_get_args (reply,
+                               &err,
+                               DBUS_TYPE_ARRAY, DBUS_TYPE_STRING,
+                               &list, &len,
+                               DBUS_TYPE_INVALID)) {
+        jclass stringClass;
+        jstring classNameStr;
+
+        //ALOGV("%s: there are %d elements in string array!", __FUNCTION__, len);
+
+        stringClass = env->FindClass("java/lang/String");
+        strArray = env->NewObjectArray(len, stringClass, NULL);
+
+        for (i = 0; i < len; i++)
+            set_object_array_element(env, strArray, list[i], i);
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+
+    dbus_message_unref(reply);
+    return strArray;
+}
+
+jbyteArray dbus_returns_array_of_bytes(JNIEnv *env, DBusMessage *reply) {
+
+    DBusError err;
+    int i, len;
+    jbyte *list;
+    jbyteArray byteArray = NULL;
+
+    dbus_error_init(&err);
+    if (dbus_message_get_args(reply, &err,
+                              DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &list, &len,
+                              DBUS_TYPE_INVALID)) {
+        //ALOGV("%s: there are %d elements in byte array!", __FUNCTION__, len);
+        byteArray = env->NewByteArray(len);
+        if (byteArray)
+            env->SetByteArrayRegion(byteArray, 0, len, list);
+
+    } else {
+        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+    }
+
+    dbus_message_unref(reply);
+    return byteArray;
+}
+
+void append_variant(DBusMessageIter *iter, int type, void *val)
+{
+    DBusMessageIter value_iter;
+    char var_type[2] = { type, '\0'};
+    dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT, var_type, &value_iter);
+    dbus_message_iter_append_basic(&value_iter, type, val);
+    dbus_message_iter_close_container(iter, &value_iter);
+}
+
+static void dict_append_entry(DBusMessageIter *dict,
+                        const char *key, int type, void *val)
+{
+        DBusMessageIter dict_entry;
+        dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+                                                        NULL, &dict_entry);
+
+        dbus_message_iter_append_basic(&dict_entry, DBUS_TYPE_STRING, &key);
+        append_variant(&dict_entry, type, val);
+        dbus_message_iter_close_container(dict, &dict_entry);
+}
+
+static void append_dict_valist(DBusMessageIter *iterator, const char *first_key,
+                                va_list var_args)
+{
+        DBusMessageIter dict;
+        int val_type;
+        const char *val_key;
+        void *val;
+
+        dbus_message_iter_open_container(iterator, DBUS_TYPE_ARRAY,
+                        DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                        DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+                        DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+        val_key = first_key;
+        while (val_key) {
+                val_type = va_arg(var_args, int);
+                val = va_arg(var_args, void *);
+                dict_append_entry(&dict, val_key, val_type, val);
+                val_key = va_arg(var_args, char *);
+        }
+
+        dbus_message_iter_close_container(iterator, &dict);
+}
+
+void append_dict_args(DBusMessage *reply, const char *first_key, ...)
+{
+        DBusMessageIter iter;
+        va_list var_args;
+
+        dbus_message_iter_init_append(reply, &iter);
+
+        va_start(var_args, first_key);
+        append_dict_valist(&iter, first_key, var_args);
+        va_end(var_args);
+}
+
+
+int get_property(DBusMessageIter iter, Properties *properties,
+                  int max_num_properties, int *prop_index, property_value *value, int *len) {
+    DBusMessageIter prop_val, array_val_iter;
+    char *property = NULL;
+    uint32_t array_type;
+    char *str_val;
+    int i, j, type, int_val;
+
+    if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
+        return -1;
+    dbus_message_iter_get_basic(&iter, &property);
+    if (!dbus_message_iter_next(&iter))
+        return -1;
+    if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_VARIANT)
+        return -1;
+    for (i = 0; i <  max_num_properties; i++) {
+        if (!strncmp(property, properties[i].name, strlen(property)))
+            break;
+    }
+    *prop_index = i;
+    if (i == max_num_properties)
+        return -1;
+
+    dbus_message_iter_recurse(&iter, &prop_val);
+    type = properties[*prop_index].type;
+    if (dbus_message_iter_get_arg_type(&prop_val) != type) {
+        ALOGE("Property type mismatch in get_property: %d, expected:%d, index:%d",
+             dbus_message_iter_get_arg_type(&prop_val), type, *prop_index);
+        return -1;
+    }
+
+    switch(type) {
+    case DBUS_TYPE_STRING:
+    case DBUS_TYPE_OBJECT_PATH:
+        dbus_message_iter_get_basic(&prop_val, &value->str_val);
+        *len = 1;
+        break;
+    case DBUS_TYPE_UINT32:
+    case DBUS_TYPE_INT16:
+    case DBUS_TYPE_BOOLEAN:
+        dbus_message_iter_get_basic(&prop_val, &int_val);
+        value->int_val = int_val;
+        *len = 1;
+        break;
+    case DBUS_TYPE_ARRAY:
+        dbus_message_iter_recurse(&prop_val, &array_val_iter);
+        array_type = dbus_message_iter_get_arg_type(&array_val_iter);
+        *len = 0;
+        value->array_val = NULL;
+        if (array_type == DBUS_TYPE_OBJECT_PATH ||
+            array_type == DBUS_TYPE_STRING){
+            j = 0;
+            do {
+               j ++;
+            } while(dbus_message_iter_next(&array_val_iter));
+            dbus_message_iter_recurse(&prop_val, &array_val_iter);
+            // Allocate  an array of char *
+            *len = j;
+            char **tmp = (char **)malloc(sizeof(char *) * *len);
+            if (!tmp)
+                return -1;
+            j = 0;
+            do {
+               dbus_message_iter_get_basic(&array_val_iter, &tmp[j]);
+               j ++;
+            } while(dbus_message_iter_next(&array_val_iter));
+            value->array_val = tmp;
+        }
+        break;
+    default:
+        return -1;
+    }
+    return 0;
+}
+
+void create_prop_array(JNIEnv *env, jobjectArray strArray, Properties *property,
+                       property_value *value, int len, int *array_index ) {
+    char **prop_val = NULL;
+    char buf[32] = {'\0'}, buf1[32] = {'\0'};
+    int i;
+
+    char *name = property->name;
+    int prop_type = property->type;
+
+    set_object_array_element(env, strArray, name, *array_index);
+    *array_index += 1;
+
+    if (prop_type == DBUS_TYPE_UINT32 || prop_type == DBUS_TYPE_INT16) {
+        sprintf(buf, "%d", value->int_val);
+        set_object_array_element(env, strArray, buf, *array_index);
+        *array_index += 1;
+    } else if (prop_type == DBUS_TYPE_BOOLEAN) {
+        sprintf(buf, "%s", value->int_val ? "true" : "false");
+
+        set_object_array_element(env, strArray, buf, *array_index);
+        *array_index += 1;
+    } else if (prop_type == DBUS_TYPE_ARRAY) {
+        // Write the length first
+        sprintf(buf1, "%d", len);
+        set_object_array_element(env, strArray, buf1, *array_index);
+        *array_index += 1;
+
+        prop_val = value->array_val;
+        for (i = 0; i < len; i++) {
+            set_object_array_element(env, strArray, prop_val[i], *array_index);
+            *array_index += 1;
+        }
+    } else {
+        set_object_array_element(env, strArray, (const char *) value->str_val, *array_index);
+        *array_index += 1;
+    }
+}
+
+jobjectArray parse_properties(JNIEnv *env, DBusMessageIter *iter, Properties *properties,
+                              const int max_num_properties) {
+    DBusMessageIter dict_entry, dict;
+    jobjectArray strArray = NULL;
+    property_value value;
+    int i, size = 0,array_index = 0;
+    int len = 0, prop_type = DBUS_TYPE_INVALID, prop_index = -1, type;
+    struct {
+        property_value value;
+        int len;
+        bool used;
+    } values[max_num_properties];
+    int t, j;
+
+    jclass stringClass = env->FindClass("java/lang/String");
+    DBusError err;
+    dbus_error_init(&err);
+
+    for (i = 0; i < max_num_properties; i++) {
+        values[i].used = false;
+    }
+
+    if(dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY)
+        goto failure;
+    dbus_message_iter_recurse(iter, &dict);
+    do {
+        len = 0;
+        if (dbus_message_iter_get_arg_type(&dict) != DBUS_TYPE_DICT_ENTRY)
+            goto failure;
+        dbus_message_iter_recurse(&dict, &dict_entry);
+
+        if (!get_property(dict_entry, properties, max_num_properties, &prop_index,
+                          &value, &len)) {
+            size += 2;
+            if (properties[prop_index].type == DBUS_TYPE_ARRAY)
+                size += len;
+            values[prop_index].value = value;
+            values[prop_index].len = len;
+            values[prop_index].used = true;
+        } else {
+            goto failure;
+        }
+    } while(dbus_message_iter_next(&dict));
+
+    strArray = env->NewObjectArray(size, stringClass, NULL);
+
+    for (i = 0; i < max_num_properties; i++) {
+        if (values[i].used) {
+            create_prop_array(env, strArray, &properties[i], &values[i].value, values[i].len,
+                              &array_index);
+
+            if (properties[i].type == DBUS_TYPE_ARRAY && values[i].used
+                   && values[i].value.array_val != NULL)
+                free(values[i].value.array_val);
+        }
+
+    }
+    return strArray;
+
+failure:
+    if (dbus_error_is_set(&err))
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    for (i = 0; i < max_num_properties; i++)
+        if (properties[i].type == DBUS_TYPE_ARRAY && values[i].used == true
+                                        && values[i].value.array_val != NULL)
+            free(values[i].value.array_val);
+    return NULL;
+}
+
+jobjectArray parse_property_change(JNIEnv *env, DBusMessage *msg,
+                           Properties *properties, int max_num_properties) {
+    DBusMessageIter iter;
+    DBusError err;
+    jobjectArray strArray = NULL;
+    jclass stringClass= env->FindClass("java/lang/String");
+    int len = 0, prop_index = -1;
+    int array_index = 0, size = 0;
+    property_value value;
+
+    dbus_error_init(&err);
+    if (!dbus_message_iter_init(msg, &iter))
+        goto failure;
+
+    if (!get_property(iter, properties, max_num_properties,
+                      &prop_index, &value, &len)) {
+        size += 2;
+        if (properties[prop_index].type == DBUS_TYPE_ARRAY)
+            size += len;
+        strArray = env->NewObjectArray(size, stringClass, NULL);
+
+        create_prop_array(env, strArray, &properties[prop_index],
+                          &value, len, &array_index);
+
+        if (properties[prop_index].type == DBUS_TYPE_ARRAY && value.array_val != NULL)
+             free(value.array_val);
+
+        return strArray;
+    }
+failure:
+    LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+    return NULL;
+}
+
+jobjectArray parse_adapter_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &adapter_properties,
+                    sizeof(adapter_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_remote_device_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &remote_device_properties,
+                    sizeof(remote_device_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_input_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &input_properties,
+                    sizeof(input_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_pan_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &pan_properties,
+                    sizeof(pan_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_adapter_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &adapter_properties,
+                            sizeof(adapter_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_remote_device_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &remote_device_properties,
+                          sizeof(remote_device_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_input_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &input_properties,
+                          sizeof(input_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_health_device_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &health_device_properties,
+                          sizeof(health_device_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_health_device_property_change(JNIEnv *env, DBusMessage *msg) {
+    return parse_property_change(env, msg, (Properties *) &health_device_properties,
+                    sizeof(health_device_properties) / sizeof(Properties));
+}
+
+jobjectArray parse_health_channel_properties(JNIEnv *env, DBusMessageIter *iter) {
+    return parse_properties(env, iter, (Properties *) &health_channel_properties,
+                          sizeof(health_channel_properties) / sizeof(Properties));
+}
+
+int get_bdaddr(const char *str, bdaddr_t *ba) {
+    char *d = ((char *)ba) + 5, *endp;
+    int i;
+    for(i = 0; i < 6; i++) {
+        *d-- = strtol(str, &endp, 16);
+        if (*endp != ':' && i != 5) {
+            memset(ba, 0, sizeof(bdaddr_t));
+            return -1;
+        }
+        str = endp + 1;
+    }
+    return 0;
+}
+
+void get_bdaddr_as_string(const bdaddr_t *ba, char *str) {
+    const uint8_t *b = (const uint8_t *)ba;
+    sprintf(str, "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+            b[5], b[4], b[3], b[2], b[1], b[0]);
+}
+
+bool debug_no_encrypt() {
+    return false;
+#if 0
+    char value[PROPERTY_VALUE_MAX] = "";
+
+    property_get("debug.bt.no_encrypt", value, "");
+    if (!strncmp("true", value, PROPERTY_VALUE_MAX) ||
+        !strncmp("1", value, PROPERTY_VALUE_MAX)) {
+        ALOGD("mandatory bluetooth encryption disabled");
+        return true;
+    } else {
+        return false;
+    }
+#endif
+}
+#endif
+
+} /* namespace android */
diff --git a/core/jni/android_bluetooth_common.h b/core/jni/android_bluetooth_common.h
new file mode 100644
index 0000000..daf4bb2
--- /dev/null
+++ b/core/jni/android_bluetooth_common.h
@@ -0,0 +1,215 @@
+/*
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef ANDROID_BLUETOOTH_COMMON_H
+#define ANDROID_BLUETOOTH_COMMON_H
+
+// Set to 0 to enable verbose bluetooth logging
+#define LOG_NDEBUG 1
+
+#include "jni.h"
+#include "utils/Log.h"
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdint.h>
+#include <sys/poll.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#include <bluetooth/bluetooth.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+#define BLUEZ_DBUS_BASE_PATH      "/org/bluez"
+#define BLUEZ_DBUS_BASE_IFC       "org.bluez"
+#define BLUEZ_ERROR_IFC           "org.bluez.Error"
+
+// It would be nicer to retrieve this from bluez using GetDefaultAdapter,
+// but this is only possible when the adapter is up (and hcid is running).
+// It is much easier just to hardcode bluetooth adapter to hci0
+#define BLUETOOTH_ADAPTER_HCI_NUM 0
+#define BLUEZ_ADAPTER_OBJECT_NAME BLUEZ_DBUS_BASE_PATH "/hci0"
+
+#define BTADDR_SIZE 18   // size of BT address character array (including null)
+
+// size of the dbus event loops pollfd structure, hopefully never to be grown
+#define DEFAULT_INITIAL_POLLFD_COUNT 8
+
+jfieldID get_field(JNIEnv *env,
+                   jclass clazz,
+                   const char *member,
+                   const char *mtype);
+
+// ALOGE and free a D-Bus error
+// Using #define so that __FUNCTION__ resolves usefully
+#define LOG_AND_FREE_DBUS_ERROR_WITH_MSG(err, msg) \
+    {   ALOGE("%s: D-Bus error in %s: %s (%s)", __FUNCTION__, \
+        dbus_message_get_member((msg)), (err)->name, (err)->message); \
+         dbus_error_free((err)); }
+#define LOG_AND_FREE_DBUS_ERROR(err) \
+    {   ALOGE("%s: D-Bus error: %s (%s)", __FUNCTION__, \
+        (err)->name, (err)->message); \
+        dbus_error_free((err)); }
+
+struct event_loop_native_data_t {
+    DBusConnection *conn;
+    const char *adapter;
+
+    /* protects the thread */
+    pthread_mutex_t thread_mutex;
+    pthread_t thread;
+    /* our comms socket */
+    /* mem for the list of sockets to listen to */
+    struct pollfd *pollData;
+    int pollMemberCount;
+    int pollDataSize;
+    /* mem for matching set of dbus watch ptrs */
+    DBusWatch **watchData;
+    /* pair of sockets for event loop control, Reader and Writer */
+    int controlFdR;
+    int controlFdW;
+    /* our vm and env Version for future env generation */
+    JavaVM *vm;
+    int envVer;
+    /* reference to our java self */
+    jobject me;
+    /* flag to indicate if the event loop thread is running */
+    bool running;
+};
+
+struct _Properties {
+    char name[32];
+    int type;
+};
+typedef struct _Properties Properties;
+
+dbus_bool_t dbus_func_args_async(JNIEnv *env,
+                                 DBusConnection *conn,
+                                 int timeout_ms,
+                                 void (*reply)(DBusMessage *, void *, void *),
+                                 void *user,
+                                 void *nat,
+                                 const char *path,
+                                 const char *ifc,
+                                 const char *func,
+                                 int first_arg_type,
+                                 ...);
+
+DBusMessage * dbus_func_args(JNIEnv *env,
+                             DBusConnection *conn,
+                             const char *path,
+                             const char *ifc,
+                             const char *func,
+                             int first_arg_type,
+                             ...);
+
+DBusMessage * dbus_func_args_error(JNIEnv *env,
+                                   DBusConnection *conn,
+                                   DBusError *err,
+                                   const char *path,
+                                   const char *ifc,
+                                   const char *func,
+                                   int first_arg_type,
+                                   ...);
+
+DBusMessage * dbus_func_args_timeout(JNIEnv *env,
+                                     DBusConnection *conn,
+                                     int timeout_ms,
+                                     const char *path,
+                                     const char *ifc,
+                                     const char *func,
+                                     int first_arg_type,
+                                     ...);
+
+DBusMessage * dbus_func_args_timeout_valist(JNIEnv *env,
+                                            DBusConnection *conn,
+                                            int timeout_ms,
+                                            DBusError *err,
+                                            const char *path,
+                                            const char *ifc,
+                                            const char *func,
+                                            int first_arg_type,
+                                            va_list args);
+
+jint dbus_returns_int32(JNIEnv *env, DBusMessage *reply);
+jint dbus_returns_uint32(JNIEnv *env, DBusMessage *reply);
+jint dbus_returns_unixfd(JNIEnv *env, DBusMessage *reply);
+jstring dbus_returns_string(JNIEnv *env, DBusMessage *reply);
+jboolean dbus_returns_boolean(JNIEnv *env, DBusMessage *reply);
+jobjectArray dbus_returns_array_of_strings(JNIEnv *env, DBusMessage *reply);
+jobjectArray dbus_returns_array_of_object_path(JNIEnv *env, DBusMessage *reply);
+jbyteArray dbus_returns_array_of_bytes(JNIEnv *env, DBusMessage *reply);
+
+jobjectArray parse_properties(JNIEnv *env, DBusMessageIter *iter, Properties *properties,
+                              const int max_num_properties);
+jobjectArray parse_property_change(JNIEnv *env, DBusMessage *msg,
+                                   Properties *properties, int max_num_properties);
+jobjectArray parse_adapter_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_remote_device_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_remote_device_property_change(JNIEnv *env, DBusMessage *msg);
+jobjectArray parse_adapter_property_change(JNIEnv *env, DBusMessage *msg);
+jobjectArray parse_input_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_health_device_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_health_channel_properties(JNIEnv *env, DBusMessageIter *iter);
+jobjectArray parse_input_property_change(JNIEnv *env, DBusMessage *msg);
+jobjectArray parse_pan_property_change(JNIEnv *env, DBusMessage *msg);
+jobjectArray parse_health_device_property_change(JNIEnv *env, DBusMessage *msg);
+
+void append_dict_args(DBusMessage *reply, const char *first_key, ...);
+void append_variant(DBusMessageIter *iter, int type, void *val);
+int get_bdaddr(const char *str, bdaddr_t *ba);
+void get_bdaddr_as_string(const bdaddr_t *ba, char *str);
+
+bool debug_no_encrypt();
+
+
+// Result codes from Bluez DBus calls
+#define BOND_RESULT_ERROR                      -1
+#define BOND_RESULT_SUCCESS                     0
+#define BOND_RESULT_AUTH_FAILED                 1
+#define BOND_RESULT_AUTH_REJECTED               2
+#define BOND_RESULT_AUTH_CANCELED               3
+#define BOND_RESULT_REMOTE_DEVICE_DOWN          4
+#define BOND_RESULT_DISCOVERY_IN_PROGRESS       5
+#define BOND_RESULT_AUTH_TIMEOUT                6
+#define BOND_RESULT_REPEATED_ATTEMPTS           7
+
+#define PAN_DISCONNECT_FAILED_NOT_CONNECTED  1000
+#define PAN_CONNECT_FAILED_ALREADY_CONNECTED 1001
+#define PAN_CONNECT_FAILED_ATTEMPT_FAILED    1002
+#define PAN_OPERATION_GENERIC_FAILURE        1003
+#define PAN_OPERATION_SUCCESS                1004
+
+#define INPUT_DISCONNECT_FAILED_NOT_CONNECTED  5000
+#define INPUT_CONNECT_FAILED_ALREADY_CONNECTED 5001
+#define INPUT_CONNECT_FAILED_ATTEMPT_FAILED    5002
+#define INPUT_OPERATION_GENERIC_FAILURE        5003
+#define INPUT_OPERATION_SUCCESS                5004
+
+#define HEALTH_OPERATION_SUCCESS               6000
+#define HEALTH_OPERATION_ERROR                 6001
+#define HEALTH_OPERATION_INVALID_ARGS          6002
+#define HEALTH_OPERATION_GENERIC_FAILURE       6003
+#define HEALTH_OPERATION_NOT_FOUND             6004
+#define HEALTH_OPERATION_NOT_ALLOWED           6005
+
+#endif
+} /* namespace android */
+
+#endif/*ANDROID_BLUETOOTH_COMMON_H*/
diff --git a/core/jni/android_server_BluetoothA2dpService.cpp b/core/jni/android_server_BluetoothA2dpService.cpp
new file mode 100644
index 0000000..d2b6038
--- /dev/null
+++ b/core/jni/android_server_BluetoothA2dpService.cpp
@@ -0,0 +1,465 @@
+/*
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "BluetoothA2dpService.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#endif
+
+namespace android {
+
+#ifdef HAVE_BLUETOOTH
+static jmethodID method_onSinkPropertyChanged;
+static jmethodID method_onConnectSinkResult;
+static jmethodID method_onGetPlayStatusRequest;
+static jfieldID field_mTrackName;
+static jfieldID field_mArtistName;
+static jfieldID field_mAlbumName;
+static jfieldID field_mMediaNumber;
+static jfieldID field_mMediaCount;
+static jfieldID field_mDuration;
+
+typedef struct {
+    JavaVM *vm;
+    int envVer;
+    DBusConnection *conn;
+    jobject me;  // for callbacks to java
+} native_data_t;
+
+static native_data_t *nat = NULL;  // global native data
+static void onConnectSinkResult(DBusMessage *msg, void *user, void *n);
+static void onStatusReply(DBusMessage *msg, void *user, void *n);
+
+static Properties sink_properties[] = {
+        {"State", DBUS_TYPE_STRING},
+        {"Connected", DBUS_TYPE_BOOLEAN},
+        {"Playing", DBUS_TYPE_BOOLEAN},
+      };
+#endif
+
+/* Returns true on success (even if adapter is present but disabled).
+ * Return false if dbus is down, or another serious error (out of memory)
+*/
+static bool initNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return false;
+    }
+    env->GetJavaVM( &(nat->vm) );
+    nat->envVer = env->GetVersion();
+    nat->me = env->NewGlobalRef(object);
+
+    DBusError err;
+    dbus_error_init(&err);
+    dbus_threads_init_default();
+    nat->conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);
+    if (dbus_error_is_set(&err)) {
+        ALOGE("Could not get onto the system bus: %s", err.message);
+        dbus_error_free(&err);
+        return false;
+    }
+    dbus_connection_set_exit_on_disconnect(nat->conn, FALSE);
+#endif  /*HAVE_BLUETOOTH*/
+    return true;
+}
+
+static void cleanupNative(JNIEnv* env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        dbus_connection_close(nat->conn);
+        env->DeleteGlobalRef(nat->me);
+        free(nat);
+        nat = NULL;
+    }
+#endif
+}
+
+static jobjectArray getSinkPropertiesNative(JNIEnv *env, jobject object,
+                                            jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        reply = dbus_func_args_timeout(env,
+                                   nat->conn, -1, c_path,
+                                   "org.bluez.AudioSink", "GetProperties",
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        if (!reply && dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, reply);
+            return NULL;
+        } else if (!reply) {
+            ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return NULL;
+        }
+        DBusMessageIter iter;
+        if (dbus_message_iter_init(reply, &iter))
+            return parse_properties(env, &iter, (Properties *)&sink_properties,
+                                 sizeof(sink_properties) / sizeof(Properties));
+    }
+#endif
+    return NULL;
+}
+
+
+static jboolean connectSinkNative(JNIEnv *env, jobject object, jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onConnectSinkResult, context_path,
+                                    nat, c_path, "org.bluez.AudioSink", "Connect",
+                                    DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectSinkNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                                    c_path, "org.bluez.AudioSink", "Disconnect",
+                                    DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean suspendSinkNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                           c_path, "org.bluez.audio.Sink", "Suspend",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean resumeSinkNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                           c_path, "org.bluez.audio.Sink", "Resume",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean avrcpVolumeUpNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                           c_path, "org.bluez.Control", "VolumeUp",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sendMetaDataNative(JNIEnv *env, jobject obj,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV(__FUNCTION__);
+    if (nat) {
+        jstring title, artist, album, media_number, total_media_count, playing_time;
+        const char *c_title, *c_artist, *c_album, *c_media_number;
+        const char *c_total_media_count, *c_playing_time;
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        title = (jstring) env->GetObjectField(obj, field_mTrackName);
+        artist = (jstring) env->GetObjectField(obj, field_mArtistName);
+        album = (jstring) env->GetObjectField(obj, field_mAlbumName);
+        media_number = (jstring) env->GetObjectField(obj, field_mMediaNumber);
+        total_media_count = (jstring) env->GetObjectField(obj, field_mMediaCount);
+        playing_time = (jstring) env->GetObjectField(obj, field_mDuration);
+
+        c_title = env->GetStringUTFChars(title, NULL);
+        c_artist = env->GetStringUTFChars(artist, NULL);
+        c_album = env->GetStringUTFChars(album, NULL);
+        c_media_number = env->GetStringUTFChars(media_number, NULL);
+        c_total_media_count = env->GetStringUTFChars(total_media_count, NULL);
+        c_playing_time = env->GetStringUTFChars(playing_time, NULL);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdateMetaData",
+                           DBUS_TYPE_STRING, &c_title,
+                           DBUS_TYPE_STRING, &c_artist,
+                           DBUS_TYPE_STRING, &c_album,
+                           DBUS_TYPE_STRING, &c_media_number,
+                           DBUS_TYPE_STRING, &c_total_media_count,
+                           DBUS_TYPE_STRING, &c_playing_time,
+                           DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(title, c_title);
+        env->ReleaseStringUTFChars(artist, c_artist);
+        env->ReleaseStringUTFChars(album, c_album);
+        env->ReleaseStringUTFChars(media_number, c_media_number);
+        env->ReleaseStringUTFChars(total_media_count, c_total_media_count);
+        env->ReleaseStringUTFChars(playing_time, c_playing_time);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+
+static jboolean sendPlayStatusNative(JNIEnv *env, jobject object, jstring path,
+                                        jint duration, jint position, jint play_status) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV(__FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdatePlayStatus",
+                           DBUS_TYPE_UINT32, &duration,
+                           DBUS_TYPE_UINT32, &position,
+                           DBUS_TYPE_UINT32, &play_status,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sendEventNative(JNIEnv *env, jobject object,
+                                     jstring path, jint event_id, jlong data) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV(__FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdateNotification",
+                           DBUS_TYPE_UINT16, &event_id,
+                           DBUS_TYPE_UINT64, &data,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean avrcpVolumeDownNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, NULL, NULL, nat,
+                           c_path, "org.bluez.Control", "VolumeDown",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+#ifdef HAVE_BLUETOOTH
+DBusHandlerResult a2dp_event_filter(DBusMessage *msg, JNIEnv *env) {
+    DBusError err;
+
+    if (!nat) {
+        ALOGV("... skipping %s\n", __FUNCTION__);
+        ALOGV("... ignored\n");
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+
+    dbus_error_init(&err);
+
+    if (dbus_message_get_type(msg) != DBUS_MESSAGE_TYPE_SIGNAL) {
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+
+    DBusHandlerResult result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    if (dbus_message_is_signal(msg, "org.bluez.AudioSink",
+                                      "PropertyChanged")) {
+        jobjectArray str_array =
+                    parse_property_change(env, msg, (Properties *)&sink_properties,
+                                sizeof(sink_properties) / sizeof(Properties));
+        const char *c_path = dbus_message_get_path(msg);
+        jstring path = env->NewStringUTF(c_path);
+        env->CallVoidMethod(nat->me,
+                            method_onSinkPropertyChanged,
+                            path,
+                            str_array);
+        env->DeleteLocalRef(path);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "GetPlayStatus")) {
+        env->CallVoidMethod(nat->me, method_onGetPlayStatusRequest);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    }else {
+        ALOGV("... ignored");
+    }
+    if (env->ExceptionCheck()) {
+        ALOGE("VM Exception occurred while handling %s.%s (%s) in %s,"
+             " leaving for VM",
+             dbus_message_get_interface(msg), dbus_message_get_member(msg),
+             dbus_message_get_path(msg), __FUNCTION__);
+    }
+
+    return result;
+}
+
+void onConnectSinkResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+
+    bool result = JNI_TRUE;
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+        result = JNI_FALSE;
+    }
+    ALOGV("... Device Path = %s, result = %d", path, result);
+
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onConnectSinkResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onStatusReply(DBusMessage *msg, void *user, void *n) {
+    ALOGV(__FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    DBusError err;
+    dbus_error_init(&err);
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+}
+
+
+#endif
+
+
+static JNINativeMethod sMethods[] = {
+    {"initNative", "()Z", (void *)initNative},
+    {"cleanupNative", "()V", (void *)cleanupNative},
+
+    /* Bluez audio 4.47 API */
+    {"connectSinkNative", "(Ljava/lang/String;)Z", (void *)connectSinkNative},
+    {"disconnectSinkNative", "(Ljava/lang/String;)Z", (void *)disconnectSinkNative},
+    {"suspendSinkNative", "(Ljava/lang/String;)Z", (void*)suspendSinkNative},
+    {"resumeSinkNative", "(Ljava/lang/String;)Z", (void*)resumeSinkNative},
+    {"getSinkPropertiesNative", "(Ljava/lang/String;)[Ljava/lang/Object;",
+                                    (void *)getSinkPropertiesNative},
+    {"avrcpVolumeUpNative", "(Ljava/lang/String;)Z", (void*)avrcpVolumeUpNative},
+    {"avrcpVolumeDownNative", "(Ljava/lang/String;)Z", (void*)avrcpVolumeDownNative},
+    {"sendMetaDataNative", "(Ljava/lang/String;)Z", (void*)sendMetaDataNative},
+    {"sendEventNative", "(Ljava/lang/String;IJ)Z", (void*)sendEventNative},
+    {"sendPlayStatusNative", "(Ljava/lang/String;III)Z", (void*)sendPlayStatusNative},
+};
+
+int register_android_server_BluetoothA2dpService(JNIEnv *env) {
+    jclass clazz = env->FindClass("android/server/BluetoothA2dpService");
+    if (clazz == NULL) {
+        ALOGE("Can't find android/server/BluetoothA2dpService");
+        return -1;
+    }
+
+#ifdef HAVE_BLUETOOTH
+    method_onSinkPropertyChanged = env->GetMethodID(clazz, "onSinkPropertyChanged",
+                                          "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onConnectSinkResult = env->GetMethodID(clazz, "onConnectSinkResult",
+                                                         "(Ljava/lang/String;Z)V");
+    method_onGetPlayStatusRequest = env->GetMethodID(clazz, "onGetPlayStatusRequest",
+                                          "()V");
+    field_mTrackName = env->GetFieldID(clazz, "mTrackName", "Ljava/lang/String;");
+    field_mArtistName = env->GetFieldID(clazz, "mArtistName", "Ljava/lang/String;");
+    field_mAlbumName = env->GetFieldID(clazz, "mAlbumName", "Ljava/lang/String;");
+    field_mMediaNumber = env->GetFieldID(clazz, "mMediaNumber", "Ljava/lang/String;");
+    field_mMediaCount = env->GetFieldID(clazz, "mMediaCount", "Ljava/lang/String;");
+    field_mDuration = env->GetFieldID(clazz, "mDuration", "Ljava/lang/String;");
+#endif
+
+    return AndroidRuntime::registerNativeMethods(env,
+                "android/server/BluetoothA2dpService", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/jni/android_server_BluetoothEventLoop.cpp b/core/jni/android_server_BluetoothEventLoop.cpp
new file mode 100644
index 0000000..aa981fe
--- /dev/null
+++ b/core/jni/android_server_BluetoothEventLoop.cpp
@@ -0,0 +1,1598 @@
+/*
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "BluetoothEventLoop.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "cutils/sockets.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#endif
+
+namespace android {
+
+#define CREATE_DEVICE_ALREADY_EXISTS 1
+#define CREATE_DEVICE_SUCCESS 0
+#define CREATE_DEVICE_FAILED -1
+
+#ifdef HAVE_BLUETOOTH
+static jfieldID field_mNativeData;
+
+static jmethodID method_onPropertyChanged;
+static jmethodID method_onDevicePropertyChanged;
+static jmethodID method_onDeviceFound;
+static jmethodID method_onDeviceDisappeared;
+static jmethodID method_onDeviceCreated;
+static jmethodID method_onDeviceRemoved;
+static jmethodID method_onDeviceDisconnectRequested;
+static jmethodID method_onNetworkDeviceDisconnected;
+static jmethodID method_onNetworkDeviceConnected;
+
+static jmethodID method_onCreatePairedDeviceResult;
+static jmethodID method_onCreateDeviceResult;
+static jmethodID method_onDiscoverServicesResult;
+static jmethodID method_onGetDeviceServiceChannelResult;
+
+static jmethodID method_onRequestPinCode;
+static jmethodID method_onRequestPasskey;
+static jmethodID method_onRequestPasskeyConfirmation;
+static jmethodID method_onRequestPairingConsent;
+static jmethodID method_onDisplayPasskey;
+static jmethodID method_onRequestOobData;
+static jmethodID method_onAgentOutOfBandDataAvailable;
+static jmethodID method_onAgentAuthorize;
+static jmethodID method_onAgentCancel;
+
+static jmethodID method_onInputDevicePropertyChanged;
+static jmethodID method_onInputDeviceConnectionResult;
+static jmethodID method_onPanDevicePropertyChanged;
+static jmethodID method_onPanDeviceConnectionResult;
+static jmethodID method_onHealthDevicePropertyChanged;
+static jmethodID method_onHealthDeviceChannelChanged;
+static jmethodID method_onHealthDeviceConnectionResult;
+
+typedef event_loop_native_data_t native_data_t;
+
+#define EVENT_LOOP_REFS 10
+
+static inline native_data_t * get_native_data(JNIEnv *env, jobject object) {
+    return (native_data_t *)(env->GetIntField(object,
+                                                 field_mNativeData));
+}
+
+native_data_t *get_EventLoop_native_data(JNIEnv *env, jobject object) {
+    return get_native_data(env, object);
+}
+
+#endif
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    ALOGV("%s", __FUNCTION__);
+
+#ifdef HAVE_BLUETOOTH
+    method_onPropertyChanged = env->GetMethodID(clazz, "onPropertyChanged",
+                                                "([Ljava/lang/String;)V");
+    method_onDevicePropertyChanged = env->GetMethodID(clazz,
+                                                      "onDevicePropertyChanged",
+                                                      "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onDeviceFound = env->GetMethodID(clazz, "onDeviceFound",
+                                            "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onDeviceDisappeared = env->GetMethodID(clazz, "onDeviceDisappeared",
+                                                  "(Ljava/lang/String;)V");
+    method_onDeviceCreated = env->GetMethodID(clazz, "onDeviceCreated", "(Ljava/lang/String;)V");
+    method_onDeviceRemoved = env->GetMethodID(clazz, "onDeviceRemoved", "(Ljava/lang/String;)V");
+    method_onDeviceDisconnectRequested = env->GetMethodID(clazz, "onDeviceDisconnectRequested",
+                                                        "(Ljava/lang/String;)V");
+    method_onNetworkDeviceConnected = env->GetMethodID(clazz, "onNetworkDeviceConnected",
+                                                     "(Ljava/lang/String;Ljava/lang/String;I)V");
+    method_onNetworkDeviceDisconnected = env->GetMethodID(clazz, "onNetworkDeviceDisconnected",
+                                                              "(Ljava/lang/String;)V");
+
+    method_onCreatePairedDeviceResult = env->GetMethodID(clazz, "onCreatePairedDeviceResult",
+                                                         "(Ljava/lang/String;I)V");
+    method_onCreateDeviceResult = env->GetMethodID(clazz, "onCreateDeviceResult",
+                                                         "(Ljava/lang/String;I)V");
+    method_onDiscoverServicesResult = env->GetMethodID(clazz, "onDiscoverServicesResult",
+                                                         "(Ljava/lang/String;Z)V");
+
+    method_onAgentAuthorize = env->GetMethodID(clazz, "onAgentAuthorize",
+                                               "(Ljava/lang/String;Ljava/lang/String;I)V");
+    method_onAgentOutOfBandDataAvailable = env->GetMethodID(clazz, "onAgentOutOfBandDataAvailable",
+                                               "(Ljava/lang/String;)Z");
+    method_onAgentCancel = env->GetMethodID(clazz, "onAgentCancel", "()V");
+    method_onRequestPinCode = env->GetMethodID(clazz, "onRequestPinCode",
+                                               "(Ljava/lang/String;I)V");
+    method_onRequestPasskey = env->GetMethodID(clazz, "onRequestPasskey",
+                                               "(Ljava/lang/String;I)V");
+    method_onRequestPasskeyConfirmation = env->GetMethodID(clazz, "onRequestPasskeyConfirmation",
+                                               "(Ljava/lang/String;II)V");
+    method_onRequestPairingConsent = env->GetMethodID(clazz, "onRequestPairingConsent",
+                                               "(Ljava/lang/String;I)V");
+    method_onDisplayPasskey = env->GetMethodID(clazz, "onDisplayPasskey",
+                                               "(Ljava/lang/String;II)V");
+    method_onInputDevicePropertyChanged = env->GetMethodID(clazz, "onInputDevicePropertyChanged",
+                                               "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onInputDeviceConnectionResult = env->GetMethodID(clazz, "onInputDeviceConnectionResult",
+                                               "(Ljava/lang/String;I)V");
+    method_onPanDevicePropertyChanged = env->GetMethodID(clazz, "onPanDevicePropertyChanged",
+                                               "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onPanDeviceConnectionResult = env->GetMethodID(clazz, "onPanDeviceConnectionResult",
+                                               "(Ljava/lang/String;I)V");
+    method_onHealthDeviceConnectionResult = env->GetMethodID(clazz,
+                                                             "onHealthDeviceConnectionResult",
+                                                             "(II)V");
+    method_onHealthDevicePropertyChanged = env->GetMethodID(clazz, "onHealthDevicePropertyChanged",
+                                               "(Ljava/lang/String;[Ljava/lang/String;)V");
+    method_onHealthDeviceChannelChanged = env->GetMethodID(clazz, "onHealthDeviceChannelChanged",
+                                               "(Ljava/lang/String;Ljava/lang/String;Z)V");
+    method_onRequestOobData = env->GetMethodID(clazz, "onRequestOobData",
+                                               "(Ljava/lang/String;I)V");
+
+    field_mNativeData = env->GetFieldID(clazz, "mNativeData", "I");
+#endif
+}
+
+static void initializeNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return;
+    }
+
+    pthread_mutex_init(&(nat->thread_mutex), NULL);
+
+    env->SetIntField(object, field_mNativeData, (jint)nat);
+
+    {
+        DBusError err;
+        dbus_error_init(&err);
+        dbus_threads_init_default();
+        nat->conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);
+        if (dbus_error_is_set(&err)) {
+            ALOGE("%s: Could not get onto the system bus!", __FUNCTION__);
+            dbus_error_free(&err);
+        }
+        dbus_connection_set_exit_on_disconnect(nat->conn, FALSE);
+    }
+#endif
+}
+
+static void cleanupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+            (native_data_t *)env->GetIntField(object, field_mNativeData);
+
+    pthread_mutex_destroy(&(nat->thread_mutex));
+
+    if (nat) {
+        free(nat);
+    }
+#endif
+}
+
+#ifdef HAVE_BLUETOOTH
+static DBusHandlerResult event_filter(DBusConnection *conn, DBusMessage *msg,
+                                      void *data);
+DBusHandlerResult agent_event_filter(DBusConnection *conn,
+                                     DBusMessage *msg,
+                                     void *data);
+static int register_agent(native_data_t *nat,
+                          const char *agent_path, const char *capabilities);
+
+static const DBusObjectPathVTable agent_vtable = {
+    NULL, agent_event_filter, NULL, NULL, NULL, NULL
+};
+
+static unsigned int unix_events_to_dbus_flags(short events) {
+    return (events & DBUS_WATCH_READABLE ? POLLIN : 0) |
+           (events & DBUS_WATCH_WRITABLE ? POLLOUT : 0) |
+           (events & DBUS_WATCH_ERROR ? POLLERR : 0) |
+           (events & DBUS_WATCH_HANGUP ? POLLHUP : 0);
+}
+
+static short dbus_flags_to_unix_events(unsigned int flags) {
+    return (flags & POLLIN ? DBUS_WATCH_READABLE : 0) |
+           (flags & POLLOUT ? DBUS_WATCH_WRITABLE : 0) |
+           (flags & POLLERR ? DBUS_WATCH_ERROR : 0) |
+           (flags & POLLHUP ? DBUS_WATCH_HANGUP : 0);
+}
+
+static jboolean setUpEventLoop(native_data_t *nat) {
+    ALOGV("%s", __FUNCTION__);
+
+    if (nat != NULL && nat->conn != NULL) {
+        dbus_threads_init_default();
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *agent_path = "/android/bluetooth/agent";
+        const char *capabilities = "DisplayYesNo";
+        if (register_agent(nat, agent_path, capabilities) < 0) {
+            dbus_connection_unregister_object_path (nat->conn, agent_path);
+            return JNI_FALSE;
+        }
+
+        // Add a filter for all incoming messages
+        if (!dbus_connection_add_filter(nat->conn, event_filter, nat, NULL)){
+            return JNI_FALSE;
+        }
+
+        // Set which messages will be processed by this dbus connection
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='org.freedesktop.DBus'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Adapter'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Device'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Input'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Network'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".NetworkServer'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Control'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".HealthDevice'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='org.bluez.AudioSink'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
+
+        return JNI_TRUE;
+    }
+    return JNI_FALSE;
+}
+
+
+const char * get_adapter_path(DBusConnection *conn) {
+    DBusMessage *msg = NULL, *reply = NULL;
+    DBusError err;
+    const char *device_path = NULL;
+    int attempt = 0;
+
+    for (attempt = 0; attempt < 1000 && reply == NULL; attempt ++) {
+        msg = dbus_message_new_method_call("org.bluez", "/",
+              "org.bluez.Manager", "DefaultAdapter");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for get_adapter_path!",
+                  __FUNCTION__);
+            return NULL;
+        }
+        dbus_message_append_args(msg, DBUS_TYPE_INVALID);
+        dbus_error_init(&err);
+        reply = dbus_connection_send_with_reply_and_block(conn, msg, -1, &err);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                if (dbus_error_has_name(&err,
+                    "org.freedesktop.DBus.Error.ServiceUnknown")) {
+                    // bluetoothd is still down, retry
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                    usleep(10000);  // 10 ms
+                    continue;
+                } else {
+                    // Some other error we weren't expecting
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                }
+            }
+            goto failed;
+        }
+    }
+    if (attempt == 1000) {
+        ALOGE("Time out while trying to get Adapter path, is bluetoothd up ?");
+        goto failed;
+    }
+
+    if (!dbus_message_get_args(reply, &err, DBUS_TYPE_OBJECT_PATH,
+                               &device_path, DBUS_TYPE_INVALID)
+                               || !device_path){
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        goto failed;
+    }
+    dbus_message_unref(msg);
+    return device_path;
+
+failed:
+    dbus_message_unref(msg);
+    return NULL;
+}
+
+static int register_agent(native_data_t *nat,
+                          const char * agent_path, const char * capabilities)
+{
+    DBusMessage *msg, *reply;
+    DBusError err;
+    dbus_bool_t oob = TRUE;
+
+    if (!dbus_connection_register_object_path(nat->conn, agent_path,
+            &agent_vtable, nat)) {
+        ALOGE("%s: Can't register object path %s for agent!",
+              __FUNCTION__, agent_path);
+        return -1;
+    }
+
+    nat->adapter = get_adapter_path(nat->conn);
+    if (nat->adapter == NULL) {
+        return -1;
+    }
+    msg = dbus_message_new_method_call("org.bluez", nat->adapter,
+          "org.bluez.Adapter", "RegisterAgent");
+    if (!msg) {
+        ALOGE("%s: Can't allocate new method call for agent!",
+              __FUNCTION__);
+        return -1;
+    }
+    dbus_message_append_args(msg, DBUS_TYPE_OBJECT_PATH, &agent_path,
+                             DBUS_TYPE_STRING, &capabilities,
+                             DBUS_TYPE_INVALID);
+
+    dbus_error_init(&err);
+    reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+    dbus_message_unref(msg);
+
+    if (!reply) {
+        ALOGE("%s: Can't register agent!", __FUNCTION__);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        return -1;
+    }
+
+    dbus_message_unref(reply);
+    dbus_connection_flush(nat->conn);
+
+    return 0;
+}
+
+static void tearDownEventLoop(native_data_t *nat) {
+    ALOGV("%s", __FUNCTION__);
+    if (nat != NULL && nat->conn != NULL) {
+
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+        const char * agent_path = "/android/bluetooth/agent";
+
+        msg = dbus_message_new_method_call("org.bluez",
+                                           nat->adapter,
+                                           "org.bluez.Adapter",
+                                           "UnregisterAgent");
+        if (msg != NULL) {
+            dbus_message_append_args(msg, DBUS_TYPE_OBJECT_PATH, &agent_path,
+                                     DBUS_TYPE_INVALID);
+            reply = dbus_connection_send_with_reply_and_block(nat->conn,
+                                                              msg, -1, &err);
+
+            if (!reply) {
+                if (dbus_error_is_set(&err)) {
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                    dbus_error_free(&err);
+                }
+            } else {
+                dbus_message_unref(reply);
+            }
+            dbus_message_unref(msg);
+        } else {
+             ALOGE("%s: Can't create new method call!", __FUNCTION__);
+        }
+
+        dbus_connection_flush(nat->conn);
+        dbus_connection_unregister_object_path(nat->conn, agent_path);
+
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".AudioSink'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Control'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Device'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Input'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Network'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".NetworkServer'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".HealthDevice'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='org.bluez.audio.Manager'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Adapter'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='org.freedesktop.DBus'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+
+        dbus_connection_remove_filter(nat->conn, event_filter, nat);
+    }
+}
+
+
+#define EVENT_LOOP_EXIT 1
+#define EVENT_LOOP_ADD  2
+#define EVENT_LOOP_REMOVE 3
+#define EVENT_LOOP_WAKEUP 4
+
+dbus_bool_t dbusAddWatch(DBusWatch *watch, void *data) {
+    native_data_t *nat = (native_data_t *)data;
+
+    if (dbus_watch_get_enabled(watch)) {
+        // note that we can't just send the watch and inspect it later
+        // because we may get a removeWatch call before this data is reacted
+        // to by our eventloop and remove this watch..  reading the add first
+        // and then inspecting the recently deceased watch would be bad.
+        char control = EVENT_LOOP_ADD;
+        write(nat->controlFdW, &control, sizeof(char));
+
+        int fd = dbus_watch_get_fd(watch);
+        write(nat->controlFdW, &fd, sizeof(int));
+
+        unsigned int flags = dbus_watch_get_flags(watch);
+        write(nat->controlFdW, &flags, sizeof(unsigned int));
+
+        write(nat->controlFdW, &watch, sizeof(DBusWatch*));
+    }
+    return true;
+}
+
+void dbusRemoveWatch(DBusWatch *watch, void *data) {
+    native_data_t *nat = (native_data_t *)data;
+
+    char control = EVENT_LOOP_REMOVE;
+    write(nat->controlFdW, &control, sizeof(char));
+
+    int fd = dbus_watch_get_fd(watch);
+    write(nat->controlFdW, &fd, sizeof(int));
+
+    unsigned int flags = dbus_watch_get_flags(watch);
+    write(nat->controlFdW, &flags, sizeof(unsigned int));
+}
+
+void dbusToggleWatch(DBusWatch *watch, void *data) {
+    if (dbus_watch_get_enabled(watch)) {
+        dbusAddWatch(watch, data);
+    } else {
+        dbusRemoveWatch(watch, data);
+    }
+}
+
+void dbusWakeup(void *data) {
+    native_data_t *nat = (native_data_t *)data;
+
+    char control = EVENT_LOOP_WAKEUP;
+    write(nat->controlFdW, &control, sizeof(char));
+}
+
+static void handleWatchAdd(native_data_t *nat) {
+    DBusWatch *watch;
+    int newFD;
+    unsigned int flags;
+
+    read(nat->controlFdR, &newFD, sizeof(int));
+    read(nat->controlFdR, &flags, sizeof(unsigned int));
+    read(nat->controlFdR, &watch, sizeof(DBusWatch *));
+    short events = dbus_flags_to_unix_events(flags);
+
+    for (int y = 0; y<nat->pollMemberCount; y++) {
+        if ((nat->pollData[y].fd == newFD) &&
+                (nat->pollData[y].events == events)) {
+            ALOGV("DBusWatch duplicate add");
+            return;
+        }
+    }
+    if (nat->pollMemberCount == nat->pollDataSize) {
+        ALOGV("Bluetooth EventLoop poll struct growing");
+        struct pollfd *temp = (struct pollfd *)malloc(
+                sizeof(struct pollfd) * (nat->pollMemberCount+1));
+        if (!temp) {
+            return;
+        }
+        memcpy(temp, nat->pollData, sizeof(struct pollfd) *
+                nat->pollMemberCount);
+        free(nat->pollData);
+        nat->pollData = temp;
+        DBusWatch **temp2 = (DBusWatch **)malloc(sizeof(DBusWatch *) *
+                (nat->pollMemberCount+1));
+        if (!temp2) {
+            return;
+        }
+        memcpy(temp2, nat->watchData, sizeof(DBusWatch *) *
+                nat->pollMemberCount);
+        free(nat->watchData);
+        nat->watchData = temp2;
+        nat->pollDataSize++;
+    }
+    nat->pollData[nat->pollMemberCount].fd = newFD;
+    nat->pollData[nat->pollMemberCount].revents = 0;
+    nat->pollData[nat->pollMemberCount].events = events;
+    nat->watchData[nat->pollMemberCount] = watch;
+    nat->pollMemberCount++;
+}
+
+static void handleWatchRemove(native_data_t *nat) {
+    int removeFD;
+    unsigned int flags;
+
+    read(nat->controlFdR, &removeFD, sizeof(int));
+    read(nat->controlFdR, &flags, sizeof(unsigned int));
+    short events = dbus_flags_to_unix_events(flags);
+
+    for (int y = 0; y < nat->pollMemberCount; y++) {
+        if ((nat->pollData[y].fd == removeFD) &&
+                (nat->pollData[y].events == events)) {
+            int newCount = --nat->pollMemberCount;
+            // copy the last live member over this one
+            nat->pollData[y].fd = nat->pollData[newCount].fd;
+            nat->pollData[y].events = nat->pollData[newCount].events;
+            nat->pollData[y].revents = nat->pollData[newCount].revents;
+            nat->watchData[y] = nat->watchData[newCount];
+            return;
+        }
+    }
+    ALOGW("WatchRemove given with unknown watch");
+}
+
+static void *eventLoopMain(void *ptr) {
+    native_data_t *nat = (native_data_t *)ptr;
+    JNIEnv *env;
+
+    JavaVMAttachArgs args;
+    char name[] = "BT EventLoop";
+    args.version = nat->envVer;
+    args.name = name;
+    args.group = NULL;
+
+    nat->vm->AttachCurrentThread(&env, &args);
+
+    dbus_connection_set_watch_functions(nat->conn, dbusAddWatch,
+            dbusRemoveWatch, dbusToggleWatch, ptr, NULL);
+    dbus_connection_set_wakeup_main_function(nat->conn, dbusWakeup, ptr, NULL);
+
+    nat->running = true;
+
+    while (1) {
+        for (int i = 0; i < nat->pollMemberCount; i++) {
+            if (!nat->pollData[i].revents) {
+                continue;
+            }
+            if (nat->pollData[i].fd == nat->controlFdR) {
+                char data;
+                while (recv(nat->controlFdR, &data, sizeof(char), MSG_DONTWAIT)
+                        != -1) {
+                    switch (data) {
+                    case EVENT_LOOP_EXIT:
+                    {
+                        dbus_connection_set_watch_functions(nat->conn,
+                                NULL, NULL, NULL, NULL, NULL);
+                        tearDownEventLoop(nat);
+                        nat->vm->DetachCurrentThread();
+
+                        int fd = nat->controlFdR;
+                        nat->controlFdR = 0;
+                        close(fd);
+                        return NULL;
+                    }
+                    case EVENT_LOOP_ADD:
+                    {
+                        handleWatchAdd(nat);
+                        break;
+                    }
+                    case EVENT_LOOP_REMOVE:
+                    {
+                        handleWatchRemove(nat);
+                        break;
+                    }
+                    case EVENT_LOOP_WAKEUP:
+                    {
+                        // noop
+                        break;
+                    }
+                    }
+                }
+            } else {
+                short events = nat->pollData[i].revents;
+                unsigned int flags = unix_events_to_dbus_flags(events);
+                dbus_watch_handle(nat->watchData[i], flags);
+                nat->pollData[i].revents = 0;
+                // can only do one - it may have caused a 'remove'
+                break;
+            }
+        }
+        while (dbus_connection_dispatch(nat->conn) ==
+                DBUS_DISPATCH_DATA_REMAINS) {
+        }
+
+        poll(nat->pollData, nat->pollMemberCount, -1);
+    }
+}
+#endif // HAVE_BLUETOOTH
+
+static jboolean startEventLoopNative(JNIEnv *env, jobject object) {
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    event_loop_native_data_t *nat = get_native_data(env, object);
+
+    pthread_mutex_lock(&(nat->thread_mutex));
+
+    nat->running = false;
+
+    if (nat->pollData) {
+        ALOGW("trying to start EventLoop a second time!");
+        pthread_mutex_unlock( &(nat->thread_mutex) );
+        return JNI_FALSE;
+    }
+
+    nat->pollData = (struct pollfd *)calloc(
+            DEFAULT_INITIAL_POLLFD_COUNT, sizeof(struct pollfd));
+    if (!nat->pollData) {
+        ALOGE("out of memory error starting EventLoop!");
+        goto done;
+    }
+
+    nat->watchData = (DBusWatch **)calloc(
+            DEFAULT_INITIAL_POLLFD_COUNT, sizeof(DBusWatch *));
+    if (!nat->watchData) {
+        ALOGE("out of memory error starting EventLoop!");
+        goto done;
+    }
+
+    nat->pollDataSize = DEFAULT_INITIAL_POLLFD_COUNT;
+    nat->pollMemberCount = 1;
+
+    if (socketpair(AF_LOCAL, SOCK_STREAM, 0, &(nat->controlFdR))) {
+        ALOGE("Error getting BT control socket");
+        goto done;
+    }
+    nat->pollData[0].fd = nat->controlFdR;
+    nat->pollData[0].events = POLLIN;
+
+    env->GetJavaVM( &(nat->vm) );
+    nat->envVer = env->GetVersion();
+
+    nat->me = env->NewGlobalRef(object);
+
+    if (setUpEventLoop(nat) != JNI_TRUE) {
+        ALOGE("failure setting up Event Loop!");
+        goto done;
+    }
+
+    pthread_create(&(nat->thread), NULL, eventLoopMain, nat);
+    result = JNI_TRUE;
+
+done:
+    if (JNI_FALSE == result) {
+        if (nat->controlFdW) {
+            close(nat->controlFdW);
+            nat->controlFdW = 0;
+        }
+        if (nat->controlFdR) {
+            close(nat->controlFdR);
+            nat->controlFdR = 0;
+        }
+        if (nat->me) env->DeleteGlobalRef(nat->me);
+        nat->me = NULL;
+        if (nat->pollData) free(nat->pollData);
+        nat->pollData = NULL;
+        if (nat->watchData) free(nat->watchData);
+        nat->watchData = NULL;
+        nat->pollDataSize = 0;
+        nat->pollMemberCount = 0;
+    }
+
+    pthread_mutex_unlock(&(nat->thread_mutex));
+#endif // HAVE_BLUETOOTH
+    return result;
+}
+
+static void stopEventLoopNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+
+    pthread_mutex_lock(&(nat->thread_mutex));
+    if (nat->pollData) {
+        char data = EVENT_LOOP_EXIT;
+        ssize_t t = write(nat->controlFdW, &data, sizeof(char));
+        void *ret;
+        pthread_join(nat->thread, &ret);
+
+        env->DeleteGlobalRef(nat->me);
+        nat->me = NULL;
+        free(nat->pollData);
+        nat->pollData = NULL;
+        free(nat->watchData);
+        nat->watchData = NULL;
+        nat->pollDataSize = 0;
+        nat->pollMemberCount = 0;
+
+        int fd = nat->controlFdW;
+        nat->controlFdW = 0;
+        close(fd);
+    }
+    nat->running = false;
+    pthread_mutex_unlock(&(nat->thread_mutex));
+#endif // HAVE_BLUETOOTH
+}
+
+static jboolean isEventLoopRunningNative(JNIEnv *env, jobject object) {
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+
+    pthread_mutex_lock(&(nat->thread_mutex));
+    if (nat->running) {
+        result = JNI_TRUE;
+    }
+    pthread_mutex_unlock(&(nat->thread_mutex));
+
+#endif // HAVE_BLUETOOTH
+    return result;
+}
+
+#ifdef HAVE_BLUETOOTH
+extern DBusHandlerResult a2dp_event_filter(DBusMessage *msg, JNIEnv *env);
+
+// Called by dbus during WaitForAndDispatchEventNative()
+static DBusHandlerResult event_filter(DBusConnection *conn, DBusMessage *msg,
+                                      void *data) {
+    native_data_t *nat;
+    JNIEnv *env;
+    DBusError err;
+    DBusHandlerResult ret;
+
+    dbus_error_init(&err);
+
+    nat = (native_data_t *)data;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+    if (dbus_message_get_type(msg) != DBUS_MESSAGE_TYPE_SIGNAL) {
+        ALOGV("%s: not interested (not a signal).", __FUNCTION__);
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+
+    ALOGV("%s: Received signal %s:%s from %s", __FUNCTION__,
+        dbus_message_get_interface(msg), dbus_message_get_member(msg),
+        dbus_message_get_path(msg));
+
+    env->PushLocalFrame(EVENT_LOOP_REFS);
+    if (dbus_message_is_signal(msg,
+                               "org.bluez.Adapter",
+                               "DeviceFound")) {
+        char *c_address;
+        DBusMessageIter iter;
+        jobjectArray str_array = NULL;
+        if (dbus_message_iter_init(msg, &iter)) {
+            dbus_message_iter_get_basic(&iter, &c_address);
+            if (dbus_message_iter_next(&iter))
+                str_array =
+                    parse_remote_device_properties(env, &iter);
+        }
+        if (str_array != NULL) {
+            env->CallVoidMethod(nat->me,
+                                method_onDeviceFound,
+                                env->NewStringUTF(c_address),
+                                str_array);
+        } else
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.Adapter",
+                                     "DeviceDisappeared")) {
+        char *c_address;
+        if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_STRING, &c_address,
+                                  DBUS_TYPE_INVALID)) {
+            ALOGV("... address = %s", c_address);
+            env->CallVoidMethod(nat->me, method_onDeviceDisappeared,
+                                env->NewStringUTF(c_address));
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.Adapter",
+                                     "DeviceCreated")) {
+        char *c_object_path;
+        if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_OBJECT_PATH, &c_object_path,
+                                  DBUS_TYPE_INVALID)) {
+            ALOGV("... address = %s", c_object_path);
+            env->CallVoidMethod(nat->me,
+                                method_onDeviceCreated,
+                                env->NewStringUTF(c_object_path));
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.Adapter",
+                                     "DeviceRemoved")) {
+        char *c_object_path;
+        if (dbus_message_get_args(msg, &err,
+                                 DBUS_TYPE_OBJECT_PATH, &c_object_path,
+                                 DBUS_TYPE_INVALID)) {
+           ALOGV("... Object Path = %s", c_object_path);
+           env->CallVoidMethod(nat->me,
+                               method_onDeviceRemoved,
+                               env->NewStringUTF(c_object_path));
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                      "org.bluez.Adapter",
+                                      "PropertyChanged")) {
+        jobjectArray str_array = parse_adapter_property_change(env, msg);
+        if (str_array != NULL) {
+            /* Check if bluetoothd has (re)started, if so update the path. */
+            jstring property =(jstring) env->GetObjectArrayElement(str_array, 0);
+            const char *c_property = env->GetStringUTFChars(property, NULL);
+            if (!strncmp(c_property, "Powered", strlen("Powered"))) {
+                jstring value =
+                    (jstring) env->GetObjectArrayElement(str_array, 1);
+                const char *c_value = env->GetStringUTFChars(value, NULL);
+                if (!strncmp(c_value, "true", strlen("true")))
+                    nat->adapter = get_adapter_path(nat->conn);
+                env->ReleaseStringUTFChars(value, c_value);
+            }
+            env->ReleaseStringUTFChars(property, c_property);
+
+            env->CallVoidMethod(nat->me,
+                              method_onPropertyChanged,
+                              str_array);
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                      "org.bluez.Device",
+                                      "PropertyChanged")) {
+        jobjectArray str_array = parse_remote_device_property_change(env, msg);
+        if (str_array != NULL) {
+            const char *remote_device_path = dbus_message_get_path(msg);
+            env->CallVoidMethod(nat->me,
+                            method_onDevicePropertyChanged,
+                            env->NewStringUTF(remote_device_path),
+                            str_array);
+        } else LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                      "org.bluez.Device",
+                                      "DisconnectRequested")) {
+        const char *remote_device_path = dbus_message_get_path(msg);
+        env->CallVoidMethod(nat->me,
+                            method_onDeviceDisconnectRequested,
+                            env->NewStringUTF(remote_device_path));
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                      "org.bluez.Input",
+                                      "PropertyChanged")) {
+
+        jobjectArray str_array =
+                    parse_input_property_change(env, msg);
+        if (str_array != NULL) {
+            const char *c_path = dbus_message_get_path(msg);
+            env->CallVoidMethod(nat->me,
+                                method_onInputDevicePropertyChanged,
+                                env->NewStringUTF(c_path),
+                                str_array);
+        } else {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        }
+        goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.Network",
+                                     "PropertyChanged")) {
+
+       jobjectArray str_array =
+                   parse_pan_property_change(env, msg);
+       if (str_array != NULL) {
+           const char *c_path = dbus_message_get_path(msg);
+           env->CallVoidMethod(nat->me,
+                               method_onPanDevicePropertyChanged,
+                               env->NewStringUTF(c_path),
+                               str_array);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.NetworkServer",
+                                     "DeviceDisconnected")) {
+       char *c_address;
+       if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_STRING, &c_address,
+                                  DBUS_TYPE_INVALID)) {
+           env->CallVoidMethod(nat->me,
+                               method_onNetworkDeviceDisconnected,
+                               env->NewStringUTF(c_address));
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.NetworkServer",
+                                     "DeviceConnected")) {
+       char *c_address;
+       char *c_iface;
+       uint16_t uuid;
+
+       if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_STRING, &c_address,
+                                  DBUS_TYPE_STRING, &c_iface,
+                                  DBUS_TYPE_UINT16, &uuid,
+                                  DBUS_TYPE_INVALID)) {
+           env->CallVoidMethod(nat->me,
+                               method_onNetworkDeviceConnected,
+                               env->NewStringUTF(c_address),
+                               env->NewStringUTF(c_iface),
+                               uuid);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.HealthDevice",
+                                     "ChannelConnected")) {
+       const char *c_path = dbus_message_get_path(msg);
+       const char *c_channel_path;
+       jboolean exists = JNI_TRUE;
+       if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_OBJECT_PATH, &c_channel_path,
+                                  DBUS_TYPE_INVALID)) {
+           env->CallVoidMethod(nat->me,
+                               method_onHealthDeviceChannelChanged,
+                               env->NewStringUTF(c_path),
+                               env->NewStringUTF(c_channel_path),
+                               exists);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.HealthDevice",
+                                     "ChannelDeleted")) {
+
+       const char *c_path = dbus_message_get_path(msg);
+       const char *c_channel_path;
+       jboolean exists = JNI_FALSE;
+       if (dbus_message_get_args(msg, &err,
+                                  DBUS_TYPE_OBJECT_PATH, &c_channel_path,
+                                  DBUS_TYPE_INVALID)) {
+           env->CallVoidMethod(nat->me,
+                               method_onHealthDeviceChannelChanged,
+                               env->NewStringUTF(c_path),
+                               env->NewStringUTF(c_channel_path),
+                               exists);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    } else if (dbus_message_is_signal(msg,
+                                     "org.bluez.HealthDevice",
+                                     "PropertyChanged")) {
+        jobjectArray str_array =
+                    parse_health_device_property_change(env, msg);
+        if (str_array != NULL) {
+            const char *c_path = dbus_message_get_path(msg);
+            env->CallVoidMethod(nat->me,
+                                method_onHealthDevicePropertyChanged,
+                                env->NewStringUTF(c_path),
+                                str_array);
+       } else {
+           LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+       }
+       goto success;
+    }
+
+    ret = a2dp_event_filter(msg, env);
+    env->PopLocalFrame(NULL);
+    return ret;
+
+success:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+// Called by dbus during WaitForAndDispatchEventNative()
+DBusHandlerResult agent_event_filter(DBusConnection *conn,
+                                     DBusMessage *msg, void *data) {
+    native_data_t *nat = (native_data_t *)data;
+    JNIEnv *env;
+    if (dbus_message_get_type(msg) != DBUS_MESSAGE_TYPE_METHOD_CALL) {
+        ALOGV("%s: not interested (not a method call).", __FUNCTION__);
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+    ALOGI("%s: Received method %s:%s", __FUNCTION__,
+         dbus_message_get_interface(msg), dbus_message_get_member(msg));
+
+    if (nat == NULL) return DBUS_HANDLER_RESULT_HANDLED;
+
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+    env->PushLocalFrame(EVENT_LOOP_REFS);
+
+    if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "Cancel")) {
+        env->CallVoidMethod(nat->me, method_onAgentCancel);
+        // reply
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+            goto failure;
+        }
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(reply);
+        goto success;
+
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "Authorize")) {
+        char *object_path;
+        const char *uuid;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_STRING, &uuid,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for Authorize() method", __FUNCTION__);
+            goto failure;
+        }
+
+        ALOGV("... object_path = %s", object_path);
+        ALOGV("... uuid = %s", uuid);
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onAgentAuthorize,
+                env->NewStringUTF(object_path), env->NewStringUTF(uuid),
+                int(msg));
+
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "OutOfBandAvailable")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for OutOfBandData available() method", __FUNCTION__);
+            goto failure;
+        }
+
+        ALOGV("... object_path = %s", object_path);
+
+        bool available =
+            env->CallBooleanMethod(nat->me, method_onAgentOutOfBandDataAvailable,
+                env->NewStringUTF(object_path));
+
+
+        // reply
+        if (available) {
+            DBusMessage *reply = dbus_message_new_method_return(msg);
+            if (!reply) {
+                ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+                goto failure;
+            }
+            dbus_connection_send(nat->conn, reply, NULL);
+            dbus_message_unref(reply);
+        } else {
+            DBusMessage *reply = dbus_message_new_error(msg,
+                    "org.bluez.Error.DoesNotExist", "OutofBand data not available");
+            if (!reply) {
+                ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+                goto failure;
+            }
+            dbus_connection_send(nat->conn, reply, NULL);
+            dbus_message_unref(reply);
+        }
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestPinCode")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestPinCode() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestPinCode,
+                                       env->NewStringUTF(object_path),
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestPasskey")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestPasskey() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestPasskey,
+                                       env->NewStringUTF(object_path),
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestOobData")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestOobData() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestOobData,
+                                       env->NewStringUTF(object_path),
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "DisplayPasskey")) {
+        char *object_path;
+        uint32_t passkey;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_UINT32, &passkey,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestPasskey() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onDisplayPasskey,
+                                       env->NewStringUTF(object_path),
+                                       passkey,
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestConfirmation")) {
+        char *object_path;
+        uint32_t passkey;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_UINT32, &passkey,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestConfirmation() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestPasskeyConfirmation,
+                                       env->NewStringUTF(object_path),
+                                       passkey,
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+            "org.bluez.Agent", "RequestPairingConsent")) {
+        char *object_path;
+        if (!dbus_message_get_args(msg, NULL,
+                                   DBUS_TYPE_OBJECT_PATH, &object_path,
+                                   DBUS_TYPE_INVALID)) {
+            ALOGE("%s: Invalid arguments for RequestPairingConsent() method", __FUNCTION__);
+            goto failure;
+        }
+
+        dbus_message_ref(msg);  // increment refcount because we pass to java
+        env->CallVoidMethod(nat->me, method_onRequestPairingConsent,
+                                       env->NewStringUTF(object_path),
+                                       int(msg));
+        goto success;
+    } else if (dbus_message_is_method_call(msg,
+                  "org.bluez.Agent", "Release")) {
+        // reply
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply\n", __FUNCTION__);
+            goto failure;
+        }
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(reply);
+        goto success;
+    } else {
+        ALOGV("%s:%s is ignored", dbus_message_get_interface(msg), dbus_message_get_member(msg));
+    }
+
+failure:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+success:
+    env->PopLocalFrame(NULL);
+    return DBUS_HANDLER_RESULT_HANDLED;
+
+}
+#endif
+
+
+#ifdef HAVE_BLUETOOTH
+
+void onCreatePairedDeviceResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *address = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    jstring addr;
+
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    ALOGV("... address = %s", address);
+
+    jint result = BOND_RESULT_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AuthenticationFailed")) {
+            // Pins did not match, or remote device did not respond to pin
+            // request in time
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_AUTH_FAILED;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AuthenticationRejected")) {
+            // We rejected pairing, or the remote side rejected pairing. This
+            // happens if either side presses 'cancel' at the pairing dialog.
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_AUTH_REJECTED;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AuthenticationCanceled")) {
+            // Not sure if this happens
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_AUTH_CANCELED;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.ConnectionAttemptFailed")) {
+            // Other device is not responding at all
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_REMOTE_DEVICE_DOWN;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AlreadyExists")) {
+            // already bonded
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_SUCCESS;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.InProgress") &&
+                   !strcmp(err.message, "Bonding in progress")) {
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            goto done;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.InProgress") &&
+                   !strcmp(err.message, "Discover in progress")) {
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_DISCOVERY_IN_PROGRESS;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.RepeatedAttempts")) {
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_REPEATED_ATTEMPTS;
+        } else if (!strcmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.AuthenticationTimeout")) {
+            ALOGV("... error = %s (%s)\n", err.name, err.message);
+            result = BOND_RESULT_AUTH_TIMEOUT;
+        } else {
+            ALOGE("%s: D-Bus error: %s (%s)\n", __FUNCTION__, err.name, err.message);
+            result = BOND_RESULT_ERROR;
+        }
+    }
+
+    addr = env->NewStringUTF(address);
+    env->CallVoidMethod(nat->me,
+                        method_onCreatePairedDeviceResult,
+                        addr,
+                        result);
+    env->DeleteLocalRef(addr);
+done:
+    dbus_error_free(&err);
+    free(user);
+}
+
+void onCreateDeviceResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *address= (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    ALOGV("... Address = %s", address);
+
+    jint result = CREATE_DEVICE_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (dbus_error_has_name(&err, "org.bluez.Error.AlreadyExists")) {
+            result = CREATE_DEVICE_ALREADY_EXISTS;
+        } else {
+            result = CREATE_DEVICE_FAILED;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+    jstring addr = env->NewStringUTF(address);
+    env->CallVoidMethod(nat->me,
+                        method_onCreateDeviceResult,
+                        addr,
+                        result);
+    env->DeleteLocalRef(addr);
+    free(user);
+}
+
+void onDiscoverServicesResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    ALOGV("... Device Path = %s", path);
+
+    bool result = JNI_TRUE;
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+        result = JNI_FALSE;
+    }
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onDiscoverServicesResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onGetDeviceServiceChannelResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    const char *address = (const char *) user;
+    native_data_t *nat = (native_data_t *) n;
+
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint channel = -2;
+
+    ALOGV("... address = %s", address);
+
+    if (dbus_set_error_from_message(&err, msg) ||
+        !dbus_message_get_args(msg, &err,
+                               DBUS_TYPE_INT32, &channel,
+                               DBUS_TYPE_INVALID)) {
+        ALOGE("%s: D-Bus error: %s (%s)\n", __FUNCTION__, err.name, err.message);
+        dbus_error_free(&err);
+    }
+
+done:
+    jstring addr = env->NewStringUTF(address);
+    env->CallVoidMethod(nat->me,
+                        method_onGetDeviceServiceChannelResult,
+                        addr,
+                        channel);
+    env->DeleteLocalRef(addr);
+    free(user);
+}
+
+void onInputDeviceConnectionResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = INPUT_OPERATION_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (!strcmp(err.name, BLUEZ_ERROR_IFC ".ConnectionAttemptFailed")) {
+            result = INPUT_CONNECT_FAILED_ATTEMPT_FAILED;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".AlreadyConnected")) {
+            result = INPUT_CONNECT_FAILED_ALREADY_CONNECTED;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".Failed")) {
+            // TODO():This is flaky, need to change Bluez to add new error codes
+            if (!strcmp(err.message, "Transport endpoint is not connected")) {
+              result = INPUT_DISCONNECT_FAILED_NOT_CONNECTED;
+            } else {
+              result = INPUT_OPERATION_GENERIC_FAILURE;
+            }
+        } else {
+            result = INPUT_OPERATION_GENERIC_FAILURE;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+
+    ALOGV("... Device Path = %s, result = %d", path, result);
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onInputDeviceConnectionResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onPanDeviceConnectionResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    const char *path = (const char *)user;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = PAN_OPERATION_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (!strcmp(err.name, BLUEZ_ERROR_IFC ".ConnectionAttemptFailed")) {
+            result = PAN_CONNECT_FAILED_ATTEMPT_FAILED;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".Failed")) {
+            // TODO():This is flaky, need to change Bluez to add new error codes
+            if (!strcmp(err.message, "Device already connected")) {
+                result = PAN_CONNECT_FAILED_ALREADY_CONNECTED;
+            } else if (!strcmp(err.message, "Device not connected")) {
+                result = PAN_DISCONNECT_FAILED_NOT_CONNECTED;
+            } else {
+                result = PAN_OPERATION_GENERIC_FAILURE;
+            }
+        } else {
+            result = PAN_OPERATION_GENERIC_FAILURE;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+
+    ALOGV("... Pan Device Path = %s, result = %d", path, result);
+    jstring jPath = env->NewStringUTF(path);
+    env->CallVoidMethod(nat->me,
+                        method_onPanDeviceConnectionResult,
+                        jPath,
+                        result);
+    env->DeleteLocalRef(jPath);
+    free(user);
+}
+
+void onHealthDeviceConnectionResult(DBusMessage *msg, void *user, void *n) {
+    ALOGV("%s", __FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    DBusError err;
+    dbus_error_init(&err);
+    JNIEnv *env;
+    nat->vm->GetEnv((void**)&env, nat->envVer);
+
+    jint result = HEALTH_OPERATION_SUCCESS;
+    if (dbus_set_error_from_message(&err, msg)) {
+        if (!strcmp(err.name, BLUEZ_ERROR_IFC ".InvalidArgs")) {
+            result = HEALTH_OPERATION_INVALID_ARGS;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".HealthError")) {
+            result = HEALTH_OPERATION_ERROR;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".NotFound")) {
+            result = HEALTH_OPERATION_NOT_FOUND;
+        } else if (!strcmp(err.name, BLUEZ_ERROR_IFC ".NotAllowed")) {
+            result = HEALTH_OPERATION_NOT_ALLOWED;
+        } else {
+            result = HEALTH_OPERATION_GENERIC_FAILURE;
+        }
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+
+    jint code = *(int *) user;
+    ALOGV("... Health Device Code = %d, result = %d", code, result);
+    env->CallVoidMethod(nat->me,
+                        method_onHealthDeviceConnectionResult,
+                        code,
+                        result);
+    free(user);
+}
+#endif
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"classInitNative", "()V", (void *)classInitNative},
+    {"initializeNativeDataNative", "()V", (void *)initializeNativeDataNative},
+    {"cleanupNativeDataNative", "()V", (void *)cleanupNativeDataNative},
+    {"startEventLoopNative", "()V", (void *)startEventLoopNative},
+    {"stopEventLoopNative", "()V", (void *)stopEventLoopNative},
+    {"isEventLoopRunningNative", "()Z", (void *)isEventLoopRunningNative}
+};
+
+int register_android_server_BluetoothEventLoop(JNIEnv *env) {
+    return AndroidRuntime::registerNativeMethods(env,
+            "android/server/BluetoothEventLoop", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/jni/android_server_BluetoothService.cpp b/core/jni/android_server_BluetoothService.cpp
new file mode 100644
index 0000000..6c11121
--- /dev/null
+++ b/core/jni/android_server_BluetoothService.cpp
@@ -0,0 +1,1785 @@
+/*
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define DBUS_ADAPTER_IFACE BLUEZ_DBUS_BASE_IFC ".Adapter"
+#define DBUS_DEVICE_IFACE BLUEZ_DBUS_BASE_IFC ".Device"
+#define DBUS_INPUT_IFACE BLUEZ_DBUS_BASE_IFC ".Input"
+#define DBUS_NETWORK_IFACE BLUEZ_DBUS_BASE_IFC ".Network"
+#define DBUS_NETWORKSERVER_IFACE BLUEZ_DBUS_BASE_IFC ".NetworkServer"
+#define DBUS_HEALTH_MANAGER_PATH "/org/bluez"
+#define DBUS_HEALTH_MANAGER_IFACE BLUEZ_DBUS_BASE_IFC ".HealthManager"
+#define DBUS_HEALTH_DEVICE_IFACE BLUEZ_DBUS_BASE_IFC ".HealthDevice"
+#define DBUS_HEALTH_CHANNEL_IFACE BLUEZ_DBUS_BASE_IFC ".HealthChannel"
+
+#define LOG_TAG "BluetoothService.cpp"
+
+#include "android_bluetooth_common.h"
+#include "android_runtime/AndroidRuntime.h"
+#include "android_util_Binder.h"
+#include "JNIHelp.h"
+#include "jni.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+
+#include <ctype.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+
+#ifdef HAVE_BLUETOOTH
+#include <dbus/dbus.h>
+#include <bluedroid/bluetooth.h>
+#endif
+
+#include <cutils/properties.h>
+
+namespace android {
+
+#define BLUETOOTH_CLASS_ERROR 0xFF000000
+#define PROPERTIES_NREFS 10
+
+#ifdef HAVE_BLUETOOTH
+// We initialize these variables when we load class
+// android.server.BluetoothService
+static jfieldID field_mNativeData;
+static jfieldID field_mEventLoop;
+
+typedef struct {
+    JNIEnv *env;
+    DBusConnection *conn;
+    const char *adapter;  // dbus object name of the local adapter
+} native_data_t;
+
+extern event_loop_native_data_t *get_EventLoop_native_data(JNIEnv *,
+                                                           jobject);
+extern DBusHandlerResult agent_event_filter(DBusConnection *conn,
+                                            DBusMessage *msg,
+                                            void *data);
+void onCreatePairedDeviceResult(DBusMessage *msg, void *user, void *nat);
+void onDiscoverServicesResult(DBusMessage *msg, void *user, void *nat);
+void onCreateDeviceResult(DBusMessage *msg, void *user, void *nat);
+void onInputDeviceConnectionResult(DBusMessage *msg, void *user, void *nat);
+void onPanDeviceConnectionResult(DBusMessage *msg, void *user, void *nat);
+void onHealthDeviceConnectionResult(DBusMessage *msg, void *user, void *nat);
+
+
+/** Get native data stored in the opaque (Java code maintained) pointer mNativeData
+ *  Perform quick sanity check, if there are any problems return NULL
+ */
+static inline native_data_t * get_native_data(JNIEnv *env, jobject object) {
+    native_data_t *nat =
+            (native_data_t *)(env->GetIntField(object, field_mNativeData));
+    if (nat == NULL || nat->conn == NULL) {
+        ALOGE("Uninitialized native data\n");
+        return NULL;
+    }
+    return nat;
+}
+#endif
+
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    field_mNativeData = get_field(env, clazz, "mNativeData", "I");
+    field_mEventLoop = get_field(env, clazz, "mEventLoop",
+            "Landroid/server/BluetoothEventLoop;");
+#endif
+}
+
+/* Returns true on success (even if adapter is present but disabled).
+ * Return false if dbus is down, or another serious error (out of memory)
+*/
+static bool initializeNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = (native_data_t *)calloc(1, sizeof(native_data_t));
+    if (NULL == nat) {
+        ALOGE("%s: out of memory!", __FUNCTION__);
+        return false;
+    }
+    nat->env = env;
+
+    env->SetIntField(object, field_mNativeData, (jint)nat);
+    DBusError err;
+    dbus_error_init(&err);
+    dbus_threads_init_default();
+    nat->conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);
+    if (dbus_error_is_set(&err)) {
+        ALOGE("Could not get onto the system bus: %s", err.message);
+        dbus_error_free(&err);
+        return false;
+    }
+    dbus_connection_set_exit_on_disconnect(nat->conn, FALSE);
+#endif  /*HAVE_BLUETOOTH*/
+    return true;
+}
+
+static const char *get_adapter_path(JNIEnv* env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    event_loop_native_data_t *event_nat =
+        get_EventLoop_native_data(env, env->GetObjectField(object,
+                                                           field_mEventLoop));
+    if (event_nat == NULL)
+        return NULL;
+    return event_nat->adapter;
+#else
+    return NULL;
+#endif
+}
+
+// This function is called when the adapter is enabled.
+static jboolean setupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+        (native_data_t *)env->GetIntField(object, field_mNativeData);
+    event_loop_native_data_t *event_nat =
+        get_EventLoop_native_data(env, env->GetObjectField(object,
+                                                           field_mEventLoop));
+    // Register agent for remote devices.
+    const char *device_agent_path = "/android/bluetooth/remote_device_agent";
+    static const DBusObjectPathVTable agent_vtable = {
+                 NULL, agent_event_filter, NULL, NULL, NULL, NULL };
+
+    if (!dbus_connection_register_object_path(nat->conn, device_agent_path,
+                                              &agent_vtable, event_nat)) {
+        ALOGE("%s: Can't register object path %s for remote device agent!",
+                               __FUNCTION__, device_agent_path);
+        return JNI_FALSE;
+    }
+#endif /*HAVE_BLUETOOTH*/
+    return JNI_TRUE;
+}
+
+static jboolean tearDownNativeDataNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+               (native_data_t *)env->GetIntField(object, field_mNativeData);
+    if (nat != NULL) {
+        const char *device_agent_path =
+            "/android/bluetooth/remote_device_agent";
+        dbus_connection_unregister_object_path (nat->conn, device_agent_path);
+    }
+#endif /*HAVE_BLUETOOTH*/
+    return JNI_TRUE;
+}
+
+static void cleanupNativeDataNative(JNIEnv* env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat =
+        (native_data_t *)env->GetIntField(object, field_mNativeData);
+    if (nat) {
+        free(nat);
+        nat = NULL;
+    }
+#endif
+}
+
+static jstring getAdapterPathNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        return (env->NewStringUTF(get_adapter_path(env, object)));
+    }
+#endif
+    return NULL;
+}
+
+
+static jboolean startDiscoveryNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    DBusMessage *msg = NULL;
+    DBusMessage *reply = NULL;
+    DBusError err;
+    const char *name;
+    jboolean ret = JNI_FALSE;
+
+    native_data_t *nat = get_native_data(env, object);
+    if (nat == NULL) {
+        goto done;
+    }
+
+    dbus_error_init(&err);
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                       get_adapter_path(env, object),
+                                       DBUS_ADAPTER_IFACE, "StartDiscovery");
+
+    if (msg == NULL) {
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        }
+        goto done;
+    }
+
+    /* Send the command. */
+    reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+    if (dbus_error_is_set(&err)) {
+         LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+         ret = JNI_FALSE;
+         goto done;
+    }
+
+    ret = JNI_TRUE;
+done:
+    if (reply) dbus_message_unref(reply);
+    if (msg) dbus_message_unref(msg);
+    return ret;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean stopDiscoveryNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    DBusMessage *msg = NULL;
+    DBusMessage *reply = NULL;
+    DBusError err;
+    const char *name;
+    native_data_t *nat;
+    jboolean ret = JNI_FALSE;
+
+    dbus_error_init(&err);
+
+    nat = get_native_data(env, object);
+    if (nat == NULL) {
+        goto done;
+    }
+
+    /* Compose the command */
+    msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                       get_adapter_path(env, object),
+                                       DBUS_ADAPTER_IFACE, "StopDiscovery");
+    if (msg == NULL) {
+        if (dbus_error_is_set(&err))
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        goto done;
+    }
+
+    /* Send the command. */
+    reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+    if (dbus_error_is_set(&err)) {
+        if(strncmp(err.name, BLUEZ_DBUS_BASE_IFC ".Error.NotAuthorized",
+                   strlen(BLUEZ_DBUS_BASE_IFC ".Error.NotAuthorized")) == 0) {
+            // hcid sends this if there is no active discovery to cancel
+            ALOGV("%s: There was no active discovery to cancel", __FUNCTION__);
+            dbus_error_free(&err);
+        } else {
+            LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
+        }
+        goto done;
+    }
+
+    ret = JNI_TRUE;
+done:
+    if (msg) dbus_message_unref(msg);
+    if (reply) dbus_message_unref(reply);
+    return ret;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jbyteArray readAdapterOutOfBandDataNative(JNIEnv *env, jobject object) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    DBusError err;
+    jbyte *hash, *randomizer;
+    jbyteArray byteArray = NULL;
+    int hash_len, r_len;
+    if (nat) {
+       DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "ReadLocalOutOfBandData",
+                           DBUS_TYPE_INVALID);
+       if (!reply) return NULL;
+
+       dbus_error_init(&err);
+       if (dbus_message_get_args(reply, &err,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &hash, &hash_len,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &randomizer, &r_len,
+                                DBUS_TYPE_INVALID)) {
+          if (hash_len == 16 && r_len == 16) {
+               byteArray = env->NewByteArray(32);
+               if (byteArray) {
+                   env->SetByteArrayRegion(byteArray, 0, 16, hash);
+                   env->SetByteArrayRegion(byteArray, 16, 16, randomizer);
+               }
+           } else {
+               ALOGE("readAdapterOutOfBandDataNative: Hash len = %d, R len = %d",
+                                                                  hash_len, r_len);
+           }
+       } else {
+          LOG_AND_FREE_DBUS_ERROR(&err);
+       }
+       dbus_message_unref(reply);
+       return byteArray;
+    }
+#endif
+    return NULL;
+}
+
+static jboolean createPairedDeviceNative(JNIEnv *env, jobject object,
+                                         jstring address, jint timeout_ms) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        ALOGV("... address = %s", c_address);
+        char *context_address = (char *)calloc(BTADDR_SIZE, sizeof(char));
+        const char *capabilities = "DisplayYesNo";
+        const char *agent_path = "/android/bluetooth/remote_device_agent";
+
+        strlcpy(context_address, c_address, BTADDR_SIZE);  // for callback
+        bool ret = dbus_func_args_async(env, nat->conn, (int)timeout_ms,
+                                        onCreatePairedDeviceResult, // callback
+                                        context_address,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "CreatePairedDevice",
+                                        DBUS_TYPE_STRING, &c_address,
+                                        DBUS_TYPE_OBJECT_PATH, &agent_path,
+                                        DBUS_TYPE_STRING, &capabilities,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        return ret ? JNI_TRUE : JNI_FALSE;
+
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean createPairedDeviceOutOfBandNative(JNIEnv *env, jobject object,
+                                                jstring address, jint timeout_ms) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        ALOGV("... address = %s", c_address);
+        char *context_address = (char *)calloc(BTADDR_SIZE, sizeof(char));
+        const char *capabilities = "DisplayYesNo";
+        const char *agent_path = "/android/bluetooth/remote_device_agent";
+
+        strlcpy(context_address, c_address, BTADDR_SIZE);  // for callback
+        bool ret = dbus_func_args_async(env, nat->conn, (int)timeout_ms,
+                                        onCreatePairedDeviceResult, // callback
+                                        context_address,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "CreatePairedDeviceOutOfBand",
+                                        DBUS_TYPE_STRING, &c_address,
+                                        DBUS_TYPE_OBJECT_PATH, &agent_path,
+                                        DBUS_TYPE_STRING, &capabilities,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jint getDeviceServiceChannelNative(JNIEnv *env, jobject object,
+                                          jstring path,
+                                          jstring pattern, jint attr_id) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+    if (nat && eventLoopNat) {
+        const char *c_pattern = env->GetStringUTFChars(pattern, NULL);
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        ALOGV("... pattern = %s", c_pattern);
+        ALOGV("... attr_id = %#X", attr_id);
+        DBusMessage *reply =
+            dbus_func_args(env, nat->conn, c_path,
+                           DBUS_DEVICE_IFACE, "GetServiceAttributeValue",
+                           DBUS_TYPE_STRING, &c_pattern,
+                           DBUS_TYPE_UINT16, &attr_id,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(pattern, c_pattern);
+        env->ReleaseStringUTFChars(path, c_path);
+        return reply ? dbus_returns_int32(env, reply) : -1;
+    }
+#endif
+    return -1;
+}
+
+static jboolean cancelDeviceCreationNative(JNIEnv *env, jobject object,
+                                           jstring address) {
+    ALOGV("%s", __FUNCTION__);
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+        ALOGV("... address = %s", c_address);
+        DBusMessage *reply =
+            dbus_func_args_timeout(env, nat->conn, -1,
+                                   get_adapter_path(env, object),
+                                   DBUS_ADAPTER_IFACE, "CancelDeviceCreation",
+                                   DBUS_TYPE_STRING, &c_address,
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return JNI_FALSE;
+        } else {
+            result = JNI_TRUE;
+        }
+        dbus_message_unref(reply);
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean removeDeviceNative(JNIEnv *env, jobject object, jstring object_path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_object_path = env->GetStringUTFChars(object_path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        NULL,
+                                        NULL,
+                                        NULL,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "RemoveDevice",
+                                        DBUS_TYPE_OBJECT_PATH, &c_object_path,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(object_path, c_object_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jint enableNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    return bt_enable();
+#endif
+    return -1;
+}
+
+static jint disableNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    return bt_disable();
+#endif
+    return -1;
+}
+
+static jint isEnabledNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    return bt_is_enabled();
+#endif
+    return -1;
+}
+
+static jboolean setPairingConfirmationNative(JNIEnv *env, jobject object,
+                                             jstring address, bool confirm,
+                                             int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        if (confirm) {
+            reply = dbus_message_new_method_return(msg);
+        } else {
+            reply = dbus_message_new_error(msg,
+                "org.bluez.Error.Rejected", "User rejected confirmation");
+        }
+
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to RequestPasskeyConfirmation or"
+                  "RequestPairingConsent to D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setPasskeyNative(JNIEnv *env, jobject object, jstring address,
+                         int passkey, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to return Passkey code to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(reply, DBUS_TYPE_UINT32, (uint32_t *)&passkey,
+                                 DBUS_TYPE_INVALID);
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setRemoteOutOfBandDataNative(JNIEnv *env, jobject object, jstring address,
+                         jbyteArray hash, jbyteArray randomizer, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        jbyte *h_ptr = env->GetByteArrayElements(hash, NULL);
+        jbyte *r_ptr = env->GetByteArrayElements(randomizer, NULL);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to return remote OOB data to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(reply,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &h_ptr, 16,
+                                DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &r_ptr, 16,
+                                DBUS_TYPE_INVALID);
+
+        env->ReleaseByteArrayElements(hash, h_ptr, 0);
+        env->ReleaseByteArrayElements(randomizer, r_ptr, 0);
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setAuthorizationNative(JNIEnv *env, jobject object, jstring address,
+                         jboolean val, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+  ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply;
+        if (val) {
+            reply = dbus_message_new_method_return(msg);
+        } else {
+            reply = dbus_message_new_error(msg,
+                    "org.bluez.Error.Rejected", "Authorization rejected");
+        }
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setPinNative(JNIEnv *env, jobject object, jstring address,
+                         jstring pin, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply = dbus_message_new_method_return(msg);
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to return PIN code to "
+                 "D-Bus\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        const char *c_pin = env->GetStringUTFChars(pin, NULL);
+
+        dbus_message_append_args(reply, DBUS_TYPE_STRING, &c_pin,
+                                 DBUS_TYPE_INVALID);
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        env->ReleaseStringUTFChars(pin, c_pin);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean cancelPairingUserInputNative(JNIEnv *env, jobject object,
+                                            jstring address, int nativeData) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg = (DBusMessage *)nativeData;
+        DBusMessage *reply = dbus_message_new_error(msg,
+                "org.bluez.Error.Canceled", "Pairing User Input was canceled");
+        if (!reply) {
+            ALOGE("%s: Cannot create message reply to return cancelUserInput to"
+                 "D-BUS\n", __FUNCTION__);
+            dbus_message_unref(msg);
+            return JNI_FALSE;
+        }
+
+        dbus_connection_send(nat->conn, reply, NULL);
+        dbus_message_unref(msg);
+        dbus_message_unref(reply);
+        return JNI_TRUE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jobjectArray getDevicePropertiesNative(JNIEnv *env, jobject object,
+                                                    jstring path)
+{
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        reply = dbus_func_args_timeout(env,
+                                   nat->conn, -1, c_path,
+                                   DBUS_DEVICE_IFACE, "GetProperties",
+                                   DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return NULL;
+        }
+        env->PushLocalFrame(PROPERTIES_NREFS);
+
+        DBusMessageIter iter;
+        jobjectArray str_array = NULL;
+        if (dbus_message_iter_init(reply, &iter))
+           str_array =  parse_remote_device_properties(env, &iter);
+        dbus_message_unref(reply);
+
+        return (jobjectArray) env->PopLocalFrame(str_array);
+    }
+#endif
+    return NULL;
+}
+
+static jobjectArray getAdapterPropertiesNative(JNIEnv *env, jobject object) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        reply = dbus_func_args_timeout(env,
+                                   nat->conn, -1, get_adapter_path(env, object),
+                                   DBUS_ADAPTER_IFACE, "GetProperties",
+                                   DBUS_TYPE_INVALID);
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            } else
+                ALOGE("DBus reply is NULL in function %s", __FUNCTION__);
+            return NULL;
+        }
+        env->PushLocalFrame(PROPERTIES_NREFS);
+
+        DBusMessageIter iter;
+        jobjectArray str_array = NULL;
+        if (dbus_message_iter_init(reply, &iter))
+            str_array = parse_adapter_properties(env, &iter);
+        dbus_message_unref(reply);
+
+        return (jobjectArray) env->PopLocalFrame(str_array);
+    }
+#endif
+    return NULL;
+}
+
+static jboolean setAdapterPropertyNative(JNIEnv *env, jobject object, jstring key,
+                                         void *value, jint type) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg;
+        DBusMessageIter iter;
+        dbus_bool_t reply = JNI_FALSE;
+        const char *c_key = env->GetStringUTFChars(key, NULL);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                           get_adapter_path(env, object),
+                                           DBUS_ADAPTER_IFACE, "SetProperty");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for GetProperties!",
+                  __FUNCTION__);
+            env->ReleaseStringUTFChars(key, c_key);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(msg, DBUS_TYPE_STRING, &c_key, DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+        append_variant(&iter, type, value);
+
+        // Asynchronous call - the callbacks come via propertyChange
+        reply = dbus_connection_send_with_reply(nat->conn, msg, NULL, -1);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(key, c_key);
+        return reply ? JNI_TRUE : JNI_FALSE;
+
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setAdapterPropertyStringNative(JNIEnv *env, jobject object, jstring key,
+                                               jstring value) {
+#ifdef HAVE_BLUETOOTH
+    const char *c_value = env->GetStringUTFChars(value, NULL);
+    jboolean ret =  setAdapterPropertyNative(env, object, key, (void *)&c_value, DBUS_TYPE_STRING);
+    env->ReleaseStringUTFChars(value, (char *)c_value);
+    return ret;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setAdapterPropertyIntegerNative(JNIEnv *env, jobject object, jstring key,
+                                               jint value) {
+#ifdef HAVE_BLUETOOTH
+    return setAdapterPropertyNative(env, object, key, (void *)&value, DBUS_TYPE_UINT32);
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setAdapterPropertyBooleanNative(JNIEnv *env, jobject object, jstring key,
+                                               jint value) {
+#ifdef HAVE_BLUETOOTH
+    return setAdapterPropertyNative(env, object, key, (void *)&value, DBUS_TYPE_BOOLEAN);
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setDevicePropertyNative(JNIEnv *env, jobject object, jstring path,
+                                               jstring key, void *value, jint type) {
+#ifdef HAVE_BLUETOOTH
+    ALOGV("%s", __FUNCTION__);
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *msg;
+        DBusMessageIter iter;
+        dbus_bool_t reply = JNI_FALSE;
+
+        const char *c_key = env->GetStringUTFChars(key, NULL);
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                          c_path, DBUS_DEVICE_IFACE, "SetProperty");
+        if (!msg) {
+            ALOGE("%s: Can't allocate new method call for device SetProperty!", __FUNCTION__);
+            env->ReleaseStringUTFChars(key, c_key);
+            env->ReleaseStringUTFChars(path, c_path);
+            return JNI_FALSE;
+        }
+
+        dbus_message_append_args(msg, DBUS_TYPE_STRING, &c_key, DBUS_TYPE_INVALID);
+        dbus_message_iter_init_append(msg, &iter);
+        append_variant(&iter, type, value);
+
+        // Asynchronous call - the callbacks come via Device propertyChange
+        reply = dbus_connection_send_with_reply(nat->conn, msg, NULL, -1);
+        dbus_message_unref(msg);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(key, c_key);
+
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setDevicePropertyBooleanNative(JNIEnv *env, jobject object,
+                                                     jstring path, jstring key, jint value) {
+#ifdef HAVE_BLUETOOTH
+    return setDevicePropertyNative(env, object, path, key,
+                                        (void *)&value, DBUS_TYPE_BOOLEAN);
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean setDevicePropertyStringNative(JNIEnv *env, jobject object,
+                                              jstring path, jstring key, jstring value) {
+#ifdef HAVE_BLUETOOTH
+    const char *c_value = env->GetStringUTFChars(value, NULL);
+    jboolean ret = setDevicePropertyNative(env, object, path, key,
+                                           (void *)&c_value, DBUS_TYPE_STRING);
+    env->ReleaseStringUTFChars(value, (char *)c_value);
+    return ret;
+#else
+    return JNI_FALSE;
+#endif
+}
+
+static jboolean createDeviceNative(JNIEnv *env, jobject object,
+                                                jstring address) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        ALOGV("... address = %s", c_address);
+        char *context_address = (char *)calloc(BTADDR_SIZE, sizeof(char));
+        strlcpy(context_address, c_address, BTADDR_SIZE);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onCreateDeviceResult,
+                                        context_address,
+                                        eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_ADAPTER_IFACE,
+                                        "CreateDevice",
+                                        DBUS_TYPE_STRING, &c_address,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(address, c_address);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean discoverServicesNative(JNIEnv *env, jobject object,
+                                               jstring path, jstring pattern) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_pattern = env->GetStringUTFChars(pattern, NULL);
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        ALOGV("... Object Path = %s", c_path);
+        ALOGV("... Pattern = %s, strlen = %d", c_pattern, strlen(c_pattern));
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onDiscoverServicesResult,
+                                        context_path,
+                                        eventLoopNat,
+                                        c_path,
+                                        DBUS_DEVICE_IFACE,
+                                        "DiscoverServices",
+                                        DBUS_TYPE_STRING, &c_pattern,
+                                        DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(pattern, c_pattern);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+#ifdef HAVE_BLUETOOTH
+static jintArray extract_handles(JNIEnv *env, DBusMessage *reply) {
+    jint *handles;
+    jintArray handleArray = NULL;
+    int len;
+
+    DBusError err;
+    dbus_error_init(&err);
+
+    if (dbus_message_get_args(reply, &err,
+                              DBUS_TYPE_ARRAY, DBUS_TYPE_UINT32, &handles, &len,
+                              DBUS_TYPE_INVALID)) {
+        handleArray = env->NewIntArray(len);
+        if (handleArray) {
+            env->SetIntArrayRegion(handleArray, 0, len, handles);
+        } else {
+            ALOGE("Null array in extract_handles");
+        }
+    } else {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+    return handleArray;
+}
+#endif
+
+static jintArray addReservedServiceRecordsNative(JNIEnv *env, jobject object,
+                                                jintArray uuids) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    DBusMessage *reply = NULL;
+
+    native_data_t *nat = get_native_data(env, object);
+
+    jint* svc_classes = env->GetIntArrayElements(uuids, NULL);
+    if (!svc_classes) return NULL;
+
+    int len = env->GetArrayLength(uuids);
+    reply = dbus_func_args(env, nat->conn,
+                            get_adapter_path(env, object),
+                            DBUS_ADAPTER_IFACE, "AddReservedServiceRecords",
+                            DBUS_TYPE_ARRAY, DBUS_TYPE_UINT32,
+                            &svc_classes, len, DBUS_TYPE_INVALID);
+    env->ReleaseIntArrayElements(uuids, svc_classes, 0);
+    return reply ? extract_handles(env, reply) : NULL;
+
+#endif
+    return NULL;
+}
+
+static jboolean removeReservedServiceRecordsNative(JNIEnv *env, jobject object,
+                                                   jintArray handles) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jint *values = env->GetIntArrayElements(handles, NULL);
+    DBusMessage *msg = NULL;
+    DBusMessage *reply = NULL;
+    if (values == NULL) return JNI_FALSE;
+
+    jsize len = env->GetArrayLength(handles);
+
+    reply = dbus_func_args(env, nat->conn,
+                            get_adapter_path(env, object),
+                            DBUS_ADAPTER_IFACE, "RemoveReservedServiceRecords",
+                            DBUS_TYPE_ARRAY, DBUS_TYPE_UINT32,
+                            &values, len, DBUS_TYPE_INVALID);
+    env->ReleaseIntArrayElements(handles, values, 0);
+    return reply ? JNI_TRUE : JNI_FALSE;
+#endif
+    return JNI_FALSE;
+}
+
+static jint addRfcommServiceRecordNative(JNIEnv *env, jobject object,
+        jstring name, jlong uuidMsb, jlong uuidLsb, jshort channel) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_name = env->GetStringUTFChars(name, NULL);
+        ALOGV("... name = %s", c_name);
+        ALOGV("... uuid1 = %llX", uuidMsb);
+        ALOGV("... uuid2 = %llX", uuidLsb);
+        ALOGV("... channel = %d", channel);
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "AddRfcommServiceRecord",
+                           DBUS_TYPE_STRING, &c_name,
+                           DBUS_TYPE_UINT64, &uuidMsb,
+                           DBUS_TYPE_UINT64, &uuidLsb,
+                           DBUS_TYPE_UINT16, &channel,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(name, c_name);
+        return reply ? dbus_returns_uint32(env, reply) : -1;
+    }
+#endif
+    return -1;
+}
+
+static jboolean removeServiceRecordNative(JNIEnv *env, jobject object, jint handle) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        ALOGV("... handle = %X", handle);
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "RemoveServiceRecord",
+                           DBUS_TYPE_UINT32, &handle,
+                           DBUS_TYPE_INVALID);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setLinkTimeoutNative(JNIEnv *env, jobject object, jstring object_path,
+                                     jint num_slots) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_object_path = env->GetStringUTFChars(object_path, NULL);
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           get_adapter_path(env, object),
+                           DBUS_ADAPTER_IFACE, "SetLinkTimeout",
+                           DBUS_TYPE_OBJECT_PATH, &c_object_path,
+                           DBUS_TYPE_UINT32, &num_slots,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(object_path, c_object_path);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean connectInputDeviceNative(JNIEnv *env, jobject object, jstring path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onInputDeviceConnectionResult,
+                                        context_path, eventLoopNat, c_path, DBUS_INPUT_IFACE,
+                                        "Connect",
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectInputDeviceNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onInputDeviceConnectionResult,
+                                        context_path, eventLoopNat, c_path, DBUS_INPUT_IFACE,
+                                        "Disconnect",
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean setBluetoothTetheringNative(JNIEnv *env, jobject object, jboolean value,
+                                            jstring src_role, jstring bridge) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        DBusMessage *reply;
+        const char *c_role = env->GetStringUTFChars(src_role, NULL);
+        const char *c_bridge = env->GetStringUTFChars(bridge, NULL);
+        if (value) {
+            ALOGE("setBluetoothTetheringNative true");
+            reply = dbus_func_args(env, nat->conn,
+                                  get_adapter_path(env, object),
+                                  DBUS_NETWORKSERVER_IFACE,
+                                  "Register",
+                                  DBUS_TYPE_STRING, &c_role,
+                                  DBUS_TYPE_STRING, &c_bridge,
+                                  DBUS_TYPE_INVALID);
+        } else {
+            ALOGE("setBluetoothTetheringNative false");
+            reply = dbus_func_args(env, nat->conn,
+                                  get_adapter_path(env, object),
+                                  DBUS_NETWORKSERVER_IFACE,
+                                  "Unregister",
+                                  DBUS_TYPE_STRING, &c_role,
+                                  DBUS_TYPE_INVALID);
+        }
+        env->ReleaseStringUTFChars(src_role, c_role);
+        env->ReleaseStringUTFChars(bridge, c_bridge);
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean connectPanDeviceNative(JNIEnv *env, jobject object, jstring path,
+                                       jstring dstRole) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    ALOGE("connectPanDeviceNative");
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *dst = env->GetStringUTFChars(dstRole, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,onPanDeviceConnectionResult,
+                                    context_path, eventLoopNat, c_path,
+                                    DBUS_NETWORK_IFACE, "Connect",
+                                    DBUS_TYPE_STRING, &dst,
+                                    DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(dstRole, dst);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectPanDeviceNative(JNIEnv *env, jobject object,
+                                     jstring path) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    ALOGE("disconnectPanDeviceNative");
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,onPanDeviceConnectionResult,
+                                        context_path, eventLoopNat, c_path,
+                                        DBUS_NETWORK_IFACE, "Disconnect",
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean disconnectPanServerDeviceNative(JNIEnv *env, jobject object,
+                                                jstring path, jstring address,
+                                                jstring iface) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    ALOGE("disconnectPanServerDeviceNative");
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_address = env->GetStringUTFChars(address, NULL);
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        const char *c_iface = env->GetStringUTFChars(iface, NULL);
+
+        int len = env->GetStringLength(path) + 1;
+        char *context_path = (char *)calloc(len, sizeof(char));
+        strlcpy(context_path, c_path, len);  // for callback
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1,
+                                        onPanDeviceConnectionResult,
+                                        context_path, eventLoopNat,
+                                        get_adapter_path(env, object),
+                                        DBUS_NETWORKSERVER_IFACE,
+                                        "DisconnectDevice",
+                                        DBUS_TYPE_STRING, &c_address,
+                                        DBUS_TYPE_STRING, &c_iface,
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(address, c_address);
+        env->ReleaseStringUTFChars(iface, c_iface);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jstring registerHealthApplicationNative(JNIEnv *env, jobject object,
+                                           jint dataType, jstring role,
+                                           jstring name, jstring channelType) {
+    ALOGV("%s", __FUNCTION__);
+    jstring path = NULL;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_role = env->GetStringUTFChars(role, NULL);
+        const char *c_name = env->GetStringUTFChars(name, NULL);
+        const char *c_channel_type = env->GetStringUTFChars(channelType, NULL);
+        char *c_path;
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                            DBUS_HEALTH_MANAGER_PATH,
+                                            DBUS_HEALTH_MANAGER_IFACE,
+                                            "CreateApplication");
+
+        if (msg == NULL) {
+            ALOGE("Could not allocate D-Bus message object!");
+            return NULL;
+        }
+
+        /* append arguments */
+        append_dict_args(msg,
+                         "DataType", DBUS_TYPE_UINT16, &dataType,
+                         "Role", DBUS_TYPE_STRING, &c_role,
+                         "Description", DBUS_TYPE_STRING, &c_name,
+                         "ChannelType", DBUS_TYPE_STRING, &c_channel_type,
+                         DBUS_TYPE_INVALID);
+
+
+        /* Make the call. */
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+
+        env->ReleaseStringUTFChars(role, c_role);
+        env->ReleaseStringUTFChars(name, c_name);
+        env->ReleaseStringUTFChars(channelType, c_channel_type);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            if (!dbus_message_get_args(reply, &err,
+                                      DBUS_TYPE_OBJECT_PATH, &c_path,
+                                      DBUS_TYPE_INVALID)) {
+                if (dbus_error_is_set(&err)) {
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                }
+            } else {
+               path = env->NewStringUTF(c_path);
+            }
+            dbus_message_unref(reply);
+        }
+    }
+#endif
+    return path;
+}
+
+static jstring registerSinkHealthApplicationNative(JNIEnv *env, jobject object,
+                                           jint dataType, jstring role,
+                                           jstring name) {
+    ALOGV("%s", __FUNCTION__);
+    jstring path = NULL;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_role = env->GetStringUTFChars(role, NULL);
+        const char *c_name = env->GetStringUTFChars(name, NULL);
+        char *c_path;
+
+        DBusMessage *msg, *reply;
+        DBusError err;
+        dbus_error_init(&err);
+
+        msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,
+                                            DBUS_HEALTH_MANAGER_PATH,
+                                            DBUS_HEALTH_MANAGER_IFACE,
+                                            "CreateApplication");
+
+        if (msg == NULL) {
+            ALOGE("Could not allocate D-Bus message object!");
+            return NULL;
+        }
+
+        /* append arguments */
+        append_dict_args(msg,
+                         "DataType", DBUS_TYPE_UINT16, &dataType,
+                         "Role", DBUS_TYPE_STRING, &c_role,
+                         "Description", DBUS_TYPE_STRING, &c_name,
+                         DBUS_TYPE_INVALID);
+
+
+        /* Make the call. */
+        reply = dbus_connection_send_with_reply_and_block(nat->conn, msg, -1, &err);
+
+        env->ReleaseStringUTFChars(role, c_role);
+        env->ReleaseStringUTFChars(name, c_name);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            if (!dbus_message_get_args(reply, &err,
+                                      DBUS_TYPE_OBJECT_PATH, &c_path,
+                                      DBUS_TYPE_INVALID)) {
+                if (dbus_error_is_set(&err)) {
+                    LOG_AND_FREE_DBUS_ERROR(&err);
+                }
+            } else {
+                path = env->NewStringUTF(c_path);
+            }
+            dbus_message_unref(reply);
+        }
+    }
+#endif
+    return path;
+}
+
+static jboolean unregisterHealthApplicationNative(JNIEnv *env, jobject object,
+                                                    jstring path) {
+    ALOGV("%s", __FUNCTION__);
+    jboolean result = JNI_FALSE;
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+        DBusMessage *reply =
+            dbus_func_args_timeout(env, nat->conn, -1,
+                                   DBUS_HEALTH_MANAGER_PATH,
+                                   DBUS_HEALTH_MANAGER_IFACE, "DestroyApplication",
+                                   DBUS_TYPE_OBJECT_PATH, &c_path,
+                                   DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            result = JNI_TRUE;
+        }
+    }
+#endif
+    return result;
+}
+
+static jboolean createChannelNative(JNIEnv *env, jobject object,
+                                       jstring devicePath, jstring appPath, jstring config,
+                                       jint code) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_device_path = env->GetStringUTFChars(devicePath, NULL);
+        const char *c_app_path = env->GetStringUTFChars(appPath, NULL);
+        const char *c_config = env->GetStringUTFChars(config, NULL);
+        int *data = (int *) malloc(sizeof(int));
+        if (data == NULL) return JNI_FALSE;
+
+        *data = code;
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onHealthDeviceConnectionResult,
+                                        data, eventLoopNat, c_device_path,
+                                        DBUS_HEALTH_DEVICE_IFACE, "CreateChannel",
+                                        DBUS_TYPE_OBJECT_PATH, &c_app_path,
+                                        DBUS_TYPE_STRING, &c_config,
+                                        DBUS_TYPE_INVALID);
+
+
+        env->ReleaseStringUTFChars(devicePath, c_device_path);
+        env->ReleaseStringUTFChars(appPath, c_app_path);
+        env->ReleaseStringUTFChars(config, c_config);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean destroyChannelNative(JNIEnv *env, jobject object, jstring devicePath,
+                                     jstring channelPath, jint code) {
+    ALOGE("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    jobject eventLoop = env->GetObjectField(object, field_mEventLoop);
+    struct event_loop_native_data_t *eventLoopNat =
+            get_EventLoop_native_data(env, eventLoop);
+
+    if (nat && eventLoopNat) {
+        const char *c_device_path = env->GetStringUTFChars(devicePath, NULL);
+        const char *c_channel_path = env->GetStringUTFChars(channelPath, NULL);
+        int *data = (int *) malloc(sizeof(int));
+        if (data == NULL) return JNI_FALSE;
+
+        *data = code;
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onHealthDeviceConnectionResult,
+                                        data, eventLoopNat, c_device_path,
+                                        DBUS_HEALTH_DEVICE_IFACE, "DestroyChannel",
+                                        DBUS_TYPE_OBJECT_PATH, &c_channel_path,
+                                        DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(devicePath, c_device_path);
+        env->ReleaseStringUTFChars(channelPath, c_channel_path);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jstring getMainChannelNative(JNIEnv *env, jobject object, jstring devicePath) {
+    ALOGE("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_device_path = env->GetStringUTFChars(devicePath, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                           c_device_path,
+                           DBUS_HEALTH_DEVICE_IFACE, "GetProperties",
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(devicePath, c_device_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            DBusMessageIter iter;
+            jobjectArray str_array = NULL;
+            if (dbus_message_iter_init(reply, &iter))
+                str_array = parse_health_device_properties(env, &iter);
+            dbus_message_unref(reply);
+            jstring path = (jstring) env->GetObjectArrayElement(str_array, 1);
+
+            return path;
+        }
+    }
+#endif
+    return NULL;
+}
+
+static jstring getChannelApplicationNative(JNIEnv *env, jobject object, jstring channelPath) {
+    ALOGE("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_channel_path = env->GetStringUTFChars(channelPath, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                                            c_channel_path,
+                                            DBUS_HEALTH_CHANNEL_IFACE, "GetProperties",
+                                            DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(channelPath, c_channel_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+        } else {
+            DBusMessageIter iter;
+            jobjectArray str_array = NULL;
+            if (dbus_message_iter_init(reply, &iter))
+                str_array = parse_health_channel_properties(env, &iter);
+            dbus_message_unref(reply);
+
+            jint len = env->GetArrayLength(str_array);
+
+            jstring name, path;
+            const char *c_name;
+
+            for (int i = 0; i < len; i+=2) {
+                name = (jstring) env->GetObjectArrayElement(str_array, i);
+                c_name = env->GetStringUTFChars(name, NULL);
+
+                if (!strcmp(c_name, "Application")) {
+                    path = (jstring) env->GetObjectArrayElement(str_array, i+1);
+                    env->ReleaseStringUTFChars(name, c_name);
+                    return path;
+                }
+                env->ReleaseStringUTFChars(name, c_name);
+            }
+        }
+    }
+#endif
+    return NULL;
+}
+
+static jboolean releaseChannelFdNative(JNIEnv *env, jobject object, jstring channelPath) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_channel_path = env->GetStringUTFChars(channelPath, NULL);
+        DBusError err;
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                                            c_channel_path,
+                                            DBUS_HEALTH_CHANNEL_IFACE, "Release",
+                                            DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(channelPath, c_channel_path);
+
+        return reply ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jobject getChannelFdNative(JNIEnv *env, jobject object, jstring channelPath) {
+    ALOGV("%s", __FUNCTION__);
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, object);
+    if (nat) {
+        const char *c_channel_path = env->GetStringUTFChars(channelPath, NULL);
+        int32_t fd;
+        DBusError err;
+        dbus_error_init(&err);
+
+        DBusMessage *reply = dbus_func_args(env, nat->conn,
+                                            c_channel_path,
+                                            DBUS_HEALTH_CHANNEL_IFACE, "Acquire",
+                                            DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(channelPath, c_channel_path);
+
+        if (!reply) {
+            if (dbus_error_is_set(&err)) {
+                LOG_AND_FREE_DBUS_ERROR(&err);
+            }
+            return NULL;
+        }
+
+        fd = dbus_returns_unixfd(env, reply);
+        if (fd == -1) return NULL;
+
+        int flags = fcntl(fd, F_GETFL);
+        if (flags < 0) {
+           ALOGE("Can't get flags with fcntl(): %s (%d)",
+                                strerror(errno), errno);
+           releaseChannelFdNative(env, object, channelPath);
+           close(fd);
+           return NULL;
+        }
+
+        flags &= ~O_NONBLOCK;
+        int status = fcntl(fd, F_SETFL, flags);
+        if (status < 0) {
+           ALOGE("Can't set flags with fcntl(): %s (%d)",
+               strerror(errno), errno);
+           releaseChannelFdNative(env, object, channelPath);
+           close(fd);
+           return NULL;
+        }
+
+        // Create FileDescriptor object
+        jobject fileDesc = jniCreateFileDescriptor(env, fd);
+        if (fileDesc == NULL) {
+            // FileDescriptor constructor has thrown an exception
+            releaseChannelFdNative(env, object, channelPath);
+            close(fd);
+            return NULL;
+        }
+
+        // Wrap it in a ParcelFileDescriptor
+        jobject parcelFileDesc = newParcelFileDescriptor(env, fileDesc);
+        if (parcelFileDesc == NULL) {
+            // ParcelFileDescriptor constructor has thrown an exception
+            releaseChannelFdNative(env, object, channelPath);
+            close(fd);
+            return NULL;
+        }
+
+        return parcelFileDesc;
+    }
+#endif
+    return NULL;
+}
+
+
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"classInitNative", "()V", (void*)classInitNative},
+    {"initializeNativeDataNative", "()V", (void *)initializeNativeDataNative},
+    {"setupNativeDataNative", "()Z", (void *)setupNativeDataNative},
+    {"tearDownNativeDataNative", "()Z", (void *)tearDownNativeDataNative},
+    {"cleanupNativeDataNative", "()V", (void *)cleanupNativeDataNative},
+    {"getAdapterPathNative", "()Ljava/lang/String;", (void*)getAdapterPathNative},
+
+    {"isEnabledNative", "()I", (void *)isEnabledNative},
+    {"enableNative", "()I", (void *)enableNative},
+    {"disableNative", "()I", (void *)disableNative},
+
+    {"getAdapterPropertiesNative", "()[Ljava/lang/Object;", (void *)getAdapterPropertiesNative},
+    {"getDevicePropertiesNative", "(Ljava/lang/String;)[Ljava/lang/Object;",
+      (void *)getDevicePropertiesNative},
+    {"setAdapterPropertyStringNative", "(Ljava/lang/String;Ljava/lang/String;)Z",
+      (void *)setAdapterPropertyStringNative},
+    {"setAdapterPropertyBooleanNative", "(Ljava/lang/String;I)Z",
+      (void *)setAdapterPropertyBooleanNative},
+    {"setAdapterPropertyIntegerNative", "(Ljava/lang/String;I)Z",
+      (void *)setAdapterPropertyIntegerNative},
+
+    {"startDiscoveryNative", "()Z", (void*)startDiscoveryNative},
+    {"stopDiscoveryNative", "()Z", (void *)stopDiscoveryNative},
+
+    {"readAdapterOutOfBandDataNative", "()[B", (void *)readAdapterOutOfBandDataNative},
+    {"createPairedDeviceNative", "(Ljava/lang/String;I)Z", (void *)createPairedDeviceNative},
+    {"createPairedDeviceOutOfBandNative", "(Ljava/lang/String;I)Z",
+                                    (void *)createPairedDeviceOutOfBandNative},
+    {"cancelDeviceCreationNative", "(Ljava/lang/String;)Z", (void *)cancelDeviceCreationNative},
+    {"removeDeviceNative", "(Ljava/lang/String;)Z", (void *)removeDeviceNative},
+    {"getDeviceServiceChannelNative", "(Ljava/lang/String;Ljava/lang/String;I)I",
+      (void *)getDeviceServiceChannelNative},
+
+    {"setPairingConfirmationNative", "(Ljava/lang/String;ZI)Z",
+            (void *)setPairingConfirmationNative},
+    {"setPasskeyNative", "(Ljava/lang/String;II)Z", (void *)setPasskeyNative},
+    {"setRemoteOutOfBandDataNative", "(Ljava/lang/String;[B[BI)Z", (void *)setRemoteOutOfBandDataNative},
+    {"setAuthorizationNative", "(Ljava/lang/String;ZI)Z", (void *)setAuthorizationNative},
+    {"setPinNative", "(Ljava/lang/String;Ljava/lang/String;I)Z", (void *)setPinNative},
+    {"cancelPairingUserInputNative", "(Ljava/lang/String;I)Z",
+            (void *)cancelPairingUserInputNative},
+    {"setDevicePropertyBooleanNative", "(Ljava/lang/String;Ljava/lang/String;I)Z",
+            (void *)setDevicePropertyBooleanNative},
+    {"setDevicePropertyStringNative", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
+            (void *)setDevicePropertyStringNative},
+    {"createDeviceNative", "(Ljava/lang/String;)Z", (void *)createDeviceNative},
+    {"discoverServicesNative", "(Ljava/lang/String;Ljava/lang/String;)Z", (void *)discoverServicesNative},
+    {"addRfcommServiceRecordNative", "(Ljava/lang/String;JJS)I", (void *)addRfcommServiceRecordNative},
+    {"removeServiceRecordNative", "(I)Z", (void *)removeServiceRecordNative},
+    {"addReservedServiceRecordsNative", "([I)[I", (void *) addReservedServiceRecordsNative},
+    {"removeReservedServiceRecordsNative", "([I)Z", (void *) removeReservedServiceRecordsNative},
+    {"setLinkTimeoutNative", "(Ljava/lang/String;I)Z", (void *)setLinkTimeoutNative},
+    // HID functions
+    {"connectInputDeviceNative", "(Ljava/lang/String;)Z", (void *)connectInputDeviceNative},
+    {"disconnectInputDeviceNative", "(Ljava/lang/String;)Z", (void *)disconnectInputDeviceNative},
+
+    {"setBluetoothTetheringNative", "(ZLjava/lang/String;Ljava/lang/String;)Z",
+              (void *)setBluetoothTetheringNative},
+    {"connectPanDeviceNative", "(Ljava/lang/String;Ljava/lang/String;)Z",
+              (void *)connectPanDeviceNative},
+    {"disconnectPanDeviceNative", "(Ljava/lang/String;)Z", (void *)disconnectPanDeviceNative},
+    {"disconnectPanServerDeviceNative", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
+              (void *)disconnectPanServerDeviceNative},
+    // Health function
+    {"registerHealthApplicationNative",
+              "(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
+              (void *)registerHealthApplicationNative},
+    {"registerHealthApplicationNative",
+            "(ILjava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
+            (void *)registerSinkHealthApplicationNative},
+
+    {"unregisterHealthApplicationNative", "(Ljava/lang/String;)Z",
+              (void *)unregisterHealthApplicationNative},
+    {"createChannelNative", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)Z",
+              (void *)createChannelNative},
+    {"destroyChannelNative", "(Ljava/lang/String;Ljava/lang/String;I)Z",
+              (void *)destroyChannelNative},
+    {"getMainChannelNative", "(Ljava/lang/String;)Ljava/lang/String;", (void *)getMainChannelNative},
+    {"getChannelApplicationNative", "(Ljava/lang/String;)Ljava/lang/String;",
+              (void *)getChannelApplicationNative},
+    {"getChannelFdNative", "(Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;", (void *)getChannelFdNative},
+    {"releaseChannelFdNative", "(Ljava/lang/String;)Z", (void *)releaseChannelFdNative},
+};
+
+
+int register_android_server_BluetoothService(JNIEnv *env) {
+    return AndroidRuntime::registerNativeMethods(env,
+                "android/server/BluetoothService", sMethods, NELEM(sMethods));
+}
+
+} /* namespace android */
diff --git a/core/res/res/values/avrcp_data.xml b/core/res/res/values/avrcp_data.xml
new file mode 100644
index 0000000..19ccbde
--- /dev/null
+++ b/core/res/res/values/avrcp_data.xml
@@ -0,0 +1,112 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* Copyright 2012, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- meta changed intents -->
+    <string-array translatable="false" name="avrcp_meta_changed_intents">
+        <!-- Android Stock Music App / Google Play Music App -->
+        <item>com.android.music.metachanged</item>
+        <!-- HTC Music App -->
+        <item>com.htc.music.metachanged</item>
+        <!-- WinAmp -->
+        <item>com.nullsoft.winamp.metachanged</item>
+        <!-- MIUI Music App -->
+        <item>com.miui.player.metachanged</item>
+        <!-- Sony Ericson Music App -->
+        <item>com.sonyericsson.music.metachanged</item>
+        <!-- RDIO Music App -->
+        <item>com.rdio.android.metachanged</item>
+        <!-- PowerAmp Music App -->
+        <item>com.maxmpz.audioplayer.metachanged</item>
+        <!-- Samsung Music App -->
+        <item>com.samsung.sec.android.MusicPlayer.metachanged</item>
+        <item>com.sec.android.app.music.metachanged</item>
+        <!-- Amazon Music App -->
+        <item>com.amazon.mp3.metachanged</item>
+        <!-- Rhapsody Music App -->
+        <item>com.rhapsody.metachanged</item>
+        <!-- Player Pro Music App -->
+        <item>com.tbig.playerpro.metachanged</item>
+        <!-- Doubletwist Music App - breaks system-->
+        <!-- <item>com.doubleTwist.androidPlayer.metachanged</item> -->
+        <!-- Last.fm scrobbler intent -->
+        <item>fm.last.android.metachanged</item>
+    </string-array>
+
+    <!-- playstate changed intents -->
+    <string-array translatable="false" name="avrcp_playstate_changed_intents">
+        <!-- Android Stock Music App / Google Play Music App -->
+        <item>com.android.music.playstatechanged</item>
+        <!-- HTC Music App -->
+        <item>com.htc.music.playstatechanged</item>
+        <!-- WinAmp -->
+        <item>com.nullsoft.winamp.playstatechanged</item>
+        <!-- MIUI Music App -->
+        <item>com.miui.player.playstatechanged</item>
+        <!-- Sony Ericson Music App -->
+        <item>com.sonyericsson.music.playstatechanged</item>
+        <!-- RDIO Music App -->
+        <item>com.rdio.android.playstatechanged</item>
+        <!-- PowerAmp Music App -->
+        <item>com.maxmpz.audioplayer.playstatechanged</item>
+        <!-- Samsung Music App -->
+        <item>com.samsung.sec.android.MusicPlayer.playstatechanged</item>
+        <item>com.sec.android.app.music.playstatechanged</item>
+        <!-- Amazon Music App -->
+        <item>com.amazon.mp3.playstatechanged</item>
+        <!-- Rhapsody Music App -->
+        <item>com.rhapsody.playstatechanged</item>
+        <!-- Player Pro Music App -->
+        <item>com.tbig.playerpro.playstatechanged</item>
+        <!-- Doubletwist Music App  - breaks system-->
+        <!-- <item>com.doubleTwist.androidPlayer.playstatechanged</item> -->
+        <!-- Last.fm scrobbler intent -->
+        <item>fm.last.android.playstatechanged</item>
+        <!-- A simple last.fm scrobbler intent -->
+        <item>com.adam.aslfms.notify.playstatechanged</item>
+        <!-- Scrobble Droid scrobbler intent -->
+        <item>net.jjc1138.android.scrobbler.action.MUSIC_STATUS</item>
+    </string-array>
+
+    <!-- intents with special extra keys -->
+    <string-array translatable="false" name="avrcp_special_extra_keys">
+        <!-- Amazon Music App -->
+        <item>com.amazon.mp3.metachanged</item>
+        <item>com.amazon.mp3.playstatechanged</item>
+    </string-array>
+
+    <!-- overridable extra keys -->
+    <string-array translatable="false" name="avrcp_overridable_extra_keys">
+        <item>track</item>
+        <item>artist</item>
+        <item>album</item>
+        <item>id</item>
+    </string-array>
+
+    <!-- mapping of special extra keys -->
+    <string name="com.amazon.mp3.metachanged_track" translatable="false">com.amazon.mp3.track</string>
+    <string name="com.amazon.mp3.metachanged_artist" translatable="false">com.amazon.mp3.artist</string>
+    <string name="com.amazon.mp3.metachanged_album" translatable="false">com.amazon.mp3.album</string>
+    <string name="com.amazon.mp3.metachanged_id" translatable="false">com.amazon.mp3.id</string>
+
+    <string name="com.amazon.mp3.playstatechanged_track" translatable="false">com.amazon.mp3.track</string>
+    <string name="com.amazon.mp3.playstatechanged_artist" translatable="false">com.amazon.mp3.artist</string>
+    <string name="com.amazon.mp3.playstatechanged_album" translatable="false">com.amazon.mp3.album</string>
+    <string name="com.amazon.mp3.playstatechanged_id" translatable="false">com.amazon.mp3.id</string>
+
+</resources>
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 3e52b0c..b542eb1 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -682,6 +682,7 @@
     <!-- Boolean indicating if current platform supports bluetooth SCO for off call
     use cases -->
     <bool name="config_bluetooth_sco_off_call">true</bool>
+    <bool name="config_bluetooth_adapter_quick_switch">false</bool>
 
     <!-- Boolean indicating if current platform supports bluetooth wide band
          speech -->
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index f6d2a48..c9d7bd4 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -1911,6 +1911,20 @@
    =============================================================== -->
   <eat-comment />
 
+  <java-symbol type="bool" name="config_bluetooth_adapter_quick_switch" />
+  <java-symbol type="array" name="avrcp_meta_changed_intents" />
+  <java-symbol type="array" name="avrcp_playstate_changed_intents" />
+  <java-symbol type="array" name="avrcp_special_extra_keys" />
+  <java-symbol type="array" name="avrcp_overridable_extra_keys" />
+  <java-symbol type="string" name="com.amazon.mp3.metachanged_track" />
+  <java-symbol type="string" name="com.amazon.mp3.metachanged_artist" />
+  <java-symbol type="string" name="com.amazon.mp3.metachanged_album" />
+  <java-symbol type="string" name="com.amazon.mp3.metachanged_id" />
+  <java-symbol type="string" name="com.amazon.mp3.playstatechanged_track" />
+  <java-symbol type="string" name="com.amazon.mp3.playstatechanged_artist" />
+  <java-symbol type="string" name="com.amazon.mp3.playstatechanged_album" />
+  <java-symbol type="string" name="com.amazon.mp3.playstatechanged_id" />
+
   <!-- Config.xml entries -->
   <java-symbol type="bool" name="config_forceDisableHardwareKeyboard" />
   <java-symbol type="bool" name="config_hasRotationLockSwitch" />
diff --git a/services/java/com/android/server/BluetoothManagerService.java b/services/java/com/android/server/BluetoothManagerService.java
deleted file mode 100644
index 5a2088c..0000000
--- a/services/java/com/android/server/BluetoothManagerService.java
+++ /dev/null
@@ -1,1129 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.app.ActivityManager;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.IBluetooth;
-import android.bluetooth.IBluetoothCallback;
-import android.bluetooth.IBluetoothManager;
-import android.bluetooth.IBluetoothManagerCallback;
-import android.bluetooth.IBluetoothStateChangeCallback;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.ServiceConnection;
-import android.os.Binder;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Message;
-import android.os.Process;
-import android.os.RemoteCallbackList;
-import android.os.RemoteException;
-import android.os.SystemClock;
-import android.os.UserHandle;
-import android.provider.Settings;
-import android.util.Log;
-class BluetoothManagerService extends IBluetoothManager.Stub {
-    private static final String TAG = "BluetoothManagerService";
-    private static final boolean DBG = true;
-
-    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
-    private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
-    private static final String ACTION_SERVICE_STATE_CHANGED="com.android.bluetooth.btservice.action.STATE_CHANGED";
-    private static final String EXTRA_ACTION="action";
-    private static final String SECURE_SETTINGS_BLUETOOTH_ADDR_VALID="bluetooth_addr_valid";
-    private static final String SECURE_SETTINGS_BLUETOOTH_ADDRESS="bluetooth_address";
-    private static final String SECURE_SETTINGS_BLUETOOTH_NAME="bluetooth_name";
-    private static final int TIMEOUT_BIND_MS = 3000; //Maximum msec to wait for a bind
-    private static final int TIMEOUT_SAVE_MS = 500; //Maximum msec to wait for a save
-    //Maximum msec to wait for service restart
-    private static final int SERVICE_RESTART_TIME_MS = 200;
-    //Maximum msec to delay MESSAGE_USER_SWITCHED
-    private static final int USER_SWITCHED_TIME_MS = 200;
-
-    private static final int MESSAGE_ENABLE = 1;
-    private static final int MESSAGE_DISABLE = 2;
-    private static final int MESSAGE_REGISTER_ADAPTER = 20;
-    private static final int MESSAGE_UNREGISTER_ADAPTER = 21;
-    private static final int MESSAGE_REGISTER_STATE_CHANGE_CALLBACK = 30;
-    private static final int MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK = 31;
-    private static final int MESSAGE_BLUETOOTH_SERVICE_CONNECTED = 40;
-    private static final int MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED = 41;
-    private static final int MESSAGE_RESTART_BLUETOOTH_SERVICE = 42;
-    private static final int MESSAGE_BLUETOOTH_STATE_CHANGE=60;
-    private static final int MESSAGE_TIMEOUT_BIND =100;
-    private static final int MESSAGE_TIMEOUT_UNBIND =101;
-    private static final int MESSAGE_GET_NAME_AND_ADDRESS=200;
-    private static final int MESSAGE_SAVE_NAME_AND_ADDRESS=201;
-    private static final int MESSAGE_USER_SWITCHED = 300;
-    private static final int MAX_SAVE_RETRIES=3;
-    // Bluetooth persisted setting is off
-    private static final int BLUETOOTH_OFF=0;
-    // Bluetooth persisted setting is on
-    // and Airplane mode won't affect Bluetooth state at start up
-    private static final int BLUETOOTH_ON_BLUETOOTH=1;
-    // Bluetooth persisted setting is on
-    // but Airplane mode will affect Bluetooth state at start up
-    // and Airplane mode will have higher priority.
-    private static final int BLUETOOTH_ON_AIRPLANE=2;
-
-    private final Context mContext;
-
-    // Locks are not provided for mName and mAddress.
-    // They are accessed in handler or broadcast receiver, same thread context.
-    private String mAddress;
-    private String mName;
-    private final ContentResolver mContentResolver;
-    private final RemoteCallbackList<IBluetoothManagerCallback> mCallbacks;
-    private final RemoteCallbackList<IBluetoothStateChangeCallback> mStateChangeCallbacks;
-    private IBluetooth mBluetooth;
-    private boolean mBinding;
-    private boolean mUnbinding;
-    // used inside handler thread
-    private boolean mQuietEnable = false;
-    // configuarion from external IBinder call which is used to
-    // synchronize with broadcast receiver.
-    private boolean mQuietEnableExternal;
-    // configuarion from external IBinder call which is used to
-    // synchronize with broadcast receiver.
-    private boolean mEnableExternal;
-    // used inside handler thread
-    private boolean mEnable;
-    private int mState;
-    private HandlerThread mThread;
-    private final BluetoothHandler mHandler;
-
-    private void registerForAirplaneMode(IntentFilter filter) {
-        final ContentResolver resolver = mContext.getContentResolver();
-        final String airplaneModeRadios = Settings.Global.getString(resolver,
-                Settings.Global.AIRPLANE_MODE_RADIOS);
-        final String toggleableRadios = Settings.Global.getString(resolver,
-                Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
-        boolean mIsAirplaneSensitive = airplaneModeRadios == null ? true :
-                airplaneModeRadios.contains(Settings.Global.RADIO_BLUETOOTH);
-        if (mIsAirplaneSensitive) {
-            filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
-        }
-    }
-
-    private final IBluetoothCallback mBluetoothCallback =  new IBluetoothCallback.Stub() {
-        @Override
-        public void onBluetoothStateChange(int prevState, int newState) throws RemoteException  {
-            Message msg = mHandler.obtainMessage(MESSAGE_BLUETOOTH_STATE_CHANGE,prevState,newState);
-            mHandler.sendMessage(msg);
-        }
-    };
-
-    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-            if (BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED.equals(action)) {
-                String newName = intent.getStringExtra(BluetoothAdapter.EXTRA_LOCAL_NAME);
-                if (DBG) Log.d(TAG, "Bluetooth Adapter name changed to " + newName);
-                if (newName != null) {
-                    storeNameAndAddress(newName, null);
-                }
-            } else if (Intent.ACTION_AIRPLANE_MODE_CHANGED.equals(action)) {
-                synchronized(mReceiver) {
-                    if (isBluetoothPersistedStateOn()) {
-                        if (isAirplaneModeOn()) {
-                            persistBluetoothSetting(BLUETOOTH_ON_AIRPLANE);
-                        } else {
-                            persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
-                        }
-                    }
-                    if (isAirplaneModeOn()) {
-                        // disable without persisting the setting
-                        sendDisableMsg();
-                    } else if (mEnableExternal) {
-                        // enable without persisting the setting
-                        sendEnableMsg(mQuietEnableExternal);
-                    }
-                }
-            } else if (Intent.ACTION_USER_SWITCHED.equals(action)) {
-                mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_USER_SWITCHED,
-                       intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0), 0));
-            } else if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
-                synchronized(mReceiver) {
-                    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
-                        //Enable
-                        if (DBG) Log.d(TAG, "Auto-enabling Bluetooth.");
-                        sendEnableMsg(mQuietEnableExternal);
-                    }
-                }
-
-                if (!isNameAndAddressSet()) {
-                    //Sync the Bluetooth name and address from the Bluetooth Adapter
-                    if (DBG) Log.d(TAG,"Retrieving Bluetooth Adapter name and address...");
-                    getNameAndAddress();
-                }
-            }
-        }
-    };
-
-    BluetoothManagerService(Context context) {
-        mThread = new HandlerThread("BluetoothManager");
-        mThread.start();
-        mHandler = new BluetoothHandler(mThread.getLooper());
-
-        mContext = context;
-        mBluetooth = null;
-        mBinding = false;
-        mUnbinding = false;
-        mEnable = false;
-        mState = BluetoothAdapter.STATE_OFF;
-        mQuietEnableExternal = false;
-        mEnableExternal = false;
-        mAddress = null;
-        mName = null;
-        mContentResolver = context.getContentResolver();
-        mCallbacks = new RemoteCallbackList<IBluetoothManagerCallback>();
-        mStateChangeCallbacks = new RemoteCallbackList<IBluetoothStateChangeCallback>();
-        IntentFilter filter = new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
-        filter.addAction(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
-        filter.addAction(Intent.ACTION_USER_SWITCHED);
-        registerForAirplaneMode(filter);
-        mContext.registerReceiver(mReceiver, filter);
-        loadStoredNameAndAddress();
-        if (isBluetoothPersistedStateOn()) {
-            mEnableExternal = true;
-        }
-    }
-
-    /**
-     *  Returns true if airplane mode is currently on
-     */
-    private final boolean isAirplaneModeOn() {
-        return Settings.Global.getInt(mContext.getContentResolver(),
-                Settings.Global.AIRPLANE_MODE_ON, 0) == 1;
-    }
-
-    /**
-     *  Returns true if the Bluetooth saved state is "on"
-     */
-    private final boolean isBluetoothPersistedStateOn() {
-        return Settings.Global.getInt(mContentResolver,
-                Settings.Global.BLUETOOTH_ON, 0) != BLUETOOTH_OFF;
-    }
-
-    /**
-     *  Returns true if the Bluetooth saved state is BLUETOOTH_ON_BLUETOOTH
-     */
-    private final boolean isBluetoothPersistedStateOnBluetooth() {
-        return Settings.Global.getInt(mContentResolver,
-                Settings.Global.BLUETOOTH_ON, 0) == BLUETOOTH_ON_BLUETOOTH;
-    }
-
-    /**
-     *  Save the Bluetooth on/off state
-     *
-     */
-    private void persistBluetoothSetting(int value) {
-        Settings.Global.putInt(mContext.getContentResolver(),
-                               Settings.Global.BLUETOOTH_ON,
-                               value);
-    }
-
-    /**
-     * Returns true if the Bluetooth Adapter's name and address is
-     * locally cached
-     * @return
-     */
-    private boolean isNameAndAddressSet() {
-        return mName !=null && mAddress!= null && mName.length()>0 && mAddress.length()>0;
-    }
-
-    /**
-     * Retrieve the Bluetooth Adapter's name and address and save it in
-     * in the local cache
-     */
-    private void loadStoredNameAndAddress() {
-        if (DBG) Log.d(TAG, "Loading stored name and address");
-        if (mContext.getResources().getBoolean
-            (com.android.internal.R.bool.config_bluetooth_address_validation) &&
-             Settings.Secure.getInt(mContentResolver, SECURE_SETTINGS_BLUETOOTH_ADDR_VALID, 0) == 0) {
-            // if the valid flag is not set, don't load the address and name
-            if (DBG) Log.d(TAG, "invalid bluetooth name and address stored");
-            return;
-        }
-        mName = Settings.Secure.getString(mContentResolver, SECURE_SETTINGS_BLUETOOTH_NAME);
-        mAddress = Settings.Secure.getString(mContentResolver, SECURE_SETTINGS_BLUETOOTH_ADDRESS);
-        if (DBG) Log.d(TAG, "Stored bluetooth Name=" + mName + ",Address=" + mAddress);
-    }
-
-    /**
-     * Save the Bluetooth name and address in the persistent store.
-     * Only non-null values will be saved.
-     * @param name
-     * @param address
-     */
-    private void storeNameAndAddress(String name, String address) {
-        if (name != null) {
-            Settings.Secure.putString(mContentResolver, SECURE_SETTINGS_BLUETOOTH_NAME, name);
-            mName = name;
-            if (DBG) Log.d(TAG,"Stored Bluetooth name: " +
-                Settings.Secure.getString(mContentResolver,SECURE_SETTINGS_BLUETOOTH_NAME));
-        }
-
-        if (address != null) {
-            Settings.Secure.putString(mContentResolver, SECURE_SETTINGS_BLUETOOTH_ADDRESS, address);
-            mAddress=address;
-            if (DBG)  Log.d(TAG,"Stored Bluetoothaddress: " +
-                Settings.Secure.getString(mContentResolver,SECURE_SETTINGS_BLUETOOTH_ADDRESS));
-        }
-
-        if ((name != null) && (address != null)) {
-            Settings.Secure.putInt(mContentResolver, SECURE_SETTINGS_BLUETOOTH_ADDR_VALID, 1);
-        }
-    }
-
-    public IBluetooth registerAdapter(IBluetoothManagerCallback callback){
-        Message msg = mHandler.obtainMessage(MESSAGE_REGISTER_ADAPTER);
-        msg.obj = callback;
-        mHandler.sendMessage(msg);
-        synchronized(mConnection) {
-            return mBluetooth;
-        }
-    }
-
-    public void unregisterAdapter(IBluetoothManagerCallback callback) {
-        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
-                                                "Need BLUETOOTH permission");
-        Message msg = mHandler.obtainMessage(MESSAGE_UNREGISTER_ADAPTER);
-        msg.obj = callback;
-        mHandler.sendMessage(msg);
-    }
-
-    public void registerStateChangeCallback(IBluetoothStateChangeCallback callback) {
-        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
-                                                "Need BLUETOOTH permission");
-        Message msg = mHandler.obtainMessage(MESSAGE_REGISTER_STATE_CHANGE_CALLBACK);
-        msg.obj = callback;
-        mHandler.sendMessage(msg);
-    }
-
-    public void unregisterStateChangeCallback(IBluetoothStateChangeCallback callback) {
-        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
-                                                "Need BLUETOOTH permission");
-        Message msg = mHandler.obtainMessage(MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK);
-        msg.obj = callback;
-        mHandler.sendMessage(msg);
-    }
-
-    public boolean isEnabled() {
-        if ((Binder.getCallingUid() != Process.SYSTEM_UID) &&
-            (!checkIfCallerIsForegroundUser())) {
-            Log.w(TAG,"isEnabled(): not allowed for non-active and non system user");
-            return false;
-        }
-
-        synchronized(mConnection) {
-            try {
-                return (mBluetooth != null && mBluetooth.isEnabled());
-            } catch (RemoteException e) {
-                Log.e(TAG, "isEnabled()", e);
-            }
-        }
-        return false;
-    }
-
-    public void getNameAndAddress() {
-        if (DBG) {
-            Log.d(TAG,"getNameAndAddress(): mBluetooth = " + mBluetooth +
-                  " mBinding = " + mBinding);
-        }
-        Message msg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
-        mHandler.sendMessage(msg);
-    }
-    public boolean enableNoAutoConnect()
-    {
-        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
-                                                "Need BLUETOOTH ADMIN permission");
-
-        if (DBG) {
-            Log.d(TAG,"enableNoAutoConnect():  mBluetooth =" + mBluetooth +
-                    " mBinding = " + mBinding);
-        }
-        int callingAppId = UserHandle.getAppId(Binder.getCallingUid());
-
-        if (callingAppId != Process.NFC_UID) {
-            throw new SecurityException("no permission to enable Bluetooth quietly");
-        }
-
-        synchronized(mReceiver) {
-            mQuietEnableExternal = true;
-            mEnableExternal = true;
-            sendEnableMsg(true);
-        }
-        return true;
-
-    }
-    public boolean enable() {
-        if ((Binder.getCallingUid() != Process.SYSTEM_UID) &&
-            (!checkIfCallerIsForegroundUser())) {
-            Log.w(TAG,"enable(): not allowed for non-active and non system user");
-            return false;
-        }
-
-        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
-                                                "Need BLUETOOTH ADMIN permission");
-        if (DBG) {
-            Log.d(TAG,"enable():  mBluetooth =" + mBluetooth +
-                    " mBinding = " + mBinding);
-        }
-
-        synchronized(mReceiver) {
-            mQuietEnableExternal = false;
-            mEnableExternal = true;
-            // waive WRITE_SECURE_SETTINGS permission check
-            long callingIdentity = Binder.clearCallingIdentity();
-            persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
-            Binder.restoreCallingIdentity(callingIdentity);
-            sendEnableMsg(false);
-        }
-        return true;
-    }
-
-    public boolean disable(boolean persist) {
-        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
-                                                "Need BLUETOOTH ADMIN permissicacheNameAndAddresson");
-
-        if ((Binder.getCallingUid() != Process.SYSTEM_UID) &&
-            (!checkIfCallerIsForegroundUser())) {
-            Log.w(TAG,"disable(): not allowed for non-active and non system user");
-            return false;
-        }
-
-        if (DBG) {
-            Log.d(TAG,"disable(): mBluetooth = " + mBluetooth +
-                " mBinding = " + mBinding);
-        }
-
-        synchronized(mReceiver) {
-            if (persist) {
-                // waive WRITE_SECURE_SETTINGS permission check
-                long callingIdentity = Binder.clearCallingIdentity();
-                persistBluetoothSetting(BLUETOOTH_OFF);
-                Binder.restoreCallingIdentity(callingIdentity);
-            }
-            mEnableExternal = false;
-            sendDisableMsg();
-        }
-        return true;
-    }
-
-    public void unbindAndFinish() {
-        if (DBG) {
-            Log.d(TAG,"unbindAndFinish(): " + mBluetooth +
-                " mBinding = " + mBinding);
-        }
-
-        synchronized (mConnection) {
-            if (mUnbinding) return;
-            mUnbinding = true;
-            if (mBluetooth != null) {
-                if (!mConnection.isGetNameAddressOnly()) {
-                    //Unregister callback object
-                    try {
-                        mBluetooth.unregisterCallback(mBluetoothCallback);
-                    } catch (RemoteException re) {
-                        Log.e(TAG, "Unable to unregister BluetoothCallback",re);
-                    }
-                }
-                if (DBG) Log.d(TAG, "Sending unbind request.");
-                mBluetooth = null;
-                //Unbind
-                mContext.unbindService(mConnection);
-                mUnbinding = false;
-                mBinding = false;
-            } else {
-                mUnbinding=false;
-            }
-        }
-    }
-
-    private void sendBluetoothStateCallback(boolean isUp) {
-        int n = mStateChangeCallbacks.beginBroadcast();
-        if (DBG) Log.d(TAG,"Broadcasting onBluetoothStateChange("+isUp+") to " + n + " receivers.");
-        for (int i=0; i <n;i++) {
-            try {
-                mStateChangeCallbacks.getBroadcastItem(i).onBluetoothStateChange(isUp);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Unable to call onBluetoothStateChange() on callback #" + i , e);
-            }
-        }
-        mStateChangeCallbacks.finishBroadcast();
-    }
-
-    /**
-     * Inform BluetoothAdapter instances that Adapter service is up
-     */
-    private void sendBluetoothServiceUpCallback() {
-        if (!mConnection.isGetNameAddressOnly()) {
-            if (DBG) Log.d(TAG,"Calling onBluetoothServiceUp callbacks");
-            int n = mCallbacks.beginBroadcast();
-            Log.d(TAG,"Broadcasting onBluetoothServiceUp() to " + n + " receivers.");
-            for (int i=0; i <n;i++) {
-                try {
-                    mCallbacks.getBroadcastItem(i).onBluetoothServiceUp(mBluetooth);
-                }  catch (RemoteException e) {
-                    Log.e(TAG, "Unable to call onBluetoothServiceUp() on callback #" + i, e);
-                }
-            }
-            mCallbacks.finishBroadcast();
-        }
-    }
-    /**
-     * Inform BluetoothAdapter instances that Adapter service is down
-     */
-    private void sendBluetoothServiceDownCallback() {
-        if (!mConnection.isGetNameAddressOnly()) {
-            if (DBG) Log.d(TAG,"Calling onBluetoothServiceDown callbacks");
-            int n = mCallbacks.beginBroadcast();
-            Log.d(TAG,"Broadcasting onBluetoothServiceDown() to " + n + " receivers.");
-            for (int i=0; i <n;i++) {
-                try {
-                    mCallbacks.getBroadcastItem(i).onBluetoothServiceDown();
-                }  catch (RemoteException e) {
-                    Log.e(TAG, "Unable to call onBluetoothServiceDown() on callback #" + i, e);
-                }
-            }
-            mCallbacks.finishBroadcast();
-        }
-    }
-    public String getAddress() {
-        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
-                                                "Need BLUETOOTH permission");
-
-        if ((Binder.getCallingUid() != Process.SYSTEM_UID) &&
-            (!checkIfCallerIsForegroundUser())) {
-            Log.w(TAG,"getAddress(): not allowed for non-active and non system user");
-            return null;
-        }
-
-        synchronized(mConnection) {
-            if (mBluetooth != null) {
-                try {
-                    return mBluetooth.getAddress();
-                } catch (RemoteException e) {
-                    Log.e(TAG, "getAddress(): Unable to retrieve address remotely..Returning cached address",e);
-                }
-            }
-        }
-        // mAddress is accessed from outside.
-        // It is alright without a lock. Here, bluetooth is off, no other thread is
-        // changing mAddress
-        return mAddress;
-    }
-
-    public String getName() {
-        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,
-                                                "Need BLUETOOTH permission");
-
-        if ((Binder.getCallingUid() != Process.SYSTEM_UID) &&
-            (!checkIfCallerIsForegroundUser())) {
-            Log.w(TAG,"getName(): not allowed for non-active and non system user");
-            return null;
-        }
-
-        synchronized(mConnection) {
-            if (mBluetooth != null) {
-                try {
-                    return mBluetooth.getName();
-                } catch (RemoteException e) {
-                    Log.e(TAG, "getName(): Unable to retrieve name remotely..Returning cached name",e);
-                }
-            }
-        }
-        // mName is accessed from outside.
-        // It alright without a lock. Here, bluetooth is off, no other thread is
-        // changing mName
-        return mName;
-    }
-
-    private class BluetoothServiceConnection implements ServiceConnection {
-
-        private boolean mGetNameAddressOnly;
-
-        public void setGetNameAddressOnly(boolean getOnly) {
-            mGetNameAddressOnly = getOnly;
-        }
-
-        public boolean isGetNameAddressOnly() {
-            return mGetNameAddressOnly;
-        }
-
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            if (DBG) Log.d(TAG, "BluetoothServiceConnection: connected to AdapterService");
-            Message msg = mHandler.obtainMessage(MESSAGE_BLUETOOTH_SERVICE_CONNECTED);
-            msg.obj = service;
-            mHandler.sendMessage(msg);
-        }
-
-        public void onServiceDisconnected(ComponentName className) {
-            // Called if we unexpected disconnected.
-            if (DBG) Log.d(TAG, "BluetoothServiceConnection: disconnected from AdapterService");
-            Message msg = mHandler.obtainMessage(MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED);
-            mHandler.sendMessage(msg);
-        }
-    }
-
-    private BluetoothServiceConnection mConnection = new BluetoothServiceConnection();
-
-    private class BluetoothHandler extends Handler {
-        public BluetoothHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            if (DBG) Log.d (TAG, "Message: " + msg.what);
-            switch (msg.what) {
-                case MESSAGE_GET_NAME_AND_ADDRESS: {
-                    if (DBG) Log.d(TAG,"MESSAGE_GET_NAME_AND_ADDRESS");
-                    synchronized(mConnection) {
-                        //Start bind request
-                        if ((mBluetooth == null) && (!mBinding)) {
-                            if (DBG) Log.d(TAG, "Binding to service to get name and address");
-                            mConnection.setGetNameAddressOnly(true);
-                            //Start bind timeout and bind
-                            Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
-                            mHandler.sendMessageDelayed(timeoutMsg,TIMEOUT_BIND_MS);
-                            Intent i = new Intent(IBluetooth.class.getName());
-                            if (!mContext.bindService(i, mConnection,
-                                  Context.BIND_AUTO_CREATE, UserHandle.USER_CURRENT)) {
-                                mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
-                                Log.e(TAG, "fail to bind to: " + IBluetooth.class.getName());
-                            } else {
-                                mBinding = true;
-                            }
-                        }
-                        else {
-                            Message saveMsg= mHandler.obtainMessage(MESSAGE_SAVE_NAME_AND_ADDRESS);
-                            saveMsg.arg1 = 0;
-                            if (mBluetooth != null) {
-                                mHandler.sendMessage(saveMsg);
-                            } else {
-                                // if enable is also called to bind the service
-                                // wait for MESSAGE_BLUETOOTH_SERVICE_CONNECTED
-                                mHandler.sendMessageDelayed(saveMsg, TIMEOUT_SAVE_MS);
-                            }
-                        }
-                    }
-                    break;
-                }
-                case MESSAGE_SAVE_NAME_AND_ADDRESS: {
-                    boolean unbind = false;
-                    if (DBG) Log.d(TAG,"MESSAGE_SAVE_NAME_AND_ADDRESS");
-                    synchronized(mConnection) {
-                        if (!mEnable && mBluetooth != null) {
-                            try {
-                                mBluetooth.enable();
-                            } catch (RemoteException e) {
-                                Log.e(TAG,"Unable to call enable()",e);
-                            }
-                        }
-                    }
-                    if (mBluetooth != null) waitForOnOff(true, false);
-                    synchronized(mConnection) {
-                        if (mBluetooth != null) {
-                            String name =  null;
-                            String address = null;
-                            try {
-                                name =  mBluetooth.getName();
-                                address = mBluetooth.getAddress();
-                            } catch (RemoteException re) {
-                                Log.e(TAG,"",re);
-                            }
-
-                            if (name != null && address != null) {
-                                storeNameAndAddress(name,address);
-                                if (mConnection.isGetNameAddressOnly()) {
-                                    unbind = true;
-                                }
-                            } else {
-                                if (msg.arg1 < MAX_SAVE_RETRIES) {
-                                    Message retryMsg = mHandler.obtainMessage(MESSAGE_SAVE_NAME_AND_ADDRESS);
-                                    retryMsg.arg1= 1+msg.arg1;
-                                    if (DBG) Log.d(TAG,"Retrying name/address remote retrieval and save.....Retry count =" + retryMsg.arg1);
-                                    mHandler.sendMessageDelayed(retryMsg, TIMEOUT_SAVE_MS);
-                                } else {
-                                    Log.w(TAG,"Maximum name/address remote retrieval retry exceeded");
-                                    if (mConnection.isGetNameAddressOnly()) {
-                                        unbind = true;
-                                    }
-                                }
-                            }
-                            if (!mEnable) {
-                                try {
-                                    mBluetooth.disable();
-                                } catch (RemoteException e) {
-                                    Log.e(TAG,"Unable to call disable()",e);
-                                }
-                            }
-                        } else {
-                            // rebind service by Request GET NAME AND ADDRESS
-                            // if service is unbinded by disable or
-                            // MESSAGE_BLUETOOTH_SERVICE_CONNECTED is not received
-                            Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
-                            mHandler.sendMessage(getMsg);
-                        }
-                    }
-                    if (!mEnable && mBluetooth != null) waitForOnOff(false, true);
-                    if (unbind) {
-                        unbindAndFinish();
-                    }
-                    break;
-                }
-                case MESSAGE_ENABLE:
-                    if (DBG) {
-                        Log.d(TAG, "MESSAGE_ENABLE: mBluetooth = " + mBluetooth);
-                    }
-                    mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
-                    mEnable = true;
-                    handleEnable(msg.arg1 == 1);
-                    break;
-
-                case MESSAGE_DISABLE:
-                    mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
-                    if (mEnable && mBluetooth != null) {
-                        waitForOnOff(true, false);
-                        mEnable = false;
-                        handleDisable();
-                        waitForOnOff(false, false);
-                    } else {
-                        mEnable = false;
-                        handleDisable();
-                    }
-                    break;
-
-                case MESSAGE_REGISTER_ADAPTER:
-                {
-                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
-                    boolean added = mCallbacks.register(callback);
-                    Log.d(TAG,"Added callback: " +  (callback == null? "null": callback)  +":" +added );
-                }
-                    break;
-                case MESSAGE_UNREGISTER_ADAPTER:
-                {
-                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
-                    boolean removed = mCallbacks.unregister(callback);
-                    Log.d(TAG,"Removed callback: " +  (callback == null? "null": callback)  +":" + removed);
-                    break;
-                }
-                case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
-                {
-                    IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
-                    mStateChangeCallbacks.register(callback);
-                    break;
-                }
-                case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
-                {
-                    IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
-                    mStateChangeCallbacks.unregister(callback);
-                    break;
-                }
-                case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
-                {
-                    if (DBG) Log.d(TAG,"MESSAGE_BLUETOOTH_SERVICE_CONNECTED");
-
-                    //Remove timeout
-                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
-
-                    IBinder service = (IBinder) msg.obj;
-                    synchronized(mConnection) {
-                        mBinding = false;
-                        mBluetooth = IBluetooth.Stub.asInterface(service);
-
-                        if (mConnection.isGetNameAddressOnly()) {
-                            //Request GET NAME AND ADDRESS
-                            Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
-                            mHandler.sendMessage(getMsg);
-                            if (!mEnable) return;
-                        }
-
-                        mConnection.setGetNameAddressOnly(false);
-                        //Register callback object
-                        try {
-                            mBluetooth.registerCallback(mBluetoothCallback);
-                        } catch (RemoteException re) {
-                            Log.e(TAG, "Unable to register BluetoothCallback",re);
-                        }
-                        //Inform BluetoothAdapter instances that service is up
-                        sendBluetoothServiceUpCallback();
-
-                        //Do enable request
-                        try {
-                            if (mQuietEnable == false) {
-                                if(!mBluetooth.enable()) {
-                                    Log.e(TAG,"IBluetooth.enable() returned false");
-                                }
-                            }
-                            else
-                            {
-                                if(!mBluetooth.enableNoAutoConnect()) {
-                                    Log.e(TAG,"IBluetooth.enableNoAutoConnect() returned false");
-                                }
-                            }
-                        } catch (RemoteException e) {
-                            Log.e(TAG,"Unable to call enable()",e);
-                        }
-                    }
-
-                    if (!mEnable) {
-                        waitForOnOff(true, false);
-                        handleDisable();
-                        waitForOnOff(false, false);
-                    }
-                    break;
-                }
-                case MESSAGE_TIMEOUT_BIND: {
-                    Log.e(TAG, "MESSAGE_TIMEOUT_BIND");
-                    synchronized(mConnection) {
-                        mBinding = false;
-                    }
-                    break;
-                }
-                case MESSAGE_BLUETOOTH_STATE_CHANGE:
-                {
-                    int prevState = msg.arg1;
-                    int newState = msg.arg2;
-                    if (DBG) Log.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: prevState = " + prevState + ", newState=" + newState);
-                    mState = newState;
-                    bluetoothStateChangeHandler(prevState, newState);
-                    break;
-                }
-                case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
-                {
-                    Log.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED");
-                    synchronized(mConnection) {
-                        // if service is unbinded already, do nothing and return
-                        if (mBluetooth == null) return;
-                        mBluetooth = null;
-                    }
-
-                    if (mEnable) {
-                        mEnable = false;
-                        // Send a Bluetooth Restart message
-                        Message restartMsg = mHandler.obtainMessage(
-                            MESSAGE_RESTART_BLUETOOTH_SERVICE);
-                        mHandler.sendMessageDelayed(restartMsg,
-                            SERVICE_RESTART_TIME_MS);
-                    }
-
-                    if (!mConnection.isGetNameAddressOnly()) {
-                        sendBluetoothServiceDownCallback();
-
-                        // Send BT state broadcast to update
-                        // the BT icon correctly
-                        if ((mState == BluetoothAdapter.STATE_TURNING_ON) ||
-                            (mState == BluetoothAdapter.STATE_ON)) {
-                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON,
-                                                        BluetoothAdapter.STATE_TURNING_OFF);
-                            mState = BluetoothAdapter.STATE_TURNING_OFF;
-                        }
-                        if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
-                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
-                                                        BluetoothAdapter.STATE_OFF);
-                        }
-
-                        mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
-                        mState = BluetoothAdapter.STATE_OFF;
-                    }
-                    break;
-                }
-                case MESSAGE_RESTART_BLUETOOTH_SERVICE:
-                {
-                    Log.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE:"
-                        +" Restart IBluetooth service");
-                    /* Enable without persisting the setting as
-                     it doesnt change when IBluetooth
-                     service restarts */
-                    mEnable = true;
-                    handleEnable(mQuietEnable);
-                    break;
-                }
-
-                case MESSAGE_TIMEOUT_UNBIND:
-                {
-                    Log.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
-                    synchronized(mConnection) {
-                        mUnbinding = false;
-                    }
-                    break;
-                }
-
-                case MESSAGE_USER_SWITCHED:
-                {
-                    if (DBG) {
-                        Log.d(TAG, "MESSAGE_USER_SWITCHED");
-                    }
-                    mHandler.removeMessages(MESSAGE_USER_SWITCHED);
-                    /* disable and enable BT when detect a user switch */
-                    if (mEnable && mBluetooth != null) {
-                        synchronized (mConnection) {
-                            if (mBluetooth != null) {
-                                //Unregister callback object
-                                try {
-                                    mBluetooth.unregisterCallback(mBluetoothCallback);
-                                } catch (RemoteException re) {
-                                    Log.e(TAG, "Unable to unregister",re);
-                                }
-                            }
-                        }
-
-                        if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
-                            // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
-                            bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
-                            mState = BluetoothAdapter.STATE_OFF;
-                        }
-                        if (mState == BluetoothAdapter.STATE_OFF) {
-                            bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
-                            mState = BluetoothAdapter.STATE_TURNING_ON;
-                        }
-
-                        waitForOnOff(true, false);
-
-                        if (mState == BluetoothAdapter.STATE_TURNING_ON) {
-                            bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
-                        }
-
-                        // disable
-                        handleDisable();
-                        // Pbap service need receive STATE_TURNING_OFF intent to close
-                        bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON,
-                                                    BluetoothAdapter.STATE_TURNING_OFF);
-
-                        waitForOnOff(false, true);
-
-                        bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
-                                                    BluetoothAdapter.STATE_OFF);
-                        sendBluetoothServiceDownCallback();
-                        synchronized (mConnection) {
-                            if (mBluetooth != null) {
-                                mBluetooth = null;
-                                //Unbind
-                                mContext.unbindService(mConnection);
-                            }
-                        }
-                        SystemClock.sleep(100);
-
-                        mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
-                        mState = BluetoothAdapter.STATE_OFF;
-                        // enable
-                        handleEnable(mQuietEnable);
-		    } else if (mBinding || mBluetooth != null) {
-                        Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
-                        userMsg.arg2 = 1 + msg.arg2;
-                        // if user is switched when service is being binding
-                        // delay sending MESSAGE_USER_SWITCHED
-                        mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
-                        if (DBG) {
-                            Log.d(TAG, "delay MESSAGE_USER_SWITCHED " + userMsg.arg2);
-                        }
-		    }
-                    break;
-                }
-            }
-        }
-    }
-
-    private void handleEnable(boolean quietMode) {
-        mQuietEnable = quietMode;
-
-        synchronized(mConnection) {
-            if ((mBluetooth == null) && (!mBinding)) {
-                //Start bind timeout and bind
-                Message timeoutMsg=mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
-                mHandler.sendMessageDelayed(timeoutMsg,TIMEOUT_BIND_MS);
-                mConnection.setGetNameAddressOnly(false);
-                Intent i = new Intent(IBluetooth.class.getName());
-                if (!mContext.bindService(i, mConnection,Context.BIND_AUTO_CREATE,
-                                          UserHandle.USER_CURRENT)) {
-                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
-                    Log.e(TAG, "Fail to bind to: " + IBluetooth.class.getName());
-                } else {
-                    mBinding = true;
-                }
-            } else if (mBluetooth != null) {
-                if (mConnection.isGetNameAddressOnly()) {
-                    // if GetNameAddressOnly is set, we can clear this flag,
-                    // so the service won't be unbind
-                    // after name and address are saved
-                    mConnection.setGetNameAddressOnly(false);
-                    //Register callback object
-                    try {
-                        mBluetooth.registerCallback(mBluetoothCallback);
-                    } catch (RemoteException re) {
-                        Log.e(TAG, "Unable to register BluetoothCallback",re);
-                    }
-                    //Inform BluetoothAdapter instances that service is up
-                    sendBluetoothServiceUpCallback();
-                }
-
-                //Enable bluetooth
-                try {
-                    if (!mQuietEnable) {
-                        if(!mBluetooth.enable()) {
-                            Log.e(TAG,"IBluetooth.enable() returned false");
-                        }
-                    }
-                    else {
-                        if(!mBluetooth.enableNoAutoConnect()) {
-                            Log.e(TAG,"IBluetooth.enableNoAutoConnect() returned false");
-                        }
-                    }
-                } catch (RemoteException e) {
-                    Log.e(TAG,"Unable to call enable()",e);
-                }
-            }
-        }
-    }
-
-    private void handleDisable() {
-        synchronized(mConnection) {
-            // don't need to disable if GetNameAddressOnly is set,
-            // service will be unbinded after Name and Address are saved
-            if ((mBluetooth != null) && (!mConnection.isGetNameAddressOnly())) {
-                if (DBG) Log.d(TAG,"Sending off request.");
-
-                try {
-                    if(!mBluetooth.disable()) {
-                        Log.e(TAG,"IBluetooth.disable() returned false");
-                    }
-                } catch (RemoteException e) {
-                    Log.e(TAG,"Unable to call disable()",e);
-                }
-            }
-        }
-    }
-
-    private boolean checkIfCallerIsForegroundUser() {
-        int foregroundUser;
-        int callingUser = UserHandle.getCallingUserId();
-        int callingUid = Binder.getCallingUid();
-        long callingIdentity = Binder.clearCallingIdentity();
-        int callingAppId = UserHandle.getAppId(callingUid);
-        boolean valid = false;
-        try {
-            foregroundUser = ActivityManager.getCurrentUser();
-            valid = (callingUser == foregroundUser) ||
-                    callingAppId == Process.NFC_UID;
-            if (DBG) {
-                Log.d(TAG, "checkIfCallerIsForegroundUser: valid=" + valid
-                    + " callingUser=" + callingUser
-                    + " foregroundUser=" + foregroundUser);
-            }
-        } finally {
-            Binder.restoreCallingIdentity(callingIdentity);
-        }
-        return valid;
-    }
-
-    private void bluetoothStateChangeHandler(int prevState, int newState) {
-        if (prevState != newState) {
-            //Notify all proxy objects first of adapter state change
-            if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_OFF) {
-                boolean isUp = (newState==BluetoothAdapter.STATE_ON);
-                sendBluetoothStateCallback(isUp);
-
-                //If Bluetooth is off, send service down event to proxy objects, and unbind
-                if (!isUp && canUnbindBluetoothService()) {
-                    sendBluetoothServiceDownCallback();
-                    unbindAndFinish();
-                }
-            }
-
-            //Send broadcast message to everyone else
-            Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
-            intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, prevState);
-            intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
-            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-            if (DBG) Log.d(TAG,"Bluetooth State Change Intent: " + prevState + " -> " + newState);
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
-                    BLUETOOTH_PERM);
-        }
-    }
-
-    /**
-     *  if on is true, wait for state become ON
-     *  if off is true, wait for state become OFF
-     *  if both on and off are false, wait for state not ON
-     */
-    private boolean waitForOnOff(boolean on, boolean off) {
-        int i = 0;
-        while (i < 10) {
-            synchronized(mConnection) {
-                try {
-                    if (mBluetooth == null) break;
-                    if (on) {
-                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
-                    } else if (off) {
-                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
-		    } else {
-                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
-		    }
-                } catch (RemoteException e) {
-                    Log.e(TAG, "getState()", e);
-                    break;
-                }
-            }
-            if (on || off) {
-                SystemClock.sleep(300);
-	    } else {
-                SystemClock.sleep(50);
-	    }
-            i++;
-        }
-        Log.e(TAG,"waitForOnOff time out");
-        return false;
-    }
-
-    private void sendDisableMsg() {
-        mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_DISABLE));
-    }
-
-    private void sendEnableMsg(boolean quietMode) {
-        mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_ENABLE,
-                             quietMode ? 1 : 0, 0));
-    }
-
-    private boolean canUnbindBluetoothService() {
-        synchronized(mConnection) {
-            //Only unbind with mEnable flag not set
-            //For race condition: disable and enable back-to-back
-            //Avoid unbind right after enable due to callback from disable
-            //Only unbind with Bluetooth at OFF state
-            //Only unbind without any MESSAGE_BLUETOOTH_STATE_CHANGE message
-            try {
-                if (mEnable || (mBluetooth == null)) return false;
-                if (mHandler.hasMessages(MESSAGE_BLUETOOTH_STATE_CHANGE)) return false;
-                return (mBluetooth.getState() == BluetoothAdapter.STATE_OFF);
-            } catch (RemoteException e) {
-                Log.e(TAG, "getState()", e);
-            }
-        }
-        return false;
-    }
-}
diff --git a/services/java/com/android/server/NetworkManagementService.java b/services/java/com/android/server/NetworkManagementService.java
index 208ae25..59a784b 100644
--- a/services/java/com/android/server/NetworkManagementService.java
+++ b/services/java/com/android/server/NetworkManagementService.java
@@ -851,7 +851,8 @@ public class NetworkManagementService extends INetworkManagementService.Stub
         } catch (NativeDaemonConnectorException e) {
             throw new IllegalStateException("Unable to communicate to native daemon");
         }
-        BluetoothTetheringDataTracker.getInstance().startReverseTether(iface);
+//-vuk
+//        BluetoothTetheringDataTracker.getInstance().startReverseTether(iface);
 
     }
 
@@ -863,7 +864,7 @@ public class NetworkManagementService extends INetworkManagementService.Stub
         } catch (NativeDaemonConnectorException e) {
             throw new IllegalStateException("Unable to communicate to native daemon to stop tether");
         }
-        BluetoothTetheringDataTracker.getInstance().stopReverseTether();
+//-vuk        BluetoothTetheringDataTracker.getInstance().stopReverseTether();
     }
 
     @Override
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index e513cee..3e0776f 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -43,6 +43,10 @@ import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.provider.Settings;
+//-vuk
+import android.server.BluetoothA2dpService;
+import android.server.BluetoothService;
+//-
 import android.server.search.SearchManagerService;
 import android.service.dreams.DreamService;
 import android.util.DisplayMetrics;
@@ -160,7 +164,11 @@ class ServerThread extends Thread {
         IPackageManager pm = null;
         Context context = null;
         WindowManagerService wm = null;
-        BluetoothManagerService bluetooth = null;
+//-vuk
+        BluetoothService bluetooth = null;
+        BluetoothA2dpService bluetoothA2dp = null;
+//        BluetoothManagerService bluetooth = null;
+//-
         DockObserver dock = null;
         RotationSwitchObserver rotateSwitch = null;
         UsbService usb = null;
@@ -354,8 +362,26 @@ class ServerThread extends Thread {
                 Slog.i(TAG, "No Bluetooth Service (factory test)");
             } else {
                 Slog.i(TAG, "Bluetooth Manager Service");
-                bluetooth = new BluetoothManagerService(context);
-                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth);
+//                bluetooth = new BluetoothManagerService(context);
+//                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth);
+//--vuk
+                bluetooth = new BluetoothService(context);
+                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
+                bluetooth.initAfterRegistration();
+
+                if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
+                    bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
+                    ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE,
+                                              bluetoothA2dp);
+                    bluetooth.initAfterA2dpRegistration();
+                }
+
+                int bluetoothOn = Settings.Secure.getInt(mContentResolver,
+                    Settings.Secure.BLUETOOTH_ON, 0);
+                if (bluetoothOn != 0) {
+                    bluetooth.enable();
+                }
+//--
             }
 
         } catch (RuntimeException e) {
@@ -940,6 +966,9 @@ class ServerThread extends Thread {
         final StatusBarManagerService statusBarF = statusBar;
         final DreamManagerService dreamyF = dreamy;
         final InputManagerService inputManagerF = inputManager;
+//-vuk
+        final BluetoothService bluetoothF = bluetooth;
+
         final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
 
         // We now tell the activity manager it is okay to run third party
@@ -1069,7 +1098,11 @@ class ServerThread extends Thread {
                 }
                 try {
                     // TODO(BT) Pass parameter to input manager
+//-vuk
                     if (inputManagerF != null) inputManagerF.systemReady();
+//-
+//                    if (inputManagerF != null) inputManagerF.systemReady(bluetoothF);
+
                 } catch (Throwable e) {
                     reportWtf("making InputManagerService ready", e);
                 }
diff --git a/services/java/com/android/server/power/ShutdownThread.java b/services/java/com/android/server/power/ShutdownThread.java
index 914b6dd..17ee80e 100644
--- a/services/java/com/android/server/power/ShutdownThread.java
+++ b/services/java/com/android/server/power/ShutdownThread.java
@@ -23,7 +23,7 @@ import android.app.Dialog;
 import android.app.IActivityManager;
 import android.app.ProgressDialog;
 import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.IBluetoothManager;
+import android.bluetooth.IBluetooth;
 import android.nfc.NfcAdapter;
 import android.nfc.INfcAdapter;
 import android.content.BroadcastReceiver;
@@ -417,9 +417,10 @@ public final class ShutdownThread extends Thread {
                         INfcAdapter.Stub.asInterface(ServiceManager.checkService("nfc"));
                 final ITelephony phone =
                         ITelephony.Stub.asInterface(ServiceManager.checkService("phone"));
-                final IBluetoothManager bluetooth =
-                        IBluetoothManager.Stub.asInterface(ServiceManager.checkService(
-                                BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE));
+                 final IBluetooth bluetooth =
+                         IBluetooth.Stub.asInterface(ServiceManager.checkService(
+                                 BluetoothAdapter.BLUETOOTH_SERVICE));
+
 
                 try {
                     nfcOff = nfc == null ||
