diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index fd14366..667c381 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -458,10 +458,10 @@
             </intent-filter>
         </activity>
 
-        <!-- bluetooth phone service -->
-        <service android:name="BluetoothPhoneService">
+        <!-- bluetooth headset service -->
+        <service android:name="BluetoothHeadsetService">
             <intent-filter>
-                <action android:name="android.bluetooth.IBluetoothHeadsetPhone" />
+                <action android:name="android.bluetooth.IBluetoothHeadset" />
             </intent-filter>
         </service>
 
diff --git a/src/com/android/phone/BluetoothAtPhonebook.java b/src/com/android/phone/BluetoothAtPhonebook.java
new file mode 100644
index 0000000..c9669c4
--- /dev/null
+++ b/src/com/android/phone/BluetoothAtPhonebook.java
@@ -0,0 +1,529 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.phone;
+
+import com.android.internal.telephony.GsmAlphabet;
+
+import android.bluetooth.AtCommandHandler;
+import android.bluetooth.AtCommandResult;
+import android.bluetooth.AtParser;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.HeadsetBase;
+import android.content.Context;
+import android.content.Intent;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.CallLog.Calls;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.PhoneLookup;
+import android.telephony.PhoneNumberUtils;
+import android.util.Log;
+
+import java.util.HashMap;
+
+/**
+ * Helper for managing phonebook presentation over AT commands
+ * @hide
+ */
+public class BluetoothAtPhonebook {
+    private static final String TAG = "BluetoothAtPhonebook";
+    private static final boolean DBG = false;
+
+    /** The projection to use when querying the call log database in response
+     *  to AT+CPBR for the MC, RC, and DC phone books (missed, received, and
+     *   dialed calls respectively)
+     */
+    private static final String[] CALLS_PROJECTION = new String[] {
+        Calls._ID, Calls.NUMBER
+    };
+
+    /** The projection to use when querying the contacts database in response
+     *   to AT+CPBR for the ME phonebook (saved phone numbers).
+     */
+    private static final String[] PHONES_PROJECTION = new String[] {
+        Phone._ID, Phone.DISPLAY_NAME, Phone.NUMBER, Phone.TYPE
+    };
+
+    /** Android supports as many phonebook entries as the flash can hold, but
+     *  BT periphals don't. Limit the number we'll report. */
+    private static final int MAX_PHONEBOOK_SIZE = 16384;
+
+    private static final String OUTGOING_CALL_WHERE = Calls.TYPE + "=" + Calls.OUTGOING_TYPE;
+    private static final String INCOMING_CALL_WHERE = Calls.TYPE + "=" + Calls.INCOMING_TYPE;
+    private static final String MISSED_CALL_WHERE = Calls.TYPE + "=" + Calls.MISSED_TYPE;
+    private static final String VISIBLE_PHONEBOOK_WHERE = Phone.IN_VISIBLE_GROUP + "=1";
+
+    private class PhonebookResult {
+        public Cursor  cursor; // result set of last query
+        public int     numberColumn;
+        public int     typeColumn;
+        public int     nameColumn;
+    };
+
+    private final Context mContext;
+    private final BluetoothHandsfree mHandsfree;
+
+    private String mCurrentPhonebook;
+    private String mCharacterSet = "UTF-8";
+
+    private int mCpbrIndex1, mCpbrIndex2;
+    private boolean mCheckingAccessPermission;
+
+    // package and class name to which we send intent to check phone book access permission
+    private static final String ACCESS_AUTHORITY_PACKAGE = "com.android.settings";
+    private static final String ACCESS_AUTHORITY_CLASS =
+        "com.android.settings.bluetooth.BluetoothPermissionRequest";
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+
+    private final HashMap<String, PhonebookResult> mPhonebooks =
+            new HashMap<String, PhonebookResult>(4);
+
+    public BluetoothAtPhonebook(Context context, BluetoothHandsfree handsfree) {
+        mContext = context;
+        mHandsfree = handsfree;
+        mPhonebooks.put("DC", new PhonebookResult());  // dialled calls
+        mPhonebooks.put("RC", new PhonebookResult());  // received calls
+        mPhonebooks.put("MC", new PhonebookResult());  // missed calls
+        mPhonebooks.put("ME", new PhonebookResult());  // mobile phonebook
+
+        mCurrentPhonebook = "ME";  // default to mobile phonebook
+
+        mCpbrIndex1 = mCpbrIndex2 = -1;
+        mCheckingAccessPermission = false;
+    }
+
+    /** Returns the last dialled number, or null if no numbers have been called */
+    public String getLastDialledNumber() {
+        String[] projection = {Calls.NUMBER};
+        Cursor cursor = mContext.getContentResolver().query(Calls.CONTENT_URI, projection,
+                Calls.TYPE + "=" + Calls.OUTGOING_TYPE, null, Calls.DEFAULT_SORT_ORDER +
+                " LIMIT 1");
+        if (cursor == null) return null;
+
+        if (cursor.getCount() < 1) {
+            cursor.close();
+            return null;
+        }
+        cursor.moveToNext();
+        int column = cursor.getColumnIndexOrThrow(Calls.NUMBER);
+        String number = cursor.getString(column);
+        cursor.close();
+        return number;
+    }
+
+    public void register(AtParser parser) {
+        // Select Character Set
+        parser.register("+CSCS", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                String result = "+CSCS: \"" + mCharacterSet + "\"";
+                return new AtCommandResult(result);
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (args.length < 1) {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+                String characterSet = (String)args[0];
+                characterSet = characterSet.replace("\"", "");
+                if (characterSet.equals("GSM") || characterSet.equals("IRA") ||
+                    characterSet.equals("UTF-8") || characterSet.equals("UTF8")) {
+                    mCharacterSet = characterSet;
+                    return new AtCommandResult(AtCommandResult.OK);
+                } else {
+                    return mHandsfree.reportCmeError(BluetoothCmeError.OPERATION_NOT_SUPPORTED);
+                }
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult( "+CSCS: (\"UTF-8\",\"IRA\",\"GSM\")");
+            }
+        });
+
+        // Select PhoneBook memory Storage
+        parser.register("+CPBS", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                // Return current size and max size
+                if ("SM".equals(mCurrentPhonebook)) {
+                    return new AtCommandResult("+CPBS: \"SM\",0," + getMaxPhoneBookSize(0));
+                }
+
+                PhonebookResult pbr = getPhonebookResult(mCurrentPhonebook, true);
+                if (pbr == null) {
+                    return mHandsfree.reportCmeError(BluetoothCmeError.OPERATION_NOT_ALLOWED);
+                }
+                int size = pbr.cursor.getCount();
+                return new AtCommandResult("+CPBS: \"" + mCurrentPhonebook + "\"," +
+                        size + "," + getMaxPhoneBookSize(size));
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // Select phonebook memory
+                if (args.length < 1 || !(args[0] instanceof String)) {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+                String pb = ((String)args[0]).trim();
+                while (pb.endsWith("\"")) pb = pb.substring(0, pb.length() - 1);
+                while (pb.startsWith("\"")) pb = pb.substring(1, pb.length());
+                if (getPhonebookResult(pb, false) == null && !"SM".equals(pb)) {
+                    if (DBG) log("Dont know phonebook: '" + pb + "'");
+                    return mHandsfree.reportCmeError(BluetoothCmeError.OPERATION_NOT_SUPPORTED);
+                }
+                mCurrentPhonebook = pb;
+                return new AtCommandResult(AtCommandResult.OK);
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+CPBS: (\"ME\",\"SM\",\"DC\",\"RC\",\"MC\")");
+            }
+        });
+
+        // Read PhoneBook Entries
+        parser.register("+CPBR", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // Phone Book Read Request
+                // AT+CPBR=<index1>[,<index2>]
+
+                if (mCpbrIndex1 != -1) {
+                    /* handling a CPBR at the moment, reject this CPBR command */
+                    return mHandsfree.reportCmeError(BluetoothCmeError.OPERATION_NOT_ALLOWED);
+                }
+
+                // Parse indexes
+                int index1;
+                int index2;
+                if (args.length < 1 || !(args[0] instanceof Integer)) {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                } else {
+                    index1 = (Integer)args[0];
+                }
+
+                if (args.length == 1) {
+                    index2 = index1;
+                } else if (!(args[1] instanceof Integer)) {
+                    return mHandsfree.reportCmeError(BluetoothCmeError.TEXT_HAS_INVALID_CHARS);
+                } else {
+                    index2 = (Integer)args[1];
+                }
+
+                mCpbrIndex1 = index1;
+                mCpbrIndex2 = index2;
+                mCheckingAccessPermission = true;
+
+                if (checkAccessPermission()) {
+                    mCheckingAccessPermission = false;
+                    AtCommandResult atResult = processCpbrCommand();
+                    mCpbrIndex1 = mCpbrIndex2 = -1;
+                    return atResult;
+                }
+
+                // no reponse here, will continue the process in handleAccessPermissionResult
+                return new AtCommandResult(AtCommandResult.UNSOLICITED);
+            };
+
+            @Override
+            public AtCommandResult handleTestCommand() {
+                /* Ideally we should return the maximum range of valid index's
+                 * for the selected phone book, but this causes problems for the
+                 * Parrot CK3300. So instead send just the range of currently
+                 * valid index's.
+                 */
+                int size;
+                if ("SM".equals(mCurrentPhonebook)) {
+                    size = 0;
+                } else {
+                    PhonebookResult pbr = getPhonebookResult(mCurrentPhonebook, false);
+                    if (pbr == null) {
+                        return mHandsfree.reportCmeError(BluetoothCmeError.OPERATION_NOT_ALLOWED);
+                    }
+                    size = pbr.cursor.getCount();
+                }
+
+                if (size == 0) {
+                    /* Sending "+CPBR: (1-0)" can confused some carkits, send "1-1"
+                     * instead */
+                    size = 1;
+                }
+                return new AtCommandResult("+CPBR: (1-" + size + "),30,30");
+            }
+        });
+    }
+
+    /* package */ void handleAccessPermissionResult(Intent intent) {
+        if (!mCheckingAccessPermission) {
+            return;
+        }
+
+        HeadsetBase headset = mHandsfree.getHeadset();
+        // ASSERT: (headset != null) && headSet.isConnected()
+        // REASON: mCheckingAccessPermission is true, otherwise resetAtState
+        //         has set mCheckingAccessPermission to false
+
+        if (intent.getAction().equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
+
+            if (intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT,
+                                   BluetoothDevice.CONNECTION_ACCESS_NO) ==
+                BluetoothDevice.CONNECTION_ACCESS_YES) {
+                BluetoothDevice remoteDevice = headset.getRemoteDevice();
+                if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
+                    remoteDevice.setTrust(true);
+                }
+
+                AtCommandResult cpbrResult = processCpbrCommand();
+                headset.sendURC(cpbrResult.toString());
+            } else {
+                headset.sendURC("ERROR");
+            }
+        }
+        mCpbrIndex1 = mCpbrIndex2 = -1;
+        mCheckingAccessPermission = false;
+    }
+
+    /** Get the most recent result for the given phone book,
+     *  with the cursor ready to go.
+     *  If force then re-query that phonebook
+     *  Returns null if the cursor is not ready
+     */
+    private synchronized PhonebookResult getPhonebookResult(String pb, boolean force) {
+        if (pb == null) {
+            return null;
+        }
+        PhonebookResult pbr = mPhonebooks.get(pb);
+        if (pbr == null) {
+            pbr = new PhonebookResult();
+        }
+        if (force || pbr.cursor == null) {
+            if (!queryPhonebook(pb, pbr)) {
+                return null;
+            }
+        }
+
+        return pbr;
+    }
+
+    private synchronized boolean queryPhonebook(String pb, PhonebookResult pbr) {
+        String where;
+        boolean ancillaryPhonebook = true;
+
+        if (pb.equals("ME")) {
+            ancillaryPhonebook = false;
+            where = VISIBLE_PHONEBOOK_WHERE;
+        } else if (pb.equals("DC")) {
+            where = OUTGOING_CALL_WHERE;
+        } else if (pb.equals("RC")) {
+            where = INCOMING_CALL_WHERE;
+        } else if (pb.equals("MC")) {
+            where = MISSED_CALL_WHERE;
+        } else {
+            return false;
+        }
+
+        if (pbr.cursor != null) {
+            pbr.cursor.close();
+            pbr.cursor = null;
+        }
+
+        if (ancillaryPhonebook) {
+            pbr.cursor = mContext.getContentResolver().query(
+                    Calls.CONTENT_URI, CALLS_PROJECTION, where, null,
+                    Calls.DEFAULT_SORT_ORDER + " LIMIT " + MAX_PHONEBOOK_SIZE);
+            if (pbr.cursor == null) return false;
+
+            pbr.numberColumn = pbr.cursor.getColumnIndexOrThrow(Calls.NUMBER);
+            pbr.typeColumn = -1;
+            pbr.nameColumn = -1;
+        } else {
+            pbr.cursor = mContext.getContentResolver().query(Phone.CONTENT_URI, PHONES_PROJECTION,
+                    where, null, Phone.NUMBER + " LIMIT " + MAX_PHONEBOOK_SIZE);
+            if (pbr.cursor == null) return false;
+
+            pbr.numberColumn = pbr.cursor.getColumnIndex(Phone.NUMBER);
+            pbr.typeColumn = pbr.cursor.getColumnIndex(Phone.TYPE);
+            pbr.nameColumn = pbr.cursor.getColumnIndex(Phone.DISPLAY_NAME);
+        }
+        Log.i(TAG, "Refreshed phonebook " + pb + " with " + pbr.cursor.getCount() + " results");
+        return true;
+    }
+
+    synchronized void resetAtState() {
+        mCharacterSet = "UTF-8";
+        mCpbrIndex1 = mCpbrIndex2 = -1;
+        mCheckingAccessPermission = false;
+    }
+
+    private synchronized int getMaxPhoneBookSize(int currSize) {
+        // some car kits ignore the current size and request max phone book
+        // size entries. Thus, it takes a long time to transfer all the
+        // entries. Use a heuristic to calculate the max phone book size
+        // considering future expansion.
+        // maxSize = currSize + currSize / 2 rounded up to nearest power of 2
+        // If currSize < 100, use 100 as the currSize
+
+        int maxSize = (currSize < 100) ? 100 : currSize;
+        maxSize += maxSize / 2;
+        return roundUpToPowerOfTwo(maxSize);
+    }
+
+    private int roundUpToPowerOfTwo(int x) {
+        x |= x >> 1;
+        x |= x >> 2;
+        x |= x >> 4;
+        x |= x >> 8;
+        x |= x >> 16;
+        return x + 1;
+    }
+
+    // process CPBR command after permission check
+    private AtCommandResult processCpbrCommand()
+    {
+        // Shortcut SM phonebook
+        if ("SM".equals(mCurrentPhonebook)) {
+            return new AtCommandResult(AtCommandResult.OK);
+        }
+
+        // Check phonebook
+        PhonebookResult pbr = getPhonebookResult(mCurrentPhonebook, false);
+        if (pbr == null) {
+            return mHandsfree.reportCmeError(BluetoothCmeError.OPERATION_NOT_ALLOWED);
+        }
+
+        // More sanity checks
+        // Send OK instead of ERROR if these checks fail.
+        // When we send error, certain kits like BMW disconnect the
+        // Handsfree connection.
+        if (pbr.cursor.getCount() == 0 || mCpbrIndex1 <= 0 || mCpbrIndex2 < mCpbrIndex1  ||
+            mCpbrIndex2 > pbr.cursor.getCount() || mCpbrIndex1 > pbr.cursor.getCount()) {
+            return new AtCommandResult(AtCommandResult.OK);
+        }
+
+        // Process
+        AtCommandResult result = new AtCommandResult(AtCommandResult.OK);
+        int errorDetected = -1; // no error
+        pbr.cursor.moveToPosition(mCpbrIndex1 - 1);
+        for (int index = mCpbrIndex1; index <= mCpbrIndex2; index++) {
+            String number = pbr.cursor.getString(pbr.numberColumn);
+            String name = null;
+            int type = -1;
+            if (pbr.nameColumn == -1) {
+                // try caller id lookup
+                // TODO: This code is horribly inefficient. I saw it
+                // take 7 seconds to process 100 missed calls.
+                Cursor c = mContext.getContentResolver().
+                    query(Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, number),
+                          new String[] {PhoneLookup.DISPLAY_NAME, PhoneLookup.TYPE},
+                          null, null, null);
+                if (c != null) {
+                    if (c.moveToFirst()) {
+                        name = c.getString(0);
+                        type = c.getInt(1);
+                    }
+                    c.close();
+                }
+                if (DBG && name == null) log("Caller ID lookup failed for " + number);
+
+            } else {
+                name = pbr.cursor.getString(pbr.nameColumn);
+            }
+            if (name == null) name = "";
+            name = name.trim();
+            if (name.length() > 28) name = name.substring(0, 28);
+
+            if (pbr.typeColumn != -1) {
+                type = pbr.cursor.getInt(pbr.typeColumn);
+                name = name + "/" + getPhoneType(type);
+            }
+
+            if (number == null) number = "";
+            int regionType = PhoneNumberUtils.toaFromString(number);
+
+            number = number.trim();
+            number = PhoneNumberUtils.stripSeparators(number);
+            if (number.length() > 30) number = number.substring(0, 30);
+            if (number.equals("-1")) {
+                // unknown numbers are stored as -1 in our database
+                number = "";
+                name = mContext.getString(R.string.unknown);
+            }
+
+            // TODO(): Handle IRA commands. It's basically
+            // a 7 bit ASCII character set.
+            if (!name.equals("") && mCharacterSet.equals("GSM")) {
+                byte[] nameByte = GsmAlphabet.stringToGsm8BitPacked(name);
+                if (nameByte == null) {
+                    name = mContext.getString(R.string.unknown);
+                } else {
+                    name = new String(nameByte);
+                }
+            }
+
+            result.addResponse("+CPBR: " + index + ",\"" + number + "\"," +
+                               regionType + ",\"" + name + "\"");
+            if (!pbr.cursor.moveToNext()) {
+                break;
+            }
+        }
+        return result;
+    }
+
+    // Check if the remote device has premission to read our phone book
+    // Return true if it has the permission
+    //        false if not known and we have sent our Intent to check
+    private boolean checkAccessPermission() {
+        BluetoothDevice remoteDevice = mHandsfree.getHeadset().getRemoteDevice();
+
+        boolean trust = remoteDevice.getTrustState();
+
+        if (trust) {
+            return true;
+        }
+
+        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
+        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
+        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE,
+                        BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, remoteDevice);
+        // Leave EXTRA_PACKAGE_NAME and EXTRA_CLASS_NAME field empty
+        // BluetoothHandsfree's broadcast receiver is anonymous, cannot be targeted
+        mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
+
+        return false;
+    }
+
+    private static String getPhoneType(int type) {
+        switch (type) {
+            case Phone.TYPE_HOME:
+                return "H";
+            case Phone.TYPE_MOBILE:
+                return "M";
+            case Phone.TYPE_WORK:
+                return "W";
+            case Phone.TYPE_FAX_HOME:
+            case Phone.TYPE_FAX_WORK:
+                return "F";
+            case Phone.TYPE_OTHER:
+            case Phone.TYPE_CUSTOM:
+            default:
+                return "O";
+        }
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/src/com/android/phone/BluetoothCmeError.java b/src/com/android/phone/BluetoothCmeError.java
new file mode 100644
index 0000000..aa5e887
--- /dev/null
+++ b/src/com/android/phone/BluetoothCmeError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.phone;
+
+/* Constants for extended AT error codes specified by the Handsfree profile. */
+public class BluetoothCmeError {
+    public static final int AG_FAILURE = 0;
+    public static final int NO_CONNECTION_TO_PHONE = 1;
+    public static final int OPERATION_NOT_ALLOWED = 3;
+    public static final int OPERATION_NOT_SUPPORTED = 4;
+    public static final int PIN_REQUIRED = 5;
+    public static final int SIM_MISSING = 10;
+    public static final int SIM_PIN_REQUIRED = 11;
+    public static final int SIM_PUK_REQUIRED = 12;
+    public static final int SIM_FAILURE = 13;
+    public static final int SIM_BUSY = 14;
+    public static final int WRONG_PASSWORD = 16;
+    public static final int SIM_PIN2_REQUIRED = 17;
+    public static final int SIM_PUK2_REQUIRED = 18;
+    public static final int MEMORY_FULL = 20;
+    public static final int INVALID_INDEX = 21;
+    public static final int MEMORY_FAILURE = 23;
+    public static final int TEXT_TOO_LONG = 24;
+    public static final int TEXT_HAS_INVALID_CHARS = 25;
+    public static final int DIAL_STRING_TOO_LONG = 26;
+    public static final int DIAL_STRING_HAS_INVALID_CHARS = 27;
+    public static final int NO_SERVICE = 30;
+    public static final int ONLY_911_ALLOWED = 32;
+}
diff --git a/src/com/android/phone/BluetoothHandsfree.java b/src/com/android/phone/BluetoothHandsfree.java
new file mode 100644
index 0000000..0238c28
--- /dev/null
+++ b/src/com/android/phone/BluetoothHandsfree.java
@@ -0,0 +1,3092 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.phone;
+
+import android.bluetooth.AtCommandHandler;
+import android.bluetooth.AtCommandResult;
+import android.bluetooth.AtParser;
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAssignedNumbers;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothServerSocket;
+import android.bluetooth.BluetoothSocket;
+import android.bluetooth.HeadsetBase;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.media.AudioManager;
+import android.net.Uri;
+import android.os.AsyncResult;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.telephony.PhoneConstants;
+
+import android.util.Log;
+
+import com.android.internal.telephony.Call;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.CallManager;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.LinkedList;
+
+/**
+ * Bluetooth headset manager for the Phone app.
+ * @hide
+ */
+public class BluetoothHandsfree {
+    private static final String TAG = "Bluetooth HS/HF";
+    private static final boolean DBG = (PhoneGlobals.DBG_LEVEL >= 1)
+            && (SystemProperties.getInt("ro.debuggable", 0) == 1);
+    private static final boolean VDBG = (PhoneGlobals.DBG_LEVEL >= 2);  // even more logging
+
+    public static final int TYPE_UNKNOWN           = 0;
+    public static final int TYPE_HEADSET           = 1;
+    public static final int TYPE_HANDSFREE         = 2;
+
+    /** The singleton instance. */
+    private static BluetoothHandsfree sInstance;
+
+    private final Context mContext;
+    private final BluetoothAdapter mAdapter;
+    private final CallManager mCM;
+    private BluetoothA2dp mA2dp;
+
+    private BluetoothDevice mA2dpDevice;
+    private int mA2dpState;
+    private boolean mPendingAudioState;
+    private int mAudioState;
+
+    private ServiceState mServiceState;
+    private HeadsetBase mHeadset;
+    private BluetoothHeadset mBluetoothHeadset;
+    private int mHeadsetType;   // TYPE_UNKNOWN when not connected
+    private boolean mAudioPossible;
+    private BluetoothSocket mConnectedSco;
+
+    private IncomingScoAcceptThread mIncomingScoThread = null;
+    private ScoSocketConnectThread mConnectScoThread = null;
+    private SignalScoCloseThread mSignalScoCloseThread = null;
+
+    private AudioManager mAudioManager;
+    private PowerManager mPowerManager;
+
+    private boolean mPendingSco;  // waiting for a2dp sink to suspend before establishing SCO
+    private boolean mA2dpSuspended;
+    private boolean mUserWantsAudio;
+    private WakeLock mStartCallWakeLock;  // held while waiting for the intent to start call
+    private WakeLock mStartVoiceRecognitionWakeLock;  // held while waiting for voice recognition
+
+    // AT command state
+    private static final int GSM_MAX_CONNECTIONS = 6;  // Max connections allowed by GSM
+    private static final int CDMA_MAX_CONNECTIONS = 2;  // Max connections allowed by CDMA
+
+    private long mBgndEarliestConnectionTime = 0;
+    private boolean mClip = false;  // Calling Line Information Presentation
+    private boolean mIndicatorsEnabled = false;
+    private boolean mCmee = false;  // Extended Error reporting
+    private long[] mClccTimestamps; // Timestamps associated with each clcc index
+    private boolean[] mClccUsed;     // Is this clcc index in use
+    private boolean mWaitingForCallStart;
+    private boolean mWaitingForVoiceRecognition;
+    // do not connect audio until service connection is established
+    // for 3-way supported devices, this is after AT+CHLD
+    // for non-3-way supported devices, this is after AT+CMER (see spec)
+    private boolean mServiceConnectionEstablished;
+
+    private final BluetoothPhoneState mBluetoothPhoneState;  // for CIND and CIEV updates
+    private final BluetoothAtPhonebook mPhonebook;
+    private final BluetoothSMSAccess mSMSAccess;
+    private PhoneConstants.State mPhoneState = PhoneConstants.State.IDLE;
+    CdmaPhoneCallState.PhoneCallState mCdmaThreeWayCallState =
+                                            CdmaPhoneCallState.PhoneCallState.IDLE;
+
+    private DebugThread mDebugThread;
+    private int mScoGain = Integer.MIN_VALUE;
+
+    private static Intent sVoiceCommandIntent;
+
+    // Audio parameters
+    private static final String HEADSET_NREC = "bt_headset_nrec";
+    private static final String HEADSET_NAME = "bt_headset_name";
+
+    private int mRemoteBrsf = 0;
+    private int mLocalBrsf = 0;
+
+    // CDMA specific flag used in context with BT devices having display capabilities
+    // to show which Caller is active. This state might not be always true as in CDMA
+    // networks if a caller drops off no update is provided to the Phone.
+    // This flag is just used as a toggle to provide a update to the BT device to specify
+    // which caller is active.
+    private boolean mCdmaIsSecondCallActive = false;
+    private boolean mCdmaCallsSwapped = false;
+
+    /* Constants from Bluetooth Specification Hands-Free profile version 1.5 */
+    private static final int BRSF_AG_THREE_WAY_CALLING = 1 << 0;
+    private static final int BRSF_AG_EC_NR = 1 << 1;
+    private static final int BRSF_AG_VOICE_RECOG = 1 << 2;
+    private static final int BRSF_AG_IN_BAND_RING = 1 << 3;
+    private static final int BRSF_AG_VOICE_TAG_NUMBE = 1 << 4;
+    private static final int BRSF_AG_REJECT_CALL = 1 << 5;
+    private static final int BRSF_AG_ENHANCED_CALL_STATUS = 1 <<  6;
+    private static final int BRSF_AG_ENHANCED_CALL_CONTROL = 1 << 7;
+    private static final int BRSF_AG_ENHANCED_ERR_RESULT_CODES = 1 << 8;
+
+    private static final int BRSF_HF_EC_NR = 1 << 0;
+    private static final int BRSF_HF_CW_THREE_WAY_CALLING = 1 << 1;
+    private static final int BRSF_HF_CLIP = 1 << 2;
+    private static final int BRSF_HF_VOICE_REG_ACT = 1 << 3;
+    private static final int BRSF_HF_REMOTE_VOL_CONTROL = 1 << 4;
+    private static final int BRSF_HF_ENHANCED_CALL_STATUS = 1 <<  5;
+    private static final int BRSF_HF_ENHANCED_CALL_CONTROL = 1 << 6;
+
+    // VirtualCall - true if Virtual Call is active, false otherwise
+    private boolean mVirtualCallStarted = false;
+
+    // Voice Recognition - true if Voice Recognition is active, false otherwise
+    private boolean mVoiceRecognitionStarted;
+
+    private HandsfreeMessageHandler mHandler;
+
+    public static String typeToString(int type) {
+        switch (type) {
+        case TYPE_UNKNOWN:
+            return "unknown";
+        case TYPE_HEADSET:
+            return "headset";
+        case TYPE_HANDSFREE:
+            return "handsfree";
+        }
+        return null;
+    }
+
+    /**
+     * Initialize the singleton BluetoothHandsfree instance.
+     * This is only done once, at startup, from PhoneGlobals.onCreate().
+     */
+    /* package */ static BluetoothHandsfree init(Context context, CallManager cm) {
+        synchronized (BluetoothHandsfree.class) {
+            if (sInstance == null) {
+                sInstance = new BluetoothHandsfree(context, cm);
+            } else {
+                Log.wtf(TAG, "init() called multiple times!  sInstance = " + sInstance);
+            }
+            return sInstance;
+        }
+    }
+
+    /** Private constructor; @see init() */
+    private BluetoothHandsfree(Context context, CallManager cm) {
+        mCM = cm;
+        mContext = context;
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        boolean bluetoothCapable = (mAdapter != null);
+        mHeadset = null;
+        mHeadsetType = TYPE_UNKNOWN; // nothing connected yet
+        if (bluetoothCapable) {
+            mAdapter.getProfileProxy(mContext, mProfileListener,
+                                     BluetoothProfile.A2DP);
+        }
+        mA2dpState = BluetoothA2dp.STATE_DISCONNECTED;
+        mA2dpDevice = null;
+        mA2dpSuspended = false;
+
+        mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        mStartCallWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
+                                                       TAG + ":StartCall");
+        mStartCallWakeLock.setReferenceCounted(false);
+        mStartVoiceRecognitionWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
+                                                       TAG + ":VoiceRecognition");
+        mStartVoiceRecognitionWakeLock.setReferenceCounted(false);
+
+        mLocalBrsf = BRSF_AG_THREE_WAY_CALLING |
+                     BRSF_AG_EC_NR |
+                     BRSF_AG_REJECT_CALL |
+                     BRSF_AG_ENHANCED_CALL_STATUS;
+
+        if (sVoiceCommandIntent == null) {
+            sVoiceCommandIntent = new Intent(Intent.ACTION_VOICE_COMMAND);
+            sVoiceCommandIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        }
+        if (mContext.getPackageManager().resolveActivity(sVoiceCommandIntent, 0) != null &&
+                BluetoothHeadset.isBluetoothVoiceDialingEnabled(mContext)) {
+            mLocalBrsf |= BRSF_AG_VOICE_RECOG;
+        }
+
+        HandlerThread thread = new HandlerThread("BluetoothHandsfreeHandler");
+        thread.start();
+        Looper looper = thread.getLooper();
+        mHandler = new HandsfreeMessageHandler(looper);
+        mBluetoothPhoneState = new BluetoothPhoneState();
+        mUserWantsAudio = true;
+        mVirtualCallStarted = false;
+        mVoiceRecognitionStarted = false;
+        mPhonebook = new BluetoothAtPhonebook(mContext, this);
+        mSMSAccess = new BluetoothSMSAccess(mContext, this);
+        mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+        cdmaSetSecondCallState(false);
+
+        if (bluetoothCapable) {
+            resetAtState();
+        }
+
+    }
+
+    /**
+     * A thread that runs in the background waiting for a Sco Server Socket to
+     * accept a connection. Even after a connection has been accepted, the Sco Server
+     * continues to listen for new connections.
+     */
+    private class IncomingScoAcceptThread extends Thread{
+        private final BluetoothServerSocket mIncomingServerSocket;
+        private BluetoothSocket mIncomingSco;
+        private boolean stopped = false;
+
+        public IncomingScoAcceptThread() {
+            BluetoothServerSocket serverSocket = null;
+            try {
+                serverSocket = BluetoothAdapter.listenUsingScoOn();
+            } catch (IOException e) {
+                Log.e(TAG, "Could not create BluetoothServerSocket");
+                stopped = true;
+            }
+            mIncomingServerSocket = serverSocket;
+        }
+
+        @Override
+        public void run() {
+            while (!stopped) {
+                try {
+                    mIncomingSco = mIncomingServerSocket.accept();
+                } catch (IOException e) {
+                    Log.e(TAG, "BluetoothServerSocket could not accept connection");
+                }
+
+                if (mIncomingSco != null) {
+                    connectSco();
+                }
+            }
+        }
+
+        private void connectSco() {
+            synchronized (BluetoothHandsfree.this) {
+                if (!Thread.interrupted() && isHeadsetConnected() &&
+                    (mAudioPossible || allowAudioAnytime()) &&
+                    mConnectedSco == null) {
+                    Log.i(TAG, "Routing audio for incoming SCO connection");
+                    mConnectedSco = mIncomingSco;
+                    mAudioManager.setBluetoothScoOn(true);
+                    setAudioState(BluetoothHeadset.STATE_AUDIO_CONNECTED,
+                        mHeadset.getRemoteDevice());
+
+                    if (mSignalScoCloseThread == null) {
+                        mSignalScoCloseThread = new SignalScoCloseThread();
+                        mSignalScoCloseThread.setName("SignalScoCloseThread");
+                        mSignalScoCloseThread.start();
+                    }
+                } else {
+                    Log.i(TAG, "Rejecting incoming SCO connection");
+                    try {
+                        mIncomingSco.close();
+                    }catch (IOException e) {
+                        Log.e(TAG, "Error when closing incoming Sco socket");
+                    }
+                    mIncomingSco = null;
+                }
+            }
+        }
+
+        // must be called with BluetoothHandsfree locked
+        void shutdown() {
+            try {
+                mIncomingServerSocket.close();
+            } catch (IOException e) {
+                Log.w(TAG, "Error when closing server socket");
+            }
+            stopped = true;
+            interrupt();
+        }
+    }
+
+    /**
+     * A thread that runs in the background waiting for a Sco Socket to
+     * connect.Once the socket is connected, this thread shall be
+     * shutdown.
+     */
+    private class ScoSocketConnectThread extends Thread{
+        private BluetoothSocket mOutgoingSco;
+
+        public ScoSocketConnectThread(BluetoothDevice device) {
+            try {
+                mOutgoingSco = device.createScoSocket();
+            } catch (IOException e) {
+                Log.w(TAG, "Could not create BluetoothSocket");
+                failedScoConnect();
+            }
+        }
+
+        @Override
+        public void run() {
+            try {
+                mOutgoingSco.connect();
+            }catch (IOException connectException) {
+                Log.e(TAG, "BluetoothSocket could not connect");
+                mOutgoingSco = null;
+                failedScoConnect();
+            }
+
+            if (mOutgoingSco != null) {
+                connectSco();
+            }
+        }
+
+        private void connectSco() {
+            synchronized (BluetoothHandsfree.this) {
+                if (!Thread.interrupted() && isHeadsetConnected() && mConnectedSco == null) {
+                    if (VDBG) log("Routing audio for outgoing SCO conection");
+                    mConnectedSco = mOutgoingSco;
+                    mAudioManager.setBluetoothScoOn(true);
+
+                    setAudioState(BluetoothHeadset.STATE_AUDIO_CONNECTED,
+                      mHeadset.getRemoteDevice());
+
+                    if (mSignalScoCloseThread == null) {
+                        mSignalScoCloseThread = new SignalScoCloseThread();
+                        mSignalScoCloseThread.setName("SignalScoCloseThread");
+                        mSignalScoCloseThread.start();
+                    }
+                } else {
+                    if (VDBG) log("Rejecting new connected outgoing SCO socket");
+                    try {
+                        mOutgoingSco.close();
+                    }catch (IOException e) {
+                        Log.e(TAG, "Error when closing Sco socket");
+                    }
+                    mOutgoingSco = null;
+                    failedScoConnect();
+                }
+            }
+        }
+
+        private void failedScoConnect() {
+            // Wait for couple of secs before sending AUDIO_STATE_DISCONNECTED,
+            // since an incoming SCO connection can happen immediately with
+            // certain headsets.
+            Message msg = Message.obtain(mHandler, SCO_AUDIO_STATE);
+            msg.obj = mHeadset.getRemoteDevice();
+            mHandler.sendMessageDelayed(msg, 2000);
+
+            // Sync with interrupt() statement of shutdown method
+            // This prevents resetting of a valid mConnectScoThread.
+            // If this thread has been interrupted, it has been shutdown and
+            // mConnectScoThread is/will be reset by the outer class.
+            // We do not want to do it here since mConnectScoThread could be
+            // assigned with a new object.
+            synchronized (ScoSocketConnectThread.this) {
+                if (!isInterrupted()) {
+                    resetConnectScoThread();
+                }
+            }
+        }
+
+        // must be called with BluetoothHandsfree locked
+        void shutdown() {
+            closeConnectedSco();
+
+            // sync with isInterrupted() check in failedScoConnect method
+            // see explanation there
+            synchronized (ScoSocketConnectThread.this) {
+                interrupt();
+            }
+        }
+    }
+
+    /*
+     * Signals when a Sco connection has been closed
+     */
+    private class SignalScoCloseThread extends Thread{
+        private boolean stopped = false;
+
+        @Override
+        public void run() {
+            while (!stopped) {
+                BluetoothSocket connectedSco = null;
+                synchronized (BluetoothHandsfree.this) {
+                    connectedSco = mConnectedSco;
+                }
+                if (connectedSco != null) {
+                    byte b[] = new byte[1];
+                    InputStream inStream = null;
+                    try {
+                        inStream = connectedSco.getInputStream();
+                    } catch (IOException e) {}
+
+                    if (inStream != null) {
+                        try {
+                            // inStream.read is a blocking call that won't ever
+                            // return anything, but will throw an exception if the
+                            // connection is closed
+                            int ret = inStream.read(b, 0, 1);
+                        }catch (IOException connectException) {
+                            // call a message to close this thread and turn off audio
+                            // we can't call audioOff directly because then
+                            // the thread would try to close itself
+                            Message msg = Message.obtain(mHandler, SCO_CLOSED);
+                            mHandler.sendMessage(msg);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        // must be called with BluetoothHandsfree locked
+        void shutdown() {
+            stopped = true;
+            closeConnectedSco();
+            interrupt();
+        }
+    }
+
+    private void connectScoThread(){
+        // Sync with setting mConnectScoThread to null to assure the validity of
+        // the condition
+        synchronized (ScoSocketConnectThread.class) {
+            if (mConnectScoThread == null) {
+                BluetoothDevice device = mHeadset.getRemoteDevice();
+                if (getAudioState(device) == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
+                    setAudioState(BluetoothHeadset.STATE_AUDIO_CONNECTING, device);
+                }
+
+                mConnectScoThread = new ScoSocketConnectThread(mHeadset.getRemoteDevice());
+                mConnectScoThread.setName("HandsfreeScoSocketConnectThread");
+
+                mConnectScoThread.start();
+            }
+        }
+    }
+
+    private void resetConnectScoThread() {
+        // Sync with if (mConnectScoThread == null) check
+        synchronized (ScoSocketConnectThread.class) {
+            mConnectScoThread = null;
+        }
+    }
+
+    // must be called with BluetoothHandsfree locked
+    private void closeConnectedSco() {
+        if (mConnectedSco != null) {
+            try {
+                mConnectedSco.close();
+            } catch (IOException e) {
+                Log.e(TAG, "Error when closing Sco socket");
+            }
+
+            BluetoothDevice device = null;
+            if (mHeadset != null) {
+                device = mHeadset.getRemoteDevice();
+            }
+            mAudioManager.setBluetoothScoOn(false);
+            setAudioState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, device);
+
+            mConnectedSco = null;
+        }
+    }
+
+    /* package */ synchronized void onBluetoothEnabled() {
+        /* Bluez has a bug where it will always accept and then orphan
+         * incoming SCO connections, regardless of whether we have a listening
+         * SCO socket. So the best thing to do is always run a listening socket
+         * while bluetooth is on so that at least we can disconnect it
+         * immediately when we don't want it.
+         */
+
+        if (mIncomingScoThread == null) {
+            mIncomingScoThread = new IncomingScoAcceptThread();
+            mIncomingScoThread.setName("incomingScoAcceptThread");
+            mIncomingScoThread.start();
+        }
+    }
+
+    /* package */ synchronized void onBluetoothDisabled() {
+        // Close off the SCO sockets
+        audioOff();
+
+        if (mIncomingScoThread != null) {
+            mIncomingScoThread.shutdown();
+            mIncomingScoThread = null;
+        }
+    }
+
+    private boolean isHeadsetConnected() {
+        if (mHeadset == null || mHeadsetType == TYPE_UNKNOWN) {
+            return false;
+        }
+        return mHeadset.isConnected();
+    }
+
+    /* package */ synchronized void connectHeadset(HeadsetBase headset, int headsetType) {
+        mHeadset = headset;
+        mHeadsetType = headsetType;
+        if (mHeadsetType == TYPE_HEADSET) {
+            initializeHeadsetAtParser();
+        } else {
+            initializeHandsfreeAtParser();
+        }
+
+        // Headset vendor-specific commands
+        registerAllVendorSpecificCommands();
+
+        headset.startEventThread();
+        configAudioParameters();
+
+        if (inDebug()) {
+            startDebug();
+        }
+
+        if (isIncallAudio()) {
+            audioOn();
+        } else if ( mCM.getFirstActiveRingingCall().isRinging()) {
+            // need to update HS with RING when single ringing call exist
+            mBluetoothPhoneState.ring();
+        }
+    }
+
+    /* returns true if there is some kind of in-call audio we may wish to route
+     * bluetooth to */
+    private boolean isIncallAudio() {
+        Call.State state = mCM.getActiveFgCallState();
+
+        return (state == Call.State.ACTIVE || state == Call.State.ALERTING);
+    }
+
+    /* package */ synchronized void disconnectHeadset() {
+        audioOff();
+
+        // No need to check if isVirtualCallInProgress()
+        // terminateScoUsingVirtualVoiceCall() does the check
+        terminateScoUsingVirtualVoiceCall();
+
+        mHeadsetType = TYPE_UNKNOWN;
+        stopDebug();
+        resetAtState();
+    }
+
+    /* package */ synchronized void resetAtState() {
+        mClip = false;
+        mIndicatorsEnabled = false;
+        mServiceConnectionEstablished = false;
+        mCmee = false;
+        mClccTimestamps = new long[GSM_MAX_CONNECTIONS];
+        mClccUsed = new boolean[GSM_MAX_CONNECTIONS];
+        for (int i = 0; i < GSM_MAX_CONNECTIONS; i++) {
+            mClccUsed[i] = false;
+        }
+        mRemoteBrsf = 0;
+        mPhonebook.resetAtState();
+        mSMSAccess.resetAtState();
+    }
+
+    /* package */ HeadsetBase getHeadset() {
+        return mHeadset;
+    }
+
+    private void configAudioParameters() {
+        String name = mHeadset.getRemoteDevice().getName();
+        if (name == null) {
+            name = "<unknown>";
+        }
+        mAudioManager.setParameters(HEADSET_NAME+"="+name+";"+HEADSET_NREC+"=on");
+    }
+
+
+    /** Represents the data that we send in a +CIND or +CIEV command to the HF
+     */
+    private class BluetoothPhoneState {
+        // 0: no service
+        // 1: service
+        private int mService;
+
+        // 0: no active call
+        // 1: active call (where active means audio is routed - not held call)
+        private int mCall;
+
+        // 0: not in call setup
+        // 1: incoming call setup
+        // 2: outgoing call setup
+        // 3: remote party being alerted in an outgoing call setup
+        private int mCallsetup;
+
+        // 0: no calls held
+        // 1: held call and active call
+        // 2: held call only
+        private int mCallheld;
+
+        // cellular signal strength of AG: 0-5
+        private int mSignal;
+
+        // cellular signal strength in CSQ rssi scale
+        private int mRssi;  // for CSQ
+
+        // 0: roaming not active (home)
+        // 1: roaming active
+        private int mRoam;
+
+        // battery charge of AG: 0-5
+        private int mBattchg;
+
+        // 0: not registered
+        // 1: registered, home network
+        // 5: registered, roaming
+        private int mStat;  // for CREG
+
+        private String mRingingNumber;  // Context for in-progress RING's
+        private int    mRingingType;
+        private boolean mIgnoreRing = false;
+        private boolean mStopRing = false;
+
+        // current or last call start timestamp
+        private long mCallStartTime = 0;
+        // time window to reconnect remotely-disconnected SCO
+        // in mili-seconds
+        private static final int RETRY_SCO_TIME_WINDOW = 1000;
+
+        private static final int SERVICE_STATE_CHANGED = 1;
+        private static final int PRECISE_CALL_STATE_CHANGED = 2;
+        private static final int RING = 3;
+        private static final int PHONE_CDMA_CALL_WAITING = 4;
+
+        private Handler mStateChangeHandler = new Handler() {
+            @Override
+            public void handleMessage(Message msg) {
+                switch(msg.what) {
+                case RING:
+                    AtCommandResult result = ring();
+                    if (result != null) {
+                        sendURC(result.toString());
+                    }
+                    break;
+                case SERVICE_STATE_CHANGED:
+                    ServiceState state = (ServiceState) ((AsyncResult) msg.obj).result;
+                    updateServiceState(sendUpdate(), state);
+                    break;
+                case PRECISE_CALL_STATE_CHANGED:
+                case PHONE_CDMA_CALL_WAITING:
+                    Connection connection = null;
+                    if (((AsyncResult) msg.obj).result instanceof Connection) {
+                        connection = (Connection) ((AsyncResult) msg.obj).result;
+                    }
+                    handlePreciseCallStateChange(sendUpdate(), connection);
+                    break;
+                }
+            }
+        };
+
+        private BluetoothPhoneState() {
+            // init members
+            // TODO May consider to repalce the default phone's state and signal
+            //      by CallManagter's state and signal
+            updateServiceState(false, mCM.getDefaultPhone().getServiceState());
+            handlePreciseCallStateChange(false, null);
+            mBattchg = 5;  // There is currently no API to get battery level
+                           // on demand, so set to 5 and wait for an update
+            mSignal = asuToSignal(mCM.getDefaultPhone().getSignalStrength());
+
+            // register for updates
+            // Use the service state of default phone as BT service state to
+            // avoid situation such as no cell or wifi connection but still
+            // reporting in service (since SipPhone always reports in service).
+            mCM.getDefaultPhone().registerForServiceStateChanged(mStateChangeHandler,
+                                                  SERVICE_STATE_CHANGED, null);
+            mCM.registerForPreciseCallStateChanged(mStateChangeHandler,
+                    PRECISE_CALL_STATE_CHANGED, null);
+            mCM.registerForCallWaiting(mStateChangeHandler,
+                PHONE_CDMA_CALL_WAITING, null);
+
+            IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
+            filter.addAction(TelephonyIntents.ACTION_SIGNAL_STRENGTH_CHANGED);
+            filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+            filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
+            mContext.registerReceiver(mStateReceiver, filter);
+        }
+
+        private void updateBtPhoneStateAfterRadioTechnologyChange() {
+            if(VDBG) Log.d(TAG, "updateBtPhoneStateAfterRadioTechnologyChange...");
+
+            //Unregister all events from the old obsolete phone
+            mCM.getDefaultPhone().unregisterForServiceStateChanged(mStateChangeHandler);
+            mCM.unregisterForPreciseCallStateChanged(mStateChangeHandler);
+            mCM.unregisterForCallWaiting(mStateChangeHandler);
+
+            //Register all events new to the new active phone
+            mCM.getDefaultPhone().registerForServiceStateChanged(mStateChangeHandler,
+                                                  SERVICE_STATE_CHANGED, null);
+            mCM.registerForPreciseCallStateChanged(mStateChangeHandler,
+                    PRECISE_CALL_STATE_CHANGED, null);
+            mCM.registerForCallWaiting(mStateChangeHandler,
+                PHONE_CDMA_CALL_WAITING, null);
+        }
+
+        private boolean sendUpdate() {
+            return isHeadsetConnected() && mHeadsetType == TYPE_HANDSFREE && mIndicatorsEnabled
+                   && mServiceConnectionEstablished;
+        }
+
+        private boolean sendClipUpdate() {
+            return isHeadsetConnected() && mHeadsetType == TYPE_HANDSFREE && mClip &&
+                   mServiceConnectionEstablished;
+        }
+
+        private boolean sendRingUpdate() {
+            if (isHeadsetConnected() && !mIgnoreRing && !mStopRing &&
+                    mCM.getFirstActiveRingingCall().isRinging()) {
+                if (mHeadsetType == TYPE_HANDSFREE) {
+                    return mServiceConnectionEstablished ? true : false;
+                }
+                return true;
+            }
+            return false;
+        }
+
+        private void stopRing() {
+            mStopRing = true;
+        }
+
+        /* convert [0,31] ASU signal strength to the [0,5] expected by
+         * bluetooth devices. Scale is similar to status bar policy
+         */
+        private int gsmAsuToSignal(SignalStrength signalStrength) {
+            int asu = signalStrength.getGsmSignalStrength();
+            if      (asu >= 16) return 5;
+            else if (asu >= 8)  return 4;
+            else if (asu >= 4)  return 3;
+            else if (asu >= 2)  return 2;
+            else if (asu >= 1)  return 1;
+            else                return 0;
+        }
+
+        /**
+         * Convert the cdma / evdo db levels to appropriate icon level.
+         * The scale is similar to the one used in status bar policy.
+         *
+         * @param signalStrength
+         * @return the icon level
+         */
+        private int cdmaDbmEcioToSignal(SignalStrength signalStrength) {
+            int levelDbm = 0;
+            int levelEcio = 0;
+            int cdmaIconLevel = 0;
+            int evdoIconLevel = 0;
+            int cdmaDbm = signalStrength.getCdmaDbm();
+            int cdmaEcio = signalStrength.getCdmaEcio();
+
+            if (cdmaDbm >= -75) levelDbm = 4;
+            else if (cdmaDbm >= -85) levelDbm = 3;
+            else if (cdmaDbm >= -95) levelDbm = 2;
+            else if (cdmaDbm >= -100) levelDbm = 1;
+            else levelDbm = 0;
+
+            // Ec/Io are in dB*10
+            if (cdmaEcio >= -90) levelEcio = 4;
+            else if (cdmaEcio >= -110) levelEcio = 3;
+            else if (cdmaEcio >= -130) levelEcio = 2;
+            else if (cdmaEcio >= -150) levelEcio = 1;
+            else levelEcio = 0;
+
+            cdmaIconLevel = (levelDbm < levelEcio) ? levelDbm : levelEcio;
+
+            if (mServiceState != null &&
+                  (mServiceState.getNetworkType() == TelephonyManager.NETWORK_TYPE_EVDO_0 ||
+                   mServiceState.getNetworkType() == TelephonyManager.NETWORK_TYPE_EVDO_A)) {
+                  int evdoEcio = signalStrength.getEvdoEcio();
+                  int evdoSnr = signalStrength.getEvdoSnr();
+                  int levelEvdoEcio = 0;
+                  int levelEvdoSnr = 0;
+
+                  // Ec/Io are in dB*10
+                  if (evdoEcio >= -650) levelEvdoEcio = 4;
+                  else if (evdoEcio >= -750) levelEvdoEcio = 3;
+                  else if (evdoEcio >= -900) levelEvdoEcio = 2;
+                  else if (evdoEcio >= -1050) levelEvdoEcio = 1;
+                  else levelEvdoEcio = 0;
+
+                  if (evdoSnr > 7) levelEvdoSnr = 4;
+                  else if (evdoSnr > 5) levelEvdoSnr = 3;
+                  else if (evdoSnr > 3) levelEvdoSnr = 2;
+                  else if (evdoSnr > 1) levelEvdoSnr = 1;
+                  else levelEvdoSnr = 0;
+
+                  evdoIconLevel = (levelEvdoEcio < levelEvdoSnr) ? levelEvdoEcio : levelEvdoSnr;
+            }
+            // TODO(): There is a bug open regarding what should be sent.
+            return (cdmaIconLevel > evdoIconLevel) ?  cdmaIconLevel : evdoIconLevel;
+
+        }
+
+
+        private int asuToSignal(SignalStrength signalStrength) {
+            if (signalStrength.isGsm()) {
+                return gsmAsuToSignal(signalStrength);
+            } else {
+                return cdmaDbmEcioToSignal(signalStrength);
+            }
+        }
+
+
+        /* convert [0,5] signal strength to a rssi signal strength for CSQ
+         * which is [0,31]. Despite the same scale, this is not the same value
+         * as ASU.
+         */
+        private int signalToRssi(int signal) {
+            // using C4A suggested values
+            switch (signal) {
+            case 0: return 0;
+            case 1: return 4;
+            case 2: return 8;
+            case 3: return 13;
+            case 4: return 19;
+            case 5: return 31;
+            }
+            return 0;
+        }
+
+
+        private final BroadcastReceiver mStateReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                if (intent.getAction().equals(Intent.ACTION_BATTERY_CHANGED)) {
+                    Message msg = mHandler.obtainMessage(BATTERY_CHANGED, intent);
+                    mHandler.sendMessage(msg);
+                } else if (intent.getAction().equals(
+                            TelephonyIntents.ACTION_SIGNAL_STRENGTH_CHANGED)) {
+                    Message msg = mHandler.obtainMessage(SIGNAL_STRENGTH_CHANGED,
+                                                                    intent);
+                    mHandler.sendMessage(msg);
+                } else if (intent.getAction().equals(
+                    BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED)) {
+                    int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                        BluetoothProfile.STATE_DISCONNECTED);
+                    int oldState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE,
+                        BluetoothProfile.STATE_DISCONNECTED);
+                    BluetoothDevice device =
+                            intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+
+                    // We are only concerned about Connected sinks to suspend and resume
+                    // them. We can safely ignore SINK_STATE_CHANGE for other devices.
+                    if (device == null || (mA2dpDevice != null && !device.equals(mA2dpDevice))) {
+                        return;
+                    }
+
+                    synchronized (BluetoothHandsfree.this) {
+                        mA2dpState = state;
+                        if (state == BluetoothProfile.STATE_DISCONNECTED) {
+                            mA2dpDevice = null;
+                        } else {
+                            mA2dpDevice = device;
+                        }
+                        if (oldState == BluetoothA2dp.STATE_PLAYING &&
+                            mA2dpState == BluetoothProfile.STATE_CONNECTED) {
+                            if (mA2dpSuspended) {
+                                if (mPendingSco) {
+                                    mHandler.removeMessages(MESSAGE_CHECK_PENDING_SCO);
+                                    if (DBG) log("A2DP suspended, completing SCO");
+                                    connectScoThread();
+                                    mPendingSco = false;
+                                }
+                            }
+                        }
+                    }
+                } else if (intent.getAction().
+                           equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
+                    mPhonebook.handleAccessPermissionResult(intent);
+                }
+            }
+        };
+
+        private synchronized void updateBatteryState(Intent intent) {
+            int batteryLevel = intent.getIntExtra("level", -1);
+            int scale = intent.getIntExtra("scale", -1);
+            if (batteryLevel == -1 || scale == -1) {
+                return;  // ignore
+            }
+            batteryLevel = batteryLevel * 5 / scale;
+            if (mBattchg != batteryLevel) {
+                mBattchg = batteryLevel;
+                if (sendUpdate()) {
+                    sendURC("+CIEV: 7," + mBattchg);
+                }
+            }
+        }
+
+        private synchronized void updateSignalState(Intent intent) {
+            // NOTE this function is called by the BroadcastReceiver mStateReceiver after intent
+            // ACTION_SIGNAL_STRENGTH_CHANGED and by the DebugThread mDebugThread
+            if (!isHeadsetConnected()) {
+                return;
+            }
+
+            SignalStrength signalStrength = SignalStrength.newFromBundle(intent.getExtras());
+            int signal;
+
+            if (signalStrength != null) {
+                signal = asuToSignal(signalStrength);
+                mRssi = signalToRssi(signal);  // no unsolicited CSQ
+                if (signal != mSignal) {
+                    mSignal = signal;
+                    if (sendUpdate()) {
+                        sendURC("+CIEV: 5," + mSignal);
+                    }
+                }
+            } else {
+                Log.e(TAG, "Signal Strength null");
+            }
+        }
+
+        private synchronized void updateServiceState(boolean sendUpdate, ServiceState state) {
+            int service = state.getState() == ServiceState.STATE_IN_SERVICE ? 1 : 0;
+            int roam = state.getRoaming() ? 1 : 0;
+            int stat;
+            AtCommandResult result = new AtCommandResult(AtCommandResult.UNSOLICITED);
+            mServiceState = state;
+            if (service == 0) {
+                stat = 0;
+            } else {
+                stat = (roam == 1) ? 5 : 1;
+            }
+
+            if (service != mService) {
+                mService = service;
+                if (sendUpdate) {
+                    result.addResponse("+CIEV: 1," + mService);
+                }
+            }
+            if (roam != mRoam) {
+                mRoam = roam;
+                if (sendUpdate) {
+                    result.addResponse("+CIEV: 6," + mRoam);
+                }
+            }
+            if (stat != mStat) {
+                mStat = stat;
+                if (sendUpdate) {
+                    result.addResponse(toCregString());
+                }
+            }
+
+            sendURC(result.toString());
+        }
+
+        private synchronized void handlePreciseCallStateChange(boolean sendUpdate,
+                Connection connection) {
+            int call = 0;
+            int callsetup = 0;
+            int callheld = 0;
+            int prevCallsetup = mCallsetup;
+            AtCommandResult result = new AtCommandResult(AtCommandResult.UNSOLICITED);
+            Call foregroundCall = mCM.getActiveFgCall();
+            Call backgroundCall = mCM.getFirstActiveBgCall();
+            Call ringingCall = mCM.getFirstActiveRingingCall();
+
+            if (VDBG) log("updatePhoneState()");
+
+            // This function will get called when the Precise Call State
+            // {@link Call.State} changes. Hence, we might get this update
+            // even if the {@link Phone.state} is same as before.
+            // Check for the same.
+
+            PhoneConstants.State newState = mCM.getState();
+            if (newState != mPhoneState) {
+                mPhoneState = newState;
+                switch (mPhoneState) {
+                case IDLE:
+                    mUserWantsAudio = true;  // out of call - reset state
+                    audioOff();
+                    break;
+                default:
+                    callStarted();
+                }
+            }
+
+            /* phone not setup yet */
+            if (foregroundCall == null) return;
+
+            switch(foregroundCall.getState()) {
+            case ACTIVE:
+                call = 1;
+                mAudioPossible = true;
+                break;
+            case DIALING:
+                callsetup = 2;
+                mAudioPossible = true;
+                // We also need to send a Call started indication
+                // for cases where the 2nd MO was initiated was
+                // from a *BT hands free* and is waiting for a
+                // +BLND: OK response
+                // There is a special case handling of the same case
+                // for CDMA below
+                if (mCM.getFgPhone().getPhoneType() == PhoneConstants.PHONE_TYPE_GSM) {
+                    callStarted();
+                }
+                break;
+            case ALERTING:
+                callsetup = 3;
+                // Open the SCO channel for the outgoing call.
+                mCallStartTime = System.currentTimeMillis();
+                audioOn();
+                mAudioPossible = true;
+                break;
+            case DISCONNECTING:
+                // This is a transient state, we don't want to send
+                // any AT commands during this state.
+                call = mCall;
+                callsetup = mCallsetup;
+                callheld = mCallheld;
+                break;
+            default:
+                mAudioPossible = false;
+            }
+
+            switch(ringingCall.getState()) {
+            case INCOMING:
+            case WAITING:
+                callsetup = 1;
+                break;
+            case DISCONNECTING:
+                // This is a transient state, we don't want to send
+                // any AT commands during this state.
+                call = mCall;
+                callsetup = mCallsetup;
+                callheld = mCallheld;
+                break;
+            }
+
+            switch(backgroundCall.getState()) {
+            case HOLDING:
+                if (call == 1) {
+                    callheld = 1;
+                } else {
+                    call = 1;
+                    callheld = 2;
+                }
+                break;
+            case DISCONNECTING:
+                // This is a transient state, we don't want to send
+                // any AT commands during this state.
+                call = mCall;
+                callsetup = mCallsetup;
+                callheld = mCallheld;
+                break;
+            }
+
+            if (mCall != call) {
+                if (call == 1) {
+                    // This means that a call has transitioned from NOT ACTIVE to ACTIVE.
+                    // Switch on audio.
+                    mCallStartTime = System.currentTimeMillis();
+                    audioOn();
+                }
+                mCall = call;
+                if (sendUpdate) {
+                    result.addResponse("+CIEV: 2," + mCall);
+                }
+            }
+            if (mCallsetup != callsetup) {
+                mCallsetup = callsetup;
+                if (sendUpdate) {
+                    // If mCall = 0, send CIEV
+                    // mCall = 1, mCallsetup = 0, send CIEV
+                    // mCall = 1, mCallsetup = 1, send CIEV after CCWA,
+                    // if 3 way supported.
+                    // mCall = 1, mCallsetup = 2 / 3 -> send CIEV,
+                    // if 3 way is supported
+                    if (mCall != 1 || mCallsetup == 0 ||
+                        mCallsetup != 1 && (mRemoteBrsf & BRSF_HF_CW_THREE_WAY_CALLING) != 0x0) {
+                        result.addResponse("+CIEV: 3," + mCallsetup);
+                    }
+                }
+            }
+
+            if (mCM.getDefaultPhone().getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+                PhoneGlobals app = PhoneGlobals.getInstance();
+                if (app.cdmaPhoneCallState != null) {
+                    CdmaPhoneCallState.PhoneCallState currCdmaThreeWayCallState =
+                            app.cdmaPhoneCallState.getCurrentCallState();
+                    CdmaPhoneCallState.PhoneCallState prevCdmaThreeWayCallState =
+                        app.cdmaPhoneCallState.getPreviousCallState();
+
+                    log("CDMA call state: " + currCdmaThreeWayCallState + " prev state:" +
+                        prevCdmaThreeWayCallState);
+                    callheld = getCdmaCallHeldStatus(currCdmaThreeWayCallState,
+                                                     prevCdmaThreeWayCallState);
+
+                    if (mCdmaThreeWayCallState != currCdmaThreeWayCallState) {
+                        // In CDMA, the network does not provide any feedback
+                        // to the phone when the 2nd MO call goes through the
+                        // stages of DIALING > ALERTING -> ACTIVE we fake the
+                        // sequence
+                        if ((currCdmaThreeWayCallState ==
+                                CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE)
+                                    && app.cdmaPhoneCallState.IsThreeWayCallOrigStateDialing()) {
+                            mAudioPossible = true;
+                            if (sendUpdate) {
+                                if ((mRemoteBrsf & BRSF_HF_CW_THREE_WAY_CALLING) != 0x0) {
+                                    result.addResponse("+CIEV: 3,2");
+                                    // Mimic putting the call on hold
+                                    result.addResponse("+CIEV: 4,1");
+                                    mCallheld = callheld;
+                                    result.addResponse("+CIEV: 3,3");
+                                    result.addResponse("+CIEV: 3,0");
+                                }
+                            }
+                            // We also need to send a Call started indication
+                            // for cases where the 2nd MO was initiated was
+                            // from a *BT hands free* and is waiting for a
+                            // +BLND: OK response
+                            callStarted();
+                        }
+
+                        // In CDMA, the network does not provide any feedback to
+                        // the phone when a user merges a 3way call or swaps
+                        // between two calls we need to send a CIEV response
+                        // indicating that a call state got changed which should
+                        // trigger a CLCC update request from the BT client.
+                        if (currCdmaThreeWayCallState ==
+                                CdmaPhoneCallState.PhoneCallState.CONF_CALL &&
+                                prevCdmaThreeWayCallState ==
+                                  CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
+                            mAudioPossible = true;
+                            if (sendUpdate) {
+                                if ((mRemoteBrsf & BRSF_HF_CW_THREE_WAY_CALLING) != 0x0) {
+                                    result.addResponse("+CIEV: 2,1");
+                                    result.addResponse("+CIEV: 3,0");
+                                }
+                            }
+                        }
+                    }
+                    mCdmaThreeWayCallState = currCdmaThreeWayCallState;
+                }
+            }
+
+            boolean callsSwitched;
+
+            if (mCM.getDefaultPhone().getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA &&
+                mCdmaThreeWayCallState == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
+                callsSwitched = mCdmaCallsSwapped;
+            } else {
+                callsSwitched =
+                    (callheld == 1 && ! (backgroundCall.getEarliestConnectTime() ==
+                        mBgndEarliestConnectionTime));
+                mBgndEarliestConnectionTime = backgroundCall.getEarliestConnectTime();
+            }
+
+
+            if (mCallheld != callheld || callsSwitched) {
+                mCallheld = callheld;
+                if (sendUpdate) {
+                    result.addResponse("+CIEV: 4," + mCallheld);
+                }
+            }
+
+            if (callsetup == 1 && callsetup != prevCallsetup) {
+                // new incoming call
+                String number = null;
+                int type = 128;
+                // find incoming phone number and type
+                if (connection == null) {
+                    connection = ringingCall.getEarliestConnection();
+                    if (connection == null) {
+                        Log.e(TAG, "Could not get a handle on Connection object for new " +
+                              "incoming call");
+                    }
+                }
+                if (connection != null) {
+                    number = connection.getAddress();
+                    if (number != null) {
+                        type = PhoneNumberUtils.toaFromString(number);
+                    }
+                }
+                if (number == null) {
+                    number = "";
+                }
+                if ((call != 0 || callheld != 0) && sendUpdate) {
+                    // call waiting
+                    if ((mRemoteBrsf & BRSF_HF_CW_THREE_WAY_CALLING) != 0x0) {
+                        result.addResponse("+CCWA: \"" + number + "\"," + type);
+                        result.addResponse("+CIEV: 3," + callsetup);
+                    }
+                } else {
+                    // regular new incoming call
+                    mRingingNumber = number;
+                    mRingingType = type;
+                    mIgnoreRing = false;
+                    mStopRing = false;
+
+                    if ((mLocalBrsf & BRSF_AG_IN_BAND_RING) != 0x0) {
+                        mCallStartTime = System.currentTimeMillis();
+                        audioOn();
+                    }
+                    result.addResult(ring());
+                }
+            }
+            sendURC(result.toString());
+        }
+
+        private int getCdmaCallHeldStatus(CdmaPhoneCallState.PhoneCallState currState,
+                                  CdmaPhoneCallState.PhoneCallState prevState) {
+            int callheld;
+            // Update the Call held information
+            if (currState == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
+                if (prevState == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
+                    callheld = 0; //0: no calls held, as now *both* the caller are active
+                } else {
+                    callheld = 1; //1: held call and active call, as on answering a
+                            // Call Waiting, one of the caller *is* put on hold
+                }
+            } else if (currState == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
+                callheld = 1; //1: held call and active call, as on make a 3 Way Call
+                        // the first caller *is* put on hold
+            } else {
+                callheld = 0; //0: no calls held as this is a SINGLE_ACTIVE call
+            }
+            return callheld;
+        }
+
+
+        private AtCommandResult ring() {
+            if (sendRingUpdate()) {
+                AtCommandResult result = new AtCommandResult(AtCommandResult.UNSOLICITED);
+                result.addResponse("RING");
+                if (sendClipUpdate()) {
+                    result.addResponse("+CLIP: \"" + mRingingNumber + "\"," + mRingingType);
+                }
+
+                Message msg = mStateChangeHandler.obtainMessage(RING);
+                mStateChangeHandler.sendMessageDelayed(msg, 3000);
+                return result;
+            }
+            return null;
+        }
+
+        private synchronized String toCregString() {
+            return new String("+CREG: 1," + mStat);
+        }
+
+        private synchronized void updateCallHeld() {
+            if (mCallheld != 0) {
+                mCallheld = 0;
+                sendURC("+CIEV: 4,0");
+            }
+        }
+
+        private synchronized AtCommandResult toCindResult() {
+            AtCommandResult result = new AtCommandResult(AtCommandResult.OK);
+            int call, call_setup;
+
+            // Handsfree carkits expect that +CIND is properly responded to.
+            // Hence we ensure that a proper response is sent for the virtual call too.
+            if (isVirtualCallInProgress()) {
+                call = 1;
+                call_setup = 0;
+            } else {
+                // regular phone call
+                call = mCall;
+                call_setup = mCallsetup;
+            }
+
+            mSignal = asuToSignal(mCM.getDefaultPhone().getSignalStrength());
+            String status = "+CIND: " + mService + "," + call + "," + call_setup + "," +
+                            mCallheld + "," + mSignal + "," + mRoam + "," + mBattchg;
+            result.addResponse(status);
+            return result;
+        }
+
+        private synchronized AtCommandResult toCsqResult() {
+            AtCommandResult result = new AtCommandResult(AtCommandResult.OK);
+            String status = "+CSQ: " + mRssi + ",99";
+            result.addResponse(status);
+            return result;
+        }
+
+
+        private synchronized AtCommandResult getCindTestResult() {
+            return new AtCommandResult("+CIND: (\"service\",(0-1))," + "(\"call\",(0-1))," +
+                        "(\"callsetup\",(0-3)),(\"callheld\",(0-2)),(\"signal\",(0-5))," +
+                        "(\"roam\",(0-1)),(\"battchg\",(0-5))");
+        }
+
+        private synchronized void ignoreRing() {
+            mCallsetup = 0;
+            mIgnoreRing = true;
+            if (sendUpdate()) {
+                sendURC("+CIEV: 3," + mCallsetup);
+            }
+        }
+
+        private void scoClosed() {
+            // sync on mUserWantsAudio change
+            synchronized(BluetoothHandsfree.this) {
+                if (mUserWantsAudio &&
+                    System.currentTimeMillis() - mCallStartTime < RETRY_SCO_TIME_WINDOW) {
+                    Message msg = mHandler.obtainMessage(SCO_CONNECTION_CHECK);
+                    mHandler.sendMessage(msg);
+                }
+            }
+        }
+    };
+
+    private static final int SCO_CLOSED = 3;
+    private static final int CHECK_CALL_STARTED = 4;
+    private static final int CHECK_VOICE_RECOGNITION_STARTED = 5;
+    private static final int MESSAGE_CHECK_PENDING_SCO = 6;
+    private static final int SCO_AUDIO_STATE = 7;
+    private static final int SCO_CONNECTION_CHECK = 8;
+    private static final int BATTERY_CHANGED = 9;
+    private static final int SIGNAL_STRENGTH_CHANGED = 10;
+
+    private final class HandsfreeMessageHandler extends Handler {
+        private HandsfreeMessageHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case SCO_CLOSED:
+                synchronized (BluetoothHandsfree.this) {
+                    // synchronized
+                    // Make atomic against audioOn, userWantsAudioOn
+                    // TODO finer lock to decouple from other call flow such as
+                    //      mWaitingForCallStart change
+
+                    audioOff();
+                    // notify mBluetoothPhoneState that the SCO channel has closed
+                    mBluetoothPhoneState.scoClosed();
+                }
+                break;
+            case CHECK_CALL_STARTED:
+                synchronized (BluetoothHandsfree.this) {
+                    // synchronized
+                    // Protect test/change of mWaitingForCallStart
+                    if (mWaitingForCallStart) {
+                        mWaitingForCallStart = false;
+                        Log.e(TAG, "Timeout waiting for call to start");
+                        sendURC("ERROR");
+                        if (mStartCallWakeLock.isHeld()) {
+                            mStartCallWakeLock.release();
+                        }
+                    }
+                }
+                break;
+            case CHECK_VOICE_RECOGNITION_STARTED:
+                synchronized (BluetoothHandsfree.this) {
+                    // synchronized
+                    // Protect test/change of mWaitingForVoiceRecognition
+                    if (mWaitingForVoiceRecognition) {
+                        mWaitingForVoiceRecognition = false;
+                        Log.e(TAG, "Timeout waiting for voice recognition to start");
+                        sendURC("ERROR");
+                    }
+                }
+                break;
+            case MESSAGE_CHECK_PENDING_SCO:
+                synchronized (BluetoothHandsfree.this) {
+                    // synchronized
+                    // Protect test/change of mPendingSco
+                    if (mPendingSco && isA2dpMultiProfile()) {
+                        Log.w(TAG, "Timeout suspending A2DP for SCO (mA2dpState = " +
+                                mA2dpState + "). Starting SCO anyway");
+                        connectScoThread();
+                        mPendingSco = false;
+                    }
+                }
+                break;
+            case SCO_AUDIO_STATE:
+                BluetoothDevice device = (BluetoothDevice) msg.obj;
+                if (getAudioState(device) == BluetoothHeadset.STATE_AUDIO_CONNECTING) {
+                    setAudioState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, device);
+                }
+                break;
+            case SCO_CONNECTION_CHECK:
+                synchronized (mBluetoothPhoneState) {
+                    // synchronized on mCall change
+                    if (mBluetoothPhoneState.mCall == 1) {
+                        // Sometimes, the SCO channel is torn down by HF with no reason.
+                        // Because we are still in active call, reconnect SCO.
+                        // audioOn does nothing if the SCO is already on.
+                        audioOn();
+                    }
+                }
+                break;
+            case BATTERY_CHANGED:
+                mBluetoothPhoneState.updateBatteryState((Intent) msg.obj);
+                break;
+            case SIGNAL_STRENGTH_CHANGED:
+                mBluetoothPhoneState.updateSignalState((Intent) msg.obj);
+                break;
+            }
+        }
+    }
+
+    private synchronized void setAudioState(int state, BluetoothDevice device) {
+        if (VDBG) log("setAudioState(" + state + ")");
+        if (mBluetoothHeadset == null) {
+            mAdapter.getProfileProxy(mContext, mProfileListener, BluetoothProfile.HEADSET);
+            mPendingAudioState = true;
+            mAudioState = state;
+            return;
+        }
+        mBluetoothHeadset.setAudioState(device, state);
+    }
+
+    private synchronized int getAudioState(BluetoothDevice device) {
+        if (mBluetoothHeadset == null) return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
+        return mBluetoothHeadset.getAudioState(device);
+    }
+
+    private BluetoothProfile.ServiceListener mProfileListener =
+            new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            if (profile == BluetoothProfile.HEADSET) {
+                mBluetoothHeadset = (BluetoothHeadset) proxy;
+                synchronized(BluetoothHandsfree.this) {
+                    if (mPendingAudioState) {
+                        mBluetoothHeadset.setAudioState(mHeadset.getRemoteDevice(), mAudioState);
+                        mPendingAudioState = false;
+                    }
+                }
+            } else if (profile == BluetoothProfile.A2DP) {
+                mA2dp = (BluetoothA2dp) proxy;
+            }
+        }
+        public void onServiceDisconnected(int profile) {
+            if (profile == BluetoothProfile.HEADSET) {
+                mBluetoothHeadset = null;
+            } else if (profile == BluetoothProfile.A2DP) {
+                mA2dp = null;
+            }
+        }
+    };
+
+    /*
+     * Put the AT command, company ID, arguments, and device in an Intent and broadcast it.
+     */
+    private void broadcastVendorSpecificEventIntent(String command,
+                                                    int companyId,
+                                                    int commandType,
+                                                    Object[] arguments,
+                                                    BluetoothDevice device) {
+        if (VDBG) log("broadcastVendorSpecificEventIntent(" + command + ")");
+        Intent intent =
+                new Intent(BluetoothHeadset.ACTION_VENDOR_SPECIFIC_HEADSET_EVENT);
+        intent.putExtra(BluetoothHeadset.EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD, command);
+        intent.putExtra(BluetoothHeadset.EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE,
+                        commandType);
+        // assert: all elements of args are Serializable
+        intent.putExtra(BluetoothHeadset.EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS, arguments);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+
+        intent.addCategory(BluetoothHeadset.VENDOR_SPECIFIC_HEADSET_EVENT_COMPANY_ID_CATEGORY
+            + "." + Integer.toString(companyId));
+
+        mContext.sendBroadcast(intent, android.Manifest.permission.BLUETOOTH);
+    }
+
+    void updateBtHandsfreeAfterRadioTechnologyChange() {
+        if (VDBG) Log.d(TAG, "updateBtHandsfreeAfterRadioTechnologyChange...");
+
+        mBluetoothPhoneState.updateBtPhoneStateAfterRadioTechnologyChange();
+    }
+
+    /** Request to establish SCO (audio) connection to bluetooth
+     * headset/handsfree, if one is connected. Does not block.
+     * Returns false if the user has requested audio off, or if there
+     * is some other immediate problem that will prevent BT audio.
+     */
+    /* package */ synchronized boolean audioOn() {
+        if (VDBG) log("audioOn()");
+        if (!isHeadsetConnected()) {
+            if (DBG) log("audioOn(): headset is not connected!");
+            return false;
+        }
+        if (mHeadsetType == TYPE_HANDSFREE && !mServiceConnectionEstablished) {
+            if (DBG) log("audioOn(): service connection not yet established!");
+            return false;
+        }
+
+        if (mConnectedSco != null) {
+            if (DBG) log("audioOn(): audio is already connected");
+            return true;
+        }
+
+        if (!mUserWantsAudio) {
+            if (DBG) log("audioOn(): user requested no audio, ignoring");
+            return false;
+        }
+
+        if (mPendingSco) {
+            if (DBG) log("audioOn(): SCO already pending");
+            return true;
+        }
+
+        mA2dpSuspended = false;
+        mPendingSco = false;
+        if (isA2dpMultiProfile() && mA2dpState == BluetoothA2dp.STATE_PLAYING) {
+            if (DBG) log("suspending A2DP stream for SCO");
+            mA2dpSuspended = mA2dp.suspendSink(mA2dpDevice);
+            if (mA2dpSuspended) {
+                mPendingSco = true;
+                Message msg = mHandler.obtainMessage(MESSAGE_CHECK_PENDING_SCO);
+                mHandler.sendMessageDelayed(msg, 2000);
+            } else {
+                Log.w(TAG, "Could not suspend A2DP stream for SCO, going ahead with SCO");
+            }
+        }
+
+        if (!mPendingSco) {
+            connectScoThread();
+        }
+
+        return true;
+    }
+
+    /** Used to indicate the user requested BT audio on.
+     *  This will establish SCO (BT audio), even if the user requested it off
+     *  previously on this call.
+     */
+    /* package */ synchronized void userWantsAudioOn() {
+        mUserWantsAudio = true;
+        audioOn();
+    }
+    /** Used to indicate the user requested BT audio off.
+     *  This will prevent us from establishing BT audio again during this call
+     *  if audioOn() is called.
+     */
+    /* package */ synchronized void userWantsAudioOff() {
+        mUserWantsAudio = false;
+        audioOff();
+    }
+
+    /** Request to disconnect SCO (audio) connection to bluetooth
+     * headset/handsfree, if one is connected. Does not block.
+     */
+    /* package */ synchronized void audioOff() {
+        if (VDBG) log("audioOff(): mPendingSco: " + mPendingSco +
+                ", mConnectedSco: " + mConnectedSco +
+                ", mA2dpState: " + mA2dpState +
+                ", mA2dpSuspended: " + mA2dpSuspended);
+
+        if (mA2dpSuspended) {
+            if (isA2dpMultiProfile()) {
+                if (DBG) log("resuming A2DP stream after disconnecting SCO");
+                mA2dp.resumeSink(mA2dpDevice);
+            }
+            mA2dpSuspended = false;
+        }
+
+        mPendingSco = false;
+
+        if (mSignalScoCloseThread != null) {
+            mSignalScoCloseThread.shutdown();
+            mSignalScoCloseThread = null;
+        }
+
+        // Sync with setting mConnectScoThread to null to assure the validity of
+        // the condition
+        synchronized (ScoSocketConnectThread.class) {
+            if (mConnectScoThread != null) {
+                mConnectScoThread.shutdown();
+                resetConnectScoThread();
+            }
+        }
+
+        closeConnectedSco();    // Should be closed already, but just in case
+    }
+
+    /* package */ boolean isAudioOn() {
+        return (mConnectedSco != null);
+    }
+
+    private boolean isA2dpMultiProfile() {
+        return mA2dp != null && mHeadset != null && mA2dpDevice != null &&
+                mA2dpDevice.equals(mHeadset.getRemoteDevice());
+    }
+
+    /* package */ void ignoreRing() {
+        mBluetoothPhoneState.ignoreRing();
+    }
+
+    /* package */ void sendURC(String urc) {
+        if (isHeadsetConnected()) {
+            mHeadset.sendURC(urc);
+        }
+    }
+
+    /**
+     * Allows a mechanism to override the default line by line input handling with a custom handler
+     * @param stringToSend - initial string of characters to send out
+     * @param inputHandler - callback for handling the specialized input
+     */
+    void setSpecialPDUInputHandler(String stringToSend, HeadsetBase.SpecialPDUInputHandler inputHandler) {
+        if ((null != inputHandler) && (null != stringToSend) && (0 < stringToSend.length())) {
+            mHeadset.sendURCChars(stringToSend);
+        }
+        mHeadset.specialPDUInputHandler = inputHandler;
+    }
+
+    /** helper to redial last dialled number */
+    private AtCommandResult redial() {
+        String number = mPhonebook.getLastDialledNumber();
+        if (number == null) {
+            // spec seems to suggest sending ERROR if we dont have a
+            // number to redial
+            if (VDBG) log("Bluetooth redial requested (+BLDN), but no previous " +
+                  "outgoing calls found. Ignoring");
+            return new AtCommandResult(AtCommandResult.ERROR);
+        }
+        // Outgoing call initiated by the handsfree device
+        // Send terminateScoUsingVirtualVoiceCall
+        terminateScoUsingVirtualVoiceCall();
+        Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED,
+                Uri.fromParts(Constants.SCHEME_TEL, number, null));
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        mContext.startActivity(intent);
+
+        // We do not immediately respond OK, wait until we get a phone state
+        // update. If we return OK now and the handsfree immeidately requests
+        // our phone state it will say we are not in call yet which confuses
+        // some devices
+        expectCallStart();
+        return new AtCommandResult(AtCommandResult.UNSOLICITED);  // send nothing
+    }
+
+    /** Build the +CLCC result
+     *  The complexity arises from the fact that we need to maintain the same
+     *  CLCC index even as a call moves between states. */
+    private synchronized AtCommandResult gsmGetClccResult() {
+        // Collect all known connections
+        Connection[] clccConnections = new Connection[GSM_MAX_CONNECTIONS];  // indexed by CLCC index
+        LinkedList<Connection> newConnections = new LinkedList<Connection>();
+        LinkedList<Connection> connections = new LinkedList<Connection>();
+
+        Call foregroundCall = mCM.getActiveFgCall();
+        Call backgroundCall = mCM.getFirstActiveBgCall();
+        Call ringingCall = mCM.getFirstActiveRingingCall();
+
+        if (ringingCall.getState().isAlive()) {
+            connections.addAll(ringingCall.getConnections());
+        }
+        if (foregroundCall.getState().isAlive()) {
+            connections.addAll(foregroundCall.getConnections());
+        }
+        if (backgroundCall.getState().isAlive()) {
+            connections.addAll(backgroundCall.getConnections());
+        }
+
+        // Mark connections that we already known about
+        boolean clccUsed[] = new boolean[GSM_MAX_CONNECTIONS];
+        for (int i = 0; i < GSM_MAX_CONNECTIONS; i++) {
+            clccUsed[i] = mClccUsed[i];
+            mClccUsed[i] = false;
+        }
+        for (Connection c : connections) {
+            boolean found = false;
+            long timestamp = c.getCreateTime();
+            for (int i = 0; i < GSM_MAX_CONNECTIONS; i++) {
+                if (clccUsed[i] && timestamp == mClccTimestamps[i]) {
+                    mClccUsed[i] = true;
+                    found = true;
+                    clccConnections[i] = c;
+                    break;
+                }
+            }
+            if (!found) {
+                newConnections.add(c);
+            }
+        }
+
+        // Find a CLCC index for new connections
+        while (!newConnections.isEmpty()) {
+            // Find lowest empty index
+            int i = 0;
+            while (mClccUsed[i]) i++;
+            // Find earliest connection
+            long earliestTimestamp = newConnections.get(0).getCreateTime();
+            Connection earliestConnection = newConnections.get(0);
+            for (int j = 0; j < newConnections.size(); j++) {
+                long timestamp = newConnections.get(j).getCreateTime();
+                if (timestamp < earliestTimestamp) {
+                    earliestTimestamp = timestamp;
+                    earliestConnection = newConnections.get(j);
+                }
+            }
+
+            // update
+            mClccUsed[i] = true;
+            mClccTimestamps[i] = earliestTimestamp;
+            clccConnections[i] = earliestConnection;
+            newConnections.remove(earliestConnection);
+        }
+
+        // Build CLCC
+        AtCommandResult result = new AtCommandResult(AtCommandResult.OK);
+        for (int i = 0; i < clccConnections.length; i++) {
+            if (mClccUsed[i]) {
+                String clccEntry = connectionToClccEntry(i, clccConnections[i]);
+                if (clccEntry != null) {
+                    result.addResponse(clccEntry);
+                }
+            }
+        }
+
+        return result;
+    }
+
+    /** Convert a Connection object into a single +CLCC result */
+    private String connectionToClccEntry(int index, Connection c) {
+        int state;
+        switch (c.getState()) {
+        case ACTIVE:
+            state = 0;
+            break;
+        case HOLDING:
+            state = 1;
+            break;
+        case DIALING:
+            state = 2;
+            break;
+        case ALERTING:
+            state = 3;
+            break;
+        case INCOMING:
+            state = 4;
+            break;
+        case WAITING:
+            state = 5;
+            break;
+        default:
+            return null;  // bad state
+        }
+
+        int mpty = 0;
+        Call call = c.getCall();
+        if (call != null) {
+            mpty = call.isMultiparty() ? 1 : 0;
+        }
+
+        int direction = c.isIncoming() ? 1 : 0;
+
+        String number = c.getAddress();
+        int type = -1;
+        if (number != null) {
+            type = PhoneNumberUtils.toaFromString(number);
+        }
+
+        String result = "+CLCC: " + (index + 1) + "," + direction + "," + state + ",0," + mpty;
+        if (number != null) {
+            result += ",\"" + number + "\"," + type;
+        }
+        return result;
+    }
+
+    /** Build the +CLCC result for CDMA
+     *  The complexity arises from the fact that we need to maintain the same
+     *  CLCC index even as a call moves between states. */
+    private synchronized AtCommandResult cdmaGetClccResult() {
+        // In CDMA at one time a user can have only two live/active connections
+        Connection[] clccConnections = new Connection[CDMA_MAX_CONNECTIONS];// indexed by CLCC index
+        Call foregroundCall = mCM.getActiveFgCall();
+        Call ringingCall = mCM.getFirstActiveRingingCall();
+
+        Call.State ringingCallState = ringingCall.getState();
+        // If the Ringing Call state is INCOMING, that means this is the very first call
+        // hence there should not be any Foreground Call
+        if (ringingCallState == Call.State.INCOMING) {
+            if (VDBG) log("Filling clccConnections[0] for INCOMING state");
+            clccConnections[0] = ringingCall.getLatestConnection();
+        } else if (foregroundCall.getState().isAlive()) {
+            // Getting Foreground Call connection based on Call state
+            if (ringingCall.isRinging()) {
+                if (VDBG) log("Filling clccConnections[0] & [1] for CALL WAITING state");
+                clccConnections[0] = foregroundCall.getEarliestConnection();
+                clccConnections[1] = ringingCall.getLatestConnection();
+            } else {
+                if (foregroundCall.getConnections().size() <= 1) {
+                    // Single call scenario
+                    if (VDBG) log("Filling clccConnections[0] with ForgroundCall latest connection");
+                    clccConnections[0] = foregroundCall.getLatestConnection();
+                } else {
+                    // Multiple Call scenario. This would be true for both
+                    // CONF_CALL and THRWAY_ACTIVE state
+                    if (VDBG) log("Filling clccConnections[0] & [1] with ForgroundCall connections");
+                    clccConnections[0] = foregroundCall.getEarliestConnection();
+                    clccConnections[1] = foregroundCall.getLatestConnection();
+                }
+            }
+        }
+
+        // Update the mCdmaIsSecondCallActive flag based on the Phone call state
+        if (PhoneGlobals.getInstance().cdmaPhoneCallState.getCurrentCallState()
+                == CdmaPhoneCallState.PhoneCallState.SINGLE_ACTIVE) {
+            cdmaSetSecondCallState(false);
+        } else if (PhoneGlobals.getInstance().cdmaPhoneCallState.getCurrentCallState()
+                == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
+            cdmaSetSecondCallState(true);
+        }
+
+        // Build CLCC
+        AtCommandResult result = new AtCommandResult(AtCommandResult.OK);
+        for (int i = 0; (i < clccConnections.length) && (clccConnections[i] != null); i++) {
+            String clccEntry = cdmaConnectionToClccEntry(i, clccConnections[i]);
+            if (clccEntry != null) {
+                result.addResponse(clccEntry);
+            }
+        }
+
+        return result;
+    }
+
+    /** Convert a Connection object into a single +CLCC result for CDMA phones */
+    private String cdmaConnectionToClccEntry(int index, Connection c) {
+        int state;
+        PhoneGlobals app = PhoneGlobals.getInstance();
+        CdmaPhoneCallState.PhoneCallState currCdmaCallState =
+                app.cdmaPhoneCallState.getCurrentCallState();
+        CdmaPhoneCallState.PhoneCallState prevCdmaCallState =
+                app.cdmaPhoneCallState.getPreviousCallState();
+
+        if ((prevCdmaCallState == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE)
+                && (currCdmaCallState == CdmaPhoneCallState.PhoneCallState.CONF_CALL)) {
+            // If the current state is reached after merging two calls
+            // we set the state of all the connections as ACTIVE
+            state = 0;
+        } else {
+            switch (c.getState()) {
+            case ACTIVE:
+                // For CDMA since both the connections are set as active by FW after accepting
+                // a Call waiting or making a 3 way call, we need to set the state specifically
+                // to ACTIVE/HOLDING based on the mCdmaIsSecondCallActive flag. This way the
+                // CLCC result will allow BT devices to enable the swap or merge options
+                if (index == 0) { // For the 1st active connection
+                    state = mCdmaIsSecondCallActive ? 1 : 0;
+                } else { // for the 2nd active connection
+                    state = mCdmaIsSecondCallActive ? 0 : 1;
+                }
+                break;
+            case HOLDING:
+                state = 1;
+                break;
+            case DIALING:
+                state = 2;
+                break;
+            case ALERTING:
+                state = 3;
+                break;
+            case INCOMING:
+                state = 4;
+                break;
+            case WAITING:
+                state = 5;
+                break;
+            default:
+                return null;  // bad state
+            }
+        }
+
+        int mpty = 0;
+        if (currCdmaCallState == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
+            if (prevCdmaCallState == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
+                // If the current state is reached after merging two calls
+                // we set the multiparty call true.
+                mpty = 1;
+            } else {
+                // CALL_CONF state is not from merging two calls, but from
+                // accepting the second call. In this case first will be on
+                // hold in most cases but in some cases its already merged.
+                // However, we will follow the common case and the test case
+                // as per Bluetooth SIG PTS
+                mpty = 0;
+            }
+        } else {
+            mpty = 0;
+        }
+
+        int direction = c.isIncoming() ? 1 : 0;
+
+        String number = c.getAddress();
+        int type = -1;
+        if (number != null) {
+            type = PhoneNumberUtils.toaFromString(number);
+        }
+
+        String result = "+CLCC: " + (index + 1) + "," + direction + "," + state + ",0," + mpty;
+        if (number != null) {
+            result += ",\"" + number + "\"," + type;
+        }
+        return result;
+    }
+
+    /*
+     * Register a vendor-specific command.
+     * @param commandName the name of the command.  For example, if the expected
+     * incoming command is <code>AT+FOO=bar,baz</code>, the value of this should be
+     * <code>"+FOO"</code>.
+     * @param companyId the Bluetooth SIG Company Identifier
+     * @param parser the AtParser on which to register the command
+     */
+    private void registerVendorSpecificCommand(String commandName,
+                                               int companyId,
+                                               AtParser parser) {
+        parser.register(commandName,
+                        new VendorSpecificCommandHandler(commandName, companyId));
+    }
+
+    /*
+     * Register all vendor-specific commands here.
+     */
+    private void registerAllVendorSpecificCommands() {
+        AtParser parser = mHeadset.getAtParser();
+
+        // Plantronics-specific headset events go here
+        registerVendorSpecificCommand("+XEVENT",
+                                      BluetoothAssignedNumbers.PLANTRONICS,
+                                      parser);
+    }
+
+    /**
+     * Register AT Command handlers to implement the Headset profile
+     */
+    private void initializeHeadsetAtParser() {
+        if (VDBG) log("Registering Headset AT commands");
+        AtParser parser = mHeadset.getAtParser();
+        // Headsets usually only have one button, which is meant to cause the
+        // HS to send us AT+CKPD=200 or AT+CKPD.
+        parser.register("+CKPD", new AtCommandHandler() {
+            private AtCommandResult headsetButtonPress() {
+                if (mCM.getFirstActiveRingingCall().isRinging()) {
+                    // Answer the call
+                    mBluetoothPhoneState.stopRing();
+                    sendURC("OK");
+                    PhoneUtils.answerCall(mCM.getFirstActiveRingingCall());
+                    // If in-band ring tone is supported, SCO connection will already
+                    // be up and the following call will just return.
+                    audioOn();
+                    return new AtCommandResult(AtCommandResult.UNSOLICITED);
+                } else if (mCM.hasActiveFgCall()) {
+                    if (!isAudioOn()) {
+                        // Transfer audio from AG to HS
+                        audioOn();
+                    } else {
+                        if (mHeadset.getDirection() == HeadsetBase.DIRECTION_INCOMING &&
+                          (System.currentTimeMillis() - mHeadset.getConnectTimestamp()) < 5000) {
+                            // Headset made a recent ACL connection to us - and
+                            // made a mandatory AT+CKPD request to connect
+                            // audio which races with our automatic audio
+                            // setup.  ignore
+                        } else {
+                            // Hang up the call
+                            audioOff();
+                            PhoneUtils.hangup(PhoneGlobals.getInstance().mCM);
+                        }
+                    }
+                    return new AtCommandResult(AtCommandResult.OK);
+                } else {
+                    // No current call - redial last number
+                    return redial();
+                }
+            }
+            @Override
+            public AtCommandResult handleActionCommand() {
+                return headsetButtonPress();
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                return headsetButtonPress();
+            }
+        });
+    }
+
+    /**
+     * Register AT Command handlers to implement the Handsfree profile
+     */
+    private void initializeHandsfreeAtParser() {
+        if (VDBG) log("Registering Handsfree AT commands");
+        AtParser parser = mHeadset.getAtParser();
+        final Phone phone = mCM.getDefaultPhone();
+
+        // Answer
+        parser.register('A', new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleBasicCommand(String args) {
+                sendURC("OK");
+                mBluetoothPhoneState.stopRing();
+                PhoneUtils.answerCall(mCM.getFirstActiveRingingCall());
+                return new AtCommandResult(AtCommandResult.UNSOLICITED);
+            }
+        });
+        parser.register('D', new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleBasicCommand(String args) {
+                if (args.length() > 0) {
+                    if (args.charAt(0) == '>') {
+                        // Yuck - memory dialling requested.
+                        // Just dial last number for now
+                        if (args.startsWith(">9999")) {   // for PTS test
+                            return new AtCommandResult(AtCommandResult.ERROR);
+                        }
+                        return redial();
+                    } else {
+                        // Send terminateScoUsingVirtualVoiceCall
+                        terminateScoUsingVirtualVoiceCall();
+                        // Remove trailing ';'
+                        if (args.charAt(args.length() - 1) == ';') {
+                            args = args.substring(0, args.length() - 1);
+                        }
+
+                        args = PhoneNumberUtils.convertPreDial(args);
+
+                        Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED,
+                                Uri.fromParts(Constants.SCHEME_TEL, args, null));
+                        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                        mContext.startActivity(intent);
+
+                        expectCallStart();
+                        return new AtCommandResult(AtCommandResult.UNSOLICITED);  // send nothing
+                    }
+                }
+                return new AtCommandResult(AtCommandResult.ERROR);
+            }
+        });
+
+        // Hang-up command
+        parser.register("+CHUP", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                sendURC("OK");
+                if (isVirtualCallInProgress()) {
+                    terminateScoUsingVirtualVoiceCall();
+                } else {
+                    if (mCM.hasActiveFgCall()) {
+                        PhoneUtils.hangupActiveCall(mCM.getActiveFgCall());
+                    } else if (mCM.hasActiveRingingCall()) {
+                        PhoneUtils.hangupRingingCall(mCM.getFirstActiveRingingCall());
+                    } else if (mCM.hasActiveBgCall()) {
+                        PhoneUtils.hangupHoldingCall(mCM.getFirstActiveBgCall());
+                    }
+                }
+                return new AtCommandResult(AtCommandResult.UNSOLICITED);
+            }
+        });
+
+        // Bluetooth Retrieve Supported Features command
+        parser.register("+BRSF", new AtCommandHandler() {
+            private AtCommandResult sendBRSF() {
+                return new AtCommandResult("+BRSF: " + mLocalBrsf);
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // AT+BRSF=<handsfree supported features bitmap>
+                // Handsfree is telling us which features it supports. We
+                // send the features we support
+                if (args.length == 1 && (args[0] instanceof Integer)) {
+                    mRemoteBrsf = (Integer) args[0];
+                } else {
+                    Log.w(TAG, "HF didn't sent BRSF assuming 0");
+                }
+                return sendBRSF();
+            }
+            @Override
+            public AtCommandResult handleActionCommand() {
+                // This seems to be out of spec, but lets do the nice thing
+                return sendBRSF();
+            }
+            @Override
+            public AtCommandResult handleReadCommand() {
+                // This seems to be out of spec, but lets do the nice thing
+                return sendBRSF();
+            }
+        });
+
+        // Call waiting notification on/off
+        parser.register("+CCWA", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                // Seems to be out of spec, but lets return nicely
+                return new AtCommandResult(AtCommandResult.OK);
+            }
+            @Override
+            public AtCommandResult handleReadCommand() {
+                // Call waiting is always on
+                return new AtCommandResult("+CCWA: 1");
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // AT+CCWA=<n>
+                // Handsfree is trying to enable/disable call waiting. We
+                // cannot disable in the current implementation.
+                return new AtCommandResult(AtCommandResult.OK);
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                // Request for range of supported CCWA paramters
+                return new AtCommandResult("+CCWA: (\"n\",(1))");
+            }
+        });
+
+        // Mobile Equipment Event Reporting enable/disable command
+        // Of the full 3GPP syntax paramters (mode, keyp, disp, ind, bfr) we
+        // only support paramter ind (disable/enable evert reporting using
+        // +CDEV)
+        parser.register("+CMER", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                return new AtCommandResult(
+                        "+CMER: 3,0,0," + (mIndicatorsEnabled ? "1" : "0"));
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (args.length < 4) {
+                    // This is a syntax error
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                } else if (args[0].equals(3) && args[1].equals(0) &&
+                           args[2].equals(0)) {
+                    boolean valid = false;
+                    if (args[3].equals(0)) {
+                        mIndicatorsEnabled = false;
+                        valid = true;
+                    } else if (args[3].equals(1)) {
+                        mIndicatorsEnabled = true;
+                        valid = true;
+                    }
+                    if (valid) {
+                        if ((mRemoteBrsf & BRSF_HF_CW_THREE_WAY_CALLING) == 0x0) {
+                            mServiceConnectionEstablished = true;
+                            sendURC("OK");  // send immediately, then initiate audio
+                            if (isIncallAudio()) {
+                                audioOn();
+                            } else if (mCM.getFirstActiveRingingCall().isRinging()) {
+                                // need to update HS with RING cmd when single
+                                // ringing call exist
+                                mBluetoothPhoneState.ring();
+                            }
+                            // only send OK once
+                            return new AtCommandResult(AtCommandResult.UNSOLICITED);
+                        } else {
+                            return new AtCommandResult(AtCommandResult.OK);
+                        }
+                    }
+                }
+                return reportCmeError(BluetoothCmeError.OPERATION_NOT_SUPPORTED);
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+CMER: (3),(0),(0),(0-1)");
+            }
+        });
+
+        // Mobile Equipment Error Reporting enable/disable
+        parser.register("+CMEE", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                // out of spec, assume they want to enable
+                mCmee = true;
+                return new AtCommandResult(AtCommandResult.OK);
+            }
+            @Override
+            public AtCommandResult handleReadCommand() {
+                return new AtCommandResult("+CMEE: " + (mCmee ? "1" : "0"));
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // AT+CMEE=<n>
+                if (args.length == 0) {
+                    // <n> ommitted - default to 0
+                    mCmee = false;
+                    return new AtCommandResult(AtCommandResult.OK);
+                } else if (!(args[0] instanceof Integer)) {
+                    // Syntax error
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                } else {
+                    mCmee = ((Integer)args[0] == 1);
+                    return new AtCommandResult(AtCommandResult.OK);
+                }
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                // Probably not required but spec, but no harm done
+                return new AtCommandResult("+CMEE: (0-1)");
+            }
+        });
+
+        // Bluetooth Last Dialled Number
+        parser.register("+BLDN", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                return redial();
+            }
+        });
+
+        // Indicator Update command
+        parser.register("+CIND", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                return mBluetoothPhoneState.toCindResult();
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return mBluetoothPhoneState.getCindTestResult();
+            }
+        });
+
+        // Query Signal Quality (legacy)
+        parser.register("+CSQ", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                return mBluetoothPhoneState.toCsqResult();
+            }
+        });
+
+        // Query network registration state
+        parser.register("+CREG", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                return new AtCommandResult(mBluetoothPhoneState.toCregString());
+            }
+        });
+
+        // Send DTMF. I don't know if we are also expected to play the DTMF tone
+        // locally, right now we don't
+        parser.register("+VTS", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (args.length >= 1) {
+                    char c;
+                    if (args[0] instanceof Integer) {
+                        c = ((Integer) args[0]).toString().charAt(0);
+                    } else {
+                        c = ((String) args[0]).charAt(0);
+                    }
+                    if (isValidDtmf(c)) {
+                        phone.sendDtmf(c);
+                        return new AtCommandResult(AtCommandResult.OK);
+                    }
+                }
+                return new AtCommandResult(AtCommandResult.ERROR);
+            }
+            private boolean isValidDtmf(char c) {
+                switch (c) {
+                case '#':
+                case '*':
+                    return true;
+                default:
+                    if (Character.digit(c, 14) != -1) {
+                        return true;  // 0-9 and A-D
+                    }
+                    return false;
+                }
+            }
+        });
+
+        // List calls
+        parser.register("+CLCC", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                int phoneType = phone.getPhoneType();
+                // Handsfree carkits expect that +CLCC is properly responded to.
+                // Hence we ensure that a proper response is sent for the virtual call too.
+                if (isVirtualCallInProgress()) {
+                    String number = phone.getLine1Number();
+                    AtCommandResult result = new AtCommandResult(AtCommandResult.OK);
+                    String args;
+                    if (number == null) {
+                        args = "+CLCC: 1,0,0,0,0,\"\",0";
+                    }
+                    else
+                    {
+                        args = "+CLCC: 1,0,0,0,0,\"" + number + "\"," +
+                                  PhoneNumberUtils.toaFromString(number);
+                    }
+                    result.addResponse(args);
+                    return result;
+                }
+                if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
+                    return cdmaGetClccResult();
+                } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
+                    return gsmGetClccResult();
+                } else {
+                    throw new IllegalStateException("Unexpected phone type: " + phoneType);
+                }
+            }
+        });
+
+        // Call Hold and Multiparty Handling command
+        parser.register("+CHLD", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                int phoneType = phone.getPhoneType();
+                Call ringingCall = mCM.getFirstActiveRingingCall();
+                Call backgroundCall = mCM.getFirstActiveBgCall();
+
+                if (args.length >= 1) {
+                    if (args[0].equals(0)) {
+                        boolean result;
+                        if (ringingCall.isRinging()) {
+                            result = PhoneUtils.hangupRingingCall(ringingCall);
+                        } else {
+                            result = PhoneUtils.hangupHoldingCall(backgroundCall);
+                        }
+                        if (result) {
+                            return new AtCommandResult(AtCommandResult.OK);
+                        } else {
+                            return new AtCommandResult(AtCommandResult.ERROR);
+                        }
+                    } else if (args[0].equals(1)) {
+                        if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
+                            if (ringingCall.isRinging()) {
+                                // Hangup the active call and then answer call waiting call.
+                                if (VDBG) log("CHLD:1 Callwaiting Answer call");
+                                PhoneUtils.hangupRingingAndActive(phone);
+                            } else {
+                                // If there is no Call waiting then just hangup
+                                // the active call. In CDMA this mean that the complete
+                                // call session would be ended
+                                if (VDBG) log("CHLD:1 Hangup Call");
+                                PhoneUtils.hangup(PhoneGlobals.getInstance().mCM);
+                            }
+                            return new AtCommandResult(AtCommandResult.OK);
+                        } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
+                            // Hangup active call, answer held call
+                            if (PhoneUtils.answerAndEndActive(
+                                    PhoneGlobals.getInstance().mCM, ringingCall)) {
+                                return new AtCommandResult(AtCommandResult.OK);
+                            } else {
+                                return new AtCommandResult(AtCommandResult.ERROR);
+                            }
+                        } else {
+                            throw new IllegalStateException("Unexpected phone type: " + phoneType);
+                        }
+                    } else if (args[0].equals(2)) {
+                        sendURC("OK");
+                        if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
+                            // For CDMA, the way we switch to a new incoming call is by
+                            // calling PhoneUtils.answerCall(). switchAndHoldActive() won't
+                            // properly update the call state within telephony.
+                            // If the Phone state is already in CONF_CALL then we simply send
+                            // a flash cmd by calling switchHoldingAndActive()
+                            if (ringingCall.isRinging()) {
+                                if (VDBG) log("CHLD:2 Callwaiting Answer call");
+                                PhoneUtils.answerCall(ringingCall);
+                                PhoneUtils.setMute(false);
+                                // Setting the second callers state flag to TRUE (i.e. active)
+                                cdmaSetSecondCallState(true);
+                            } else if (PhoneGlobals.getInstance().cdmaPhoneCallState
+                                    .getCurrentCallState()
+                                    == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
+                                if (VDBG) log("CHLD:2 Swap Calls");
+                                PhoneUtils.switchHoldingAndActive(backgroundCall);
+                                // Toggle the second callers active state flag
+                                cdmaSwapSecondCallState();
+                            }
+                        } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
+                            PhoneUtils.switchHoldingAndActive(backgroundCall);
+                        } else {
+                            throw new IllegalStateException("Unexpected phone type: " + phoneType);
+                        }
+                        return new AtCommandResult(AtCommandResult.UNSOLICITED);
+                    } else if (args[0].equals(3)) {
+                        sendURC("OK");
+                        if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
+                            CdmaPhoneCallState.PhoneCallState state =
+                                PhoneGlobals.getInstance().cdmaPhoneCallState.getCurrentCallState();
+                            // For CDMA, we need to check if the call is in THRWAY_ACTIVE state
+                            if (state == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
+                                if (VDBG) log("CHLD:3 Merge Calls");
+                                PhoneUtils.mergeCalls();
+                            } else if (state == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
+                                // State is CONF_CALL already and we are getting a merge call
+                                // This can happen when CONF_CALL was entered from a Call Waiting
+                                mBluetoothPhoneState.updateCallHeld();
+                            }
+                        } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
+                            if (mCM.hasActiveFgCall() && mCM.hasActiveBgCall()) {
+                                PhoneUtils.mergeCalls();
+                            }
+                        } else {
+                            throw new IllegalStateException("Unexpected phone type: " + phoneType);
+                        }
+                        return new AtCommandResult(AtCommandResult.UNSOLICITED);
+                    }
+                }
+                return new AtCommandResult(AtCommandResult.ERROR);
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                mServiceConnectionEstablished = true;
+                sendURC("+CHLD: (0,1,2,3)");
+                sendURC("OK");  // send reply first, then connect audio
+                if (isIncallAudio()) {
+                    audioOn();
+                } else if (mCM.getFirstActiveRingingCall().isRinging()) {
+                    // need to update HS with RING when single ringing call exist
+                    mBluetoothPhoneState.ring();
+                }
+                // already replied
+                return new AtCommandResult(AtCommandResult.UNSOLICITED);
+            }
+        });
+
+        // Get Network operator name
+        parser.register("+COPS", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                String operatorName = phone.getServiceState().getOperatorAlphaLong();
+                if (operatorName != null) {
+                    if (operatorName.length() > 16) {
+                        operatorName = operatorName.substring(0, 16);
+                    }
+                    return new AtCommandResult(
+                            "+COPS: 0,0,\"" + operatorName + "\"");
+                } else {
+                    return new AtCommandResult(
+                            "+COPS: 0");
+                }
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // Handsfree only supports AT+COPS=3,0
+                if (args.length != 2 || !(args[0] instanceof Integer)
+                    || !(args[1] instanceof Integer)) {
+                    // syntax error
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                } else if ((Integer)args[0] != 3 || (Integer)args[1] != 0) {
+                    return reportCmeError(BluetoothCmeError.OPERATION_NOT_SUPPORTED);
+                } else {
+                    return new AtCommandResult(AtCommandResult.OK);
+                }
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                // Out of spec, but lets be friendly
+                return new AtCommandResult("+COPS: (3),(0)");
+            }
+        });
+
+        // Mobile PIN
+        // AT+CPIN is not in the handsfree spec (although it is in 3GPP)
+        parser.register("+CPIN", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                return new AtCommandResult("+CPIN: READY");
+            }
+        });
+
+        // Bluetooth Response and Hold
+        // Only supported on PDC (Japan) and CDMA networks.
+        parser.register("+BTRH", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                // Replying with just OK indicates no response and hold
+                // features in use now
+                return new AtCommandResult(AtCommandResult.OK);
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // Neeed PDC or CDMA
+                return new AtCommandResult(AtCommandResult.ERROR);
+            }
+        });
+
+        // Request International Mobile Subscriber Identity (IMSI)
+        // Not in bluetooth handset spec
+        parser.register("+CIMI", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                // AT+CIMI
+                String imsi = phone.getSubscriberId();
+                if (imsi == null || imsi.length() == 0) {
+                    return reportCmeError(BluetoothCmeError.SIM_FAILURE);
+                } else {
+                    return new AtCommandResult(imsi);
+                }
+            }
+        });
+
+        // Calling Line Identification Presentation
+        parser.register("+CLIP", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleReadCommand() {
+                // Currently assumes the network is provisioned for CLIP
+                return new AtCommandResult("+CLIP: " + (mClip ? "1" : "0") + ",1");
+            }
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // AT+CLIP=<n>
+                if (args.length >= 1 && (args[0].equals(0) || args[0].equals(1))) {
+                    mClip = args[0].equals(1);
+                    return new AtCommandResult(AtCommandResult.OK);
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+CLIP: (0-1)");
+            }
+        });
+
+        // AT+CGSN - Returns the device IMEI number.
+        parser.register("+CGSN", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                // Get the IMEI of the device.
+                // phone will not be NULL at this point.
+                return new AtCommandResult("+CGSN: " + phone.getDeviceId());
+            }
+        });
+
+        // AT+CGMM - Query Model Information
+        parser.register("+CGMM", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                // Return the Model Information.
+                String model = SystemProperties.get("ro.product.model");
+                if (model != null) {
+                    return new AtCommandResult("+CGMM: " + model);
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+        });
+
+        // AT+CGMI - Query Manufacturer Information
+        parser.register("+CGMI", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                // Return the Model Information.
+                String manuf = SystemProperties.get("ro.product.manufacturer");
+                if (manuf != null) {
+                    return new AtCommandResult("+CGMI: " + manuf);
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+        });
+
+        // Noise Reduction and Echo Cancellation control
+        parser.register("+NREC", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (args[0].equals(0)) {
+                    mAudioManager.setParameters(HEADSET_NREC+"=off");
+                    return new AtCommandResult(AtCommandResult.OK);
+                } else if (args[0].equals(1)) {
+                    mAudioManager.setParameters(HEADSET_NREC+"=on");
+                    return new AtCommandResult(AtCommandResult.OK);
+                }
+                return new AtCommandResult(AtCommandResult.ERROR);
+            }
+        });
+
+        // Voice recognition (dialing)
+        parser.register("+BVRA", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (!BluetoothHeadset.isBluetoothVoiceDialingEnabled(mContext)) {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+                if (args.length >= 1 && args[0].equals(1)) {
+                    synchronized (BluetoothHandsfree.this) {
+                        if (!isVoiceRecognitionInProgress() &&
+                            !isCellularCallInProgress() &&
+                            !isVirtualCallInProgress()) {
+                            try {
+                                mContext.startActivity(sVoiceCommandIntent);
+                            } catch (ActivityNotFoundException e) {
+                                return new AtCommandResult(AtCommandResult.ERROR);
+                            }
+                            expectVoiceRecognition();
+                        }
+                    }
+                    return new AtCommandResult(AtCommandResult.UNSOLICITED);  // send nothing yet
+                } else if (args.length >= 1 && args[0].equals(0)) {
+                    if (isVoiceRecognitionInProgress()) {
+                        audioOff();
+                    }
+                    return new AtCommandResult(AtCommandResult.OK);
+                }
+                return new AtCommandResult(AtCommandResult.ERROR);
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+BVRA: (0-1)");
+            }
+        });
+
+        // Retrieve Subscriber Number
+        parser.register("+CNUM", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                String number = phone.getLine1Number();
+                if (number == null) {
+                    return new AtCommandResult(AtCommandResult.OK);
+                }
+                return new AtCommandResult("+CNUM: ,\"" + number + "\"," +
+                        PhoneNumberUtils.toaFromString(number) + ",,4");
+            }
+        });
+
+        // Microphone Gain
+        parser.register("+VGM", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // AT+VGM=<gain>    in range [0,15]
+                // Headset/Handsfree is reporting its current gain setting
+                return new AtCommandResult(AtCommandResult.OK);
+            }
+        });
+
+        // Speaker Gain
+        parser.register("+VGS", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                // AT+VGS=<gain>    in range [0,15]
+                if (args.length != 1 || !(args[0] instanceof Integer)) {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+                mScoGain = (Integer) args[0];
+                int flag =  mAudioManager.isBluetoothScoOn() ? AudioManager.FLAG_SHOW_UI:0;
+
+                mAudioManager.setStreamVolume(AudioManager.STREAM_BLUETOOTH_SCO, mScoGain, flag);
+                return new AtCommandResult(AtCommandResult.OK);
+            }
+        });
+
+        // Phone activity status
+        parser.register("+CPAS", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleActionCommand() {
+                int status = 0;
+                switch (mCM.getState()) {
+                case IDLE:
+                    status = 0;
+                    break;
+                case RINGING:
+                    status = 3;
+                    break;
+                case OFFHOOK:
+                    status = 4;
+                    break;
+                }
+                return new AtCommandResult("+CPAS: " + status);
+            }
+        });
+
+        mPhonebook.register(parser);
+        mSMSAccess.register(parser);
+    }
+
+    public void sendScoGainUpdate(int gain) {
+        if (mScoGain != gain && (mRemoteBrsf & BRSF_HF_REMOTE_VOL_CONTROL) != 0x0) {
+            sendURC("+VGS:" + gain);
+            mScoGain = gain;
+        }
+    }
+
+    public AtCommandResult reportCmeError(int error) {
+        if (mCmee) {
+            AtCommandResult result = new AtCommandResult(AtCommandResult.UNSOLICITED);
+            result.addResponse("+CME ERROR: " + error);
+            return result;
+        } else {
+            return new AtCommandResult(AtCommandResult.ERROR);
+        }
+    }
+
+    private static final int START_CALL_TIMEOUT = 10000;  // ms
+
+    private synchronized void expectCallStart() {
+        mWaitingForCallStart = true;
+        Message msg = Message.obtain(mHandler, CHECK_CALL_STARTED);
+        mHandler.sendMessageDelayed(msg, START_CALL_TIMEOUT);
+        if (!mStartCallWakeLock.isHeld()) {
+            mStartCallWakeLock.acquire(START_CALL_TIMEOUT);
+        }
+    }
+
+    private synchronized void callStarted() {
+        if (mWaitingForCallStart) {
+            mWaitingForCallStart = false;
+            sendURC("OK");
+            if (mStartCallWakeLock.isHeld()) {
+                mStartCallWakeLock.release();
+            }
+        }
+    }
+
+    private static final int START_VOICE_RECOGNITION_TIMEOUT = 5000;  // ms
+
+    private synchronized void expectVoiceRecognition() {
+        mWaitingForVoiceRecognition = true;
+        Message msg = Message.obtain(mHandler, CHECK_VOICE_RECOGNITION_STARTED);
+        mHandler.sendMessageDelayed(msg, START_VOICE_RECOGNITION_TIMEOUT);
+        if (!mStartVoiceRecognitionWakeLock.isHeld()) {
+            mStartVoiceRecognitionWakeLock.acquire(START_VOICE_RECOGNITION_TIMEOUT);
+        }
+    }
+
+    /* package */ synchronized boolean startVoiceRecognition() {
+
+        if  ((isCellularCallInProgress()) ||
+             (isVirtualCallInProgress()) ||
+             mVoiceRecognitionStarted) {
+            Log.e(TAG, "startVoiceRecognition: Call in progress");
+            return false;
+        }
+
+        mVoiceRecognitionStarted = true;
+
+        if (mWaitingForVoiceRecognition) {
+            // HF initiated
+            mWaitingForVoiceRecognition = false;
+            sendURC("OK");
+        } else {
+            // AG initiated
+            sendURC("+BVRA: 1");
+        }
+        boolean ret = audioOn();
+        if (ret == false) {
+            mVoiceRecognitionStarted = false;
+        }
+        if (mStartVoiceRecognitionWakeLock.isHeld()) {
+            mStartVoiceRecognitionWakeLock.release();
+        }
+        return ret;
+    }
+
+    /* package */ synchronized boolean stopVoiceRecognition() {
+
+        if (!isVoiceRecognitionInProgress()) {
+            return false;
+        }
+
+        mVoiceRecognitionStarted = false;
+
+        sendURC("+BVRA: 0");
+        audioOff();
+        return true;
+    }
+
+    // Voice Recognition in Progress
+    private boolean isVoiceRecognitionInProgress() {
+        return (mVoiceRecognitionStarted || mWaitingForVoiceRecognition);
+    }
+
+    /*
+     * This class broadcasts vendor-specific commands + arguments to interested receivers.
+     */
+    private class VendorSpecificCommandHandler extends AtCommandHandler {
+
+        private String mCommandName;
+
+        private int mCompanyId;
+
+        private VendorSpecificCommandHandler(String commandName, int companyId) {
+            mCommandName = commandName;
+            mCompanyId = companyId;
+        }
+
+        @Override
+        public AtCommandResult handleReadCommand() {
+            return new AtCommandResult(AtCommandResult.ERROR);
+        }
+
+        @Override
+        public AtCommandResult handleTestCommand() {
+            return new AtCommandResult(AtCommandResult.ERROR);
+        }
+
+        @Override
+        public AtCommandResult handleActionCommand() {
+            return new AtCommandResult(AtCommandResult.ERROR);
+        }
+
+        @Override
+        public AtCommandResult handleSetCommand(Object[] arguments) {
+            broadcastVendorSpecificEventIntent(mCommandName,
+                                               mCompanyId,
+                                               BluetoothHeadset.AT_CMD_TYPE_SET,
+                                               arguments,
+                                               mHeadset.getRemoteDevice());
+            return new AtCommandResult(AtCommandResult.OK);
+        }
+    }
+
+    private boolean inDebug() {
+        return DBG && SystemProperties.getBoolean(DebugThread.DEBUG_HANDSFREE, false);
+    }
+
+    private boolean allowAudioAnytime() {
+        return inDebug() && SystemProperties.getBoolean(DebugThread.DEBUG_HANDSFREE_AUDIO_ANYTIME,
+                false);
+    }
+
+    private void startDebug() {
+        if (DBG && mDebugThread == null) {
+            mDebugThread = new DebugThread();
+            mDebugThread.start();
+        }
+    }
+
+    private void stopDebug() {
+        if (mDebugThread != null) {
+            mDebugThread.interrupt();
+            mDebugThread = null;
+        }
+    }
+
+    // VirtualCall SCO support
+    //
+
+    // Cellular call in progress
+    private boolean isCellularCallInProgress() {
+        if (mCM.hasActiveFgCall() || mCM.hasActiveRingingCall()) return true;
+        return false;
+    }
+
+    // Virtual Call in Progress
+    private boolean isVirtualCallInProgress() {
+        return mVirtualCallStarted;
+    }
+
+    void setVirtualCallInProgress(boolean state) {
+        mVirtualCallStarted = state;
+    }
+
+    //NOTE: Currently the VirtualCall API does not allow the application to initiate a call
+    // transfer. Call transfer may be initiated from the handsfree device and this is handled by
+    // the VirtualCall API
+    synchronized boolean initiateScoUsingVirtualVoiceCall() {
+        if (DBG) log("initiateScoUsingVirtualVoiceCall: Received");
+        // 1. Check if the SCO state is idle
+        if (isCellularCallInProgress() || isVoiceRecognitionInProgress()) {
+            Log.e(TAG, "initiateScoUsingVirtualVoiceCall: Call in progress");
+            return false;
+        }
+
+        // 2. Perform outgoing call setup procedure
+        if (mBluetoothPhoneState.sendUpdate() && !isVirtualCallInProgress()) {
+            AtCommandResult result = new AtCommandResult(AtCommandResult.UNSOLICITED);
+            // outgoing call
+            result.addResponse("+CIEV: 3,2");
+            result.addResponse("+CIEV: 2,1");
+            result.addResponse("+CIEV: 3,0");
+            sendURC(result.toString());
+            if (DBG) Log.d(TAG, "initiateScoUsingVirtualVoiceCall: Sent Call-setup procedure");
+        }
+
+        mVirtualCallStarted = true;
+
+        // 3. Open the Audio Connection
+        if (audioOn() == false) {
+            log("initiateScoUsingVirtualVoiceCall: audioON failed");
+            terminateScoUsingVirtualVoiceCall();
+            return false;
+        }
+
+        mAudioPossible = true;
+
+        // Done
+        if (DBG) log("initiateScoUsingVirtualVoiceCall: Done");
+        return true;
+    }
+
+    synchronized boolean terminateScoUsingVirtualVoiceCall() {
+        if (DBG) log("terminateScoUsingVirtualVoiceCall: Received");
+
+        if (!isVirtualCallInProgress()) {
+            return false;
+        }
+
+        // 1. Release audio connection
+        audioOff();
+
+        // 2. terminate call-setup
+        if (mBluetoothPhoneState.sendUpdate()) {
+            AtCommandResult result = new AtCommandResult(AtCommandResult.UNSOLICITED);
+            // outgoing call
+            result.addResponse("+CIEV: 2,0");
+            sendURC(result.toString());
+            if (DBG) log("terminateScoUsingVirtualVoiceCall: Sent Call-setup procedure");
+        }
+        mVirtualCallStarted = false;
+        mAudioPossible = false;
+
+        // Done
+        if (DBG) log("terminateScoUsingVirtualVoiceCall: Done");
+        return true;
+    }
+
+
+    /** Debug thread to read debug properties - runs when debug.bt.hfp is true
+     *  at the time a bluetooth handsfree device is connected. Debug properties
+     *  are polled and mock updates sent every 1 second */
+    private class DebugThread extends Thread {
+        /** Turns on/off handsfree profile debugging mode */
+        static final String DEBUG_HANDSFREE = "debug.bt.hfp";
+
+        /** Mock battery level change - use 0 to 5 */
+        static final String DEBUG_HANDSFREE_BATTERY = "debug.bt.hfp.battery";
+
+        /** Mock no cellular service when false */
+        static final String DEBUG_HANDSFREE_SERVICE = "debug.bt.hfp.service";
+
+        /** Mock cellular roaming when true */
+        static final String DEBUG_HANDSFREE_ROAM = "debug.bt.hfp.roam";
+
+        /** false to true transition will force an audio (SCO) connection to
+         *  be established. true to false will force audio to be disconnected
+         */
+        static final String DEBUG_HANDSFREE_AUDIO = "debug.bt.hfp.audio";
+
+        /** true allows incoming SCO connection out of call.
+         */
+        static final String DEBUG_HANDSFREE_AUDIO_ANYTIME = "debug.bt.hfp.audio_anytime";
+
+        /** Mock signal strength change in ASU - use 0 to 31 */
+        static final String DEBUG_HANDSFREE_SIGNAL = "debug.bt.hfp.signal";
+
+        /** Debug AT+CLCC: print +CLCC result */
+        static final String DEBUG_HANDSFREE_CLCC = "debug.bt.hfp.clcc";
+
+        /** Debug AT+BSIR - Send In Band Ringtones Unsolicited AT command.
+         * debug.bt.unsol.inband = 0 => AT+BSIR = 0 sent by the AG
+         * debug.bt.unsol.inband = 1 => AT+BSIR = 0 sent by the AG
+         * Other values are ignored.
+         */
+
+        static final String DEBUG_UNSOL_INBAND_RINGTONE = "debug.bt.unsol.inband";
+
+        @Override
+        public void run() {
+            boolean oldService = true;
+            boolean oldRoam = false;
+            boolean oldAudio = false;
+
+            while (!isInterrupted() && inDebug()) {
+                int batteryLevel = SystemProperties.getInt(DEBUG_HANDSFREE_BATTERY, -1);
+                if (batteryLevel >= 0 && batteryLevel <= 5) {
+                    Intent intent = new Intent();
+                    intent.putExtra("level", batteryLevel);
+                    intent.putExtra("scale", 5);
+                    mBluetoothPhoneState.updateBatteryState(intent);
+                }
+
+                boolean serviceStateChanged = false;
+                if (SystemProperties.getBoolean(DEBUG_HANDSFREE_SERVICE, true) != oldService) {
+                    oldService = !oldService;
+                    serviceStateChanged = true;
+                }
+                if (SystemProperties.getBoolean(DEBUG_HANDSFREE_ROAM, false) != oldRoam) {
+                    oldRoam = !oldRoam;
+                    serviceStateChanged = true;
+                }
+                if (serviceStateChanged) {
+                    Bundle b = new Bundle();
+                    b.putInt("state", oldService ? 0 : 1);
+                    b.putBoolean("roaming", oldRoam);
+                    mBluetoothPhoneState.updateServiceState(true, ServiceState.newFromBundle(b));
+                }
+
+                if (SystemProperties.getBoolean(DEBUG_HANDSFREE_AUDIO, false) != oldAudio) {
+                    oldAudio = !oldAudio;
+                    if (oldAudio) {
+                        audioOn();
+                    } else {
+                        audioOff();
+                    }
+                }
+
+                int signalLevel = SystemProperties.getInt(DEBUG_HANDSFREE_SIGNAL, -1);
+                if (signalLevel >= 0 && signalLevel <= 31) {
+                    SignalStrength signalStrength = new SignalStrength(signalLevel, -1, -1, -1,
+                            -1, -1, -1, true);
+                    Intent intent = new Intent();
+                    Bundle data = new Bundle();
+                    signalStrength.fillInNotifierBundle(data);
+                    intent.putExtras(data);
+                    mBluetoothPhoneState.updateSignalState(intent);
+                }
+
+                if (SystemProperties.getBoolean(DEBUG_HANDSFREE_CLCC, false)) {
+                    log(gsmGetClccResult().toString());
+                }
+                try {
+                    sleep(1000);  // 1 second
+                } catch (InterruptedException e) {
+                    break;
+                }
+
+                int inBandRing =
+                    SystemProperties.getInt(DEBUG_UNSOL_INBAND_RINGTONE, -1);
+                if (inBandRing == 0 || inBandRing == 1) {
+                    AtCommandResult result =
+                        new AtCommandResult(AtCommandResult.UNSOLICITED);
+                    result.addResponse("+BSIR: " + inBandRing);
+                    sendURC(result.toString());
+                }
+            }
+        }
+    }
+
+    public void cdmaSwapSecondCallState() {
+        if (VDBG) log("cdmaSetSecondCallState: Toggling mCdmaIsSecondCallActive");
+        mCdmaIsSecondCallActive = !mCdmaIsSecondCallActive;
+        mCdmaCallsSwapped = true;
+    }
+
+    public void cdmaSetSecondCallState(boolean state) {
+        if (VDBG) log("cdmaSetSecondCallState: Setting mCdmaIsSecondCallActive to " + state);
+        mCdmaIsSecondCallActive = state;
+
+        if (!mCdmaIsSecondCallActive) {
+            mCdmaCallsSwapped = false;
+        }
+    }
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/src/com/android/phone/BluetoothHeadsetService.java b/src/com/android/phone/BluetoothHeadsetService.java
new file mode 100644
index 0000000..ff8b9d8
--- /dev/null
+++ b/src/com/android/phone/BluetoothHeadsetService.java
@@ -0,0 +1,927 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.phone;
+
+import android.app.Service;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothAudioGateway;
+import android.bluetooth.BluetoothAudioGateway.IncomingConnectionInfo;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.bluetooth.HeadsetBase;
+import android.bluetooth.IBluetooth;
+import android.bluetooth.IBluetoothHeadset;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.media.AudioManager;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.ParcelUuid;
+import android.os.PowerManager;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Provides Bluetooth Headset and Handsfree profile, as a service in
+ * the Phone application.
+ * @hide
+ */
+public class BluetoothHeadsetService extends Service {
+    private static final String TAG = "Bluetooth HSHFP";
+    private static final boolean DBG = true;
+
+    private static final String PREF_NAME = BluetoothHeadsetService.class.getSimpleName();
+    private static final String PREF_LAST_HEADSET = "lastHeadsetAddress";
+
+    private static final int PHONE_STATE_CHANGED = 1;
+
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+    private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+
+    private static boolean sHasStarted = false;
+
+    private BluetoothDevice mDeviceSdpQuery;
+    private BluetoothAdapter mAdapter;
+    private IBluetooth mBluetoothService;
+    private PowerManager mPowerManager;
+    private BluetoothAudioGateway mAg;
+    private BluetoothHandsfree mBtHandsfree;
+    private ConcurrentHashMap<BluetoothDevice, BluetoothRemoteHeadset> mRemoteHeadsets;
+    private BluetoothDevice mAudioConnectedDevice;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        mPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
+        mBtHandsfree = PhoneGlobals.getInstance().getBluetoothHandsfree();
+        mAg = new BluetoothAudioGateway(mAdapter);
+        IntentFilter filter = new IntentFilter(
+                BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);
+        filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+        filter.addAction(AudioManager.VOLUME_CHANGED_ACTION);
+        filter.addAction(BluetoothDevice.ACTION_UUID);
+        registerReceiver(mBluetoothReceiver, filter);
+
+        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
+        if (b == null) {
+            throw new RuntimeException("Bluetooth service not available");
+        }
+        mBluetoothService = IBluetooth.Stub.asInterface(b);
+        mRemoteHeadsets = new ConcurrentHashMap<BluetoothDevice, BluetoothRemoteHeadset>();
+   }
+
+   private class BluetoothRemoteHeadset {
+       private int mState;
+       private int mAudioState;
+       private int mHeadsetType;
+       private HeadsetBase mHeadset;
+       private IncomingConnectionInfo mIncomingInfo;
+
+       BluetoothRemoteHeadset() {
+           mState = BluetoothProfile.STATE_DISCONNECTED;
+           mHeadsetType = BluetoothHandsfree.TYPE_UNKNOWN;
+           mHeadset = null;
+           mIncomingInfo = null;
+           mAudioState = BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
+       }
+
+       BluetoothRemoteHeadset(int headsetType, IncomingConnectionInfo incomingInfo) {
+           mState = BluetoothProfile.STATE_DISCONNECTED;
+           mHeadsetType = headsetType;
+           mHeadset = null;
+           mIncomingInfo = incomingInfo;
+           mAudioState = BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
+       }
+   }
+
+   synchronized private BluetoothDevice getCurrentDevice() {
+       for (BluetoothDevice device : mRemoteHeadsets.keySet()) {
+           int state = mRemoteHeadsets.get(device).mState;
+           if (state == BluetoothProfile.STATE_CONNECTING ||
+               state == BluetoothProfile.STATE_CONNECTED) {
+               return device;
+           }
+       }
+       return null;
+   }
+
+    @Override
+    public void onStart(Intent intent, int startId) {
+         if (mAdapter == null) {
+            Log.w(TAG, "Stopping BluetoothHeadsetService: device does not have BT");
+            stopSelf();
+        } else {
+            if (!sHasStarted) {
+                if (DBG) log("Starting BluetoothHeadsetService");
+                if (mAdapter.isEnabled()) {
+                    mAg.start(mIncomingConnectionHandler);
+                    mBtHandsfree.onBluetoothEnabled();
+                }
+                sHasStarted = true;
+            }
+        }
+    }
+
+    private final Handler mIncomingConnectionHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            synchronized(BluetoothHeadsetService.this) {
+                IncomingConnectionInfo info = (IncomingConnectionInfo)msg.obj;
+                int type = BluetoothHandsfree.TYPE_UNKNOWN;
+                switch(msg.what) {
+                case BluetoothAudioGateway.MSG_INCOMING_HEADSET_CONNECTION:
+                    type = BluetoothHandsfree.TYPE_HEADSET;
+                    break;
+                case BluetoothAudioGateway.MSG_INCOMING_HANDSFREE_CONNECTION:
+                    type = BluetoothHandsfree.TYPE_HANDSFREE;
+                    break;
+                }
+
+                Log.i(TAG, "Incoming rfcomm (" + BluetoothHandsfree.typeToString(type) +
+                      ") connection from " + info.mRemoteDevice + "on channel " +
+                      info.mRfcommChan);
+
+                int priority = BluetoothProfile.PRIORITY_OFF;
+                HeadsetBase headset;
+                priority = getPriority(info.mRemoteDevice);
+                if (priority <= BluetoothProfile.PRIORITY_OFF) {
+                    Log.i(TAG, "Rejecting incoming connection because priority = " + priority);
+
+                    headset = new HeadsetBase(mPowerManager, mAdapter,
+                                              info.mRemoteDevice,
+                                              info.mSocketFd, info.mRfcommChan,
+                                              null);
+                    headset.disconnect();
+                    try {
+                        mBluetoothService.notifyIncomingConnection(info.mRemoteDevice.getAddress(),
+                                                                   true);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "notifyIncomingConnection", e);
+                    }
+                    return;
+                }
+
+                BluetoothRemoteHeadset remoteHeadset;
+                BluetoothDevice device = getCurrentDevice();
+
+                int state = BluetoothProfile.STATE_DISCONNECTED;
+                if (device != null) {
+                    state = mRemoteHeadsets.get(device).mState;
+                }
+
+                switch (state) {
+                case BluetoothProfile.STATE_DISCONNECTED:
+                    // headset connecting us, lets join
+                    remoteHeadset = new BluetoothRemoteHeadset(type, info);
+                    mRemoteHeadsets.put(info.mRemoteDevice, remoteHeadset);
+
+                    try {
+                        mBluetoothService.notifyIncomingConnection(
+                           info.mRemoteDevice.getAddress(), false);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "notifyIncomingConnection");
+                    }
+                    break;
+                case BluetoothProfile.STATE_CONNECTING:
+                    if (!info.mRemoteDevice.equals(device)) {
+                        // different headset, ignoring
+                        Log.i(TAG, "Already attempting connect to " + device +
+                              ", disconnecting " + info.mRemoteDevice);
+
+                        headset = new HeadsetBase(mPowerManager, mAdapter,
+                                                  info.mRemoteDevice,
+                                                  info.mSocketFd, info.mRfcommChan,
+                                                  null);
+                        headset.disconnect();
+                        break;
+                    }
+
+                    // Incoming and Outgoing connections to the same headset.
+                    // The state machine manager will cancel outgoing and accept the incoming one.
+                    // Update the state
+                    mRemoteHeadsets.get(info.mRemoteDevice).mHeadsetType = type;
+                    mRemoteHeadsets.get(info.mRemoteDevice).mIncomingInfo = info;
+
+                    try {
+                        mBluetoothService.notifyIncomingConnection(
+                            info.mRemoteDevice.getAddress(), false);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "notifyIncomingConnection");
+                    }
+                    break;
+                case BluetoothProfile.STATE_CONNECTED:
+                    Log.i(TAG, "Already connected to " + device + ", disconnecting " +
+                            info.mRemoteDevice);
+                    rejectIncomingConnection(info);
+                    break;
+                }
+            }
+        }
+    };
+
+    private void rejectIncomingConnection(IncomingConnectionInfo info) {
+        HeadsetBase headset = new HeadsetBase(mPowerManager, mAdapter,
+            info.mRemoteDevice, info.mSocketFd, info.mRfcommChan, null);
+        headset.disconnect();
+    }
+
+
+    private final BroadcastReceiver mBluetoothReceiver = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            BluetoothDevice device =
+                    intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+            BluetoothDevice currDevice = getCurrentDevice();
+            int state = BluetoothProfile.STATE_DISCONNECTED;
+            if (currDevice != null) {
+                state = mRemoteHeadsets.get(currDevice).mState;
+            }
+
+            if ((state == BluetoothProfile.STATE_CONNECTED ||
+                    state == BluetoothProfile.STATE_CONNECTING) &&
+                    action.equals(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED) &&
+                    device.equals(currDevice)) {
+                try {
+                    mBinder.disconnect(currDevice);
+                } catch (RemoteException e) {}
+            } else if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+                switch (intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                                           BluetoothAdapter.ERROR)) {
+                case BluetoothAdapter.STATE_ON:
+                    mAg.start(mIncomingConnectionHandler);
+                    mBtHandsfree.onBluetoothEnabled();
+                    break;
+                case BluetoothAdapter.STATE_TURNING_OFF:
+                    mBtHandsfree.onBluetoothDisabled();
+                    mAg.stop();
+                    if (currDevice != null) {
+                        try {
+                            mBinder.disconnect(currDevice);
+                        } catch (RemoteException e) {}
+                    }
+                    break;
+                }
+            } else if (action.equals(AudioManager.VOLUME_CHANGED_ACTION)) {
+                int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
+                if (streamType == AudioManager.STREAM_BLUETOOTH_SCO) {
+                    mBtHandsfree.sendScoGainUpdate(intent.getIntExtra(
+                            AudioManager.EXTRA_VOLUME_STREAM_VALUE, 0));
+                }
+
+            } else if (action.equals(BluetoothDevice.ACTION_UUID)) {
+                if (device.equals(mDeviceSdpQuery) && device.equals(currDevice)) {
+                    // We have got SDP records for the device we are interested in.
+                    getSdpRecordsAndConnect(device);
+                }
+            }
+        }
+    };
+
+    private static final int CONNECT_HEADSET_DELAYED = 1;
+    private Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case CONNECT_HEADSET_DELAYED:
+                    BluetoothDevice device = (BluetoothDevice) msg.obj;
+                    getSdpRecordsAndConnect(device);
+                    break;
+            }
+        }
+    };
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return mBinder;
+    }
+
+    // ------------------------------------------------------------------
+    // Bluetooth Headset Connect
+    // ------------------------------------------------------------------
+    private static final int RFCOMM_CONNECTED             = 1;
+    private static final int RFCOMM_ERROR                 = 2;
+
+    private long mTimestamp;
+
+    /**
+     * Thread for RFCOMM connection
+     * Messages are sent to mConnectingStatusHandler as connection progresses.
+     */
+    private RfcommConnectThread mConnectThread;
+    private class RfcommConnectThread extends Thread {
+        private BluetoothDevice device;
+        private int channel;
+        private int type;
+
+        private static final int EINTERRUPT = -1000;
+        private static final int ECONNREFUSED = -111;
+
+        public RfcommConnectThread(BluetoothDevice device, int channel, int type) {
+            super();
+            this.device = device;
+            this.channel = channel;
+            this.type = type;
+        }
+
+        private int waitForConnect(HeadsetBase headset) {
+            // Try to connect for 20 seconds
+            int result = 0;
+            for (int i=0; i < 40 && result == 0; i++) {
+                // waitForAsyncConnect returns 0 on timeout, 1 on success, < 0 on error.
+                result = headset.waitForAsyncConnect(500, mConnectedStatusHandler);
+                if (isInterrupted()) {
+                    headset.disconnect();
+                    return EINTERRUPT;
+                }
+            }
+            return result;
+        }
+
+        @Override
+        public void run() {
+            long timestamp;
+
+            timestamp = System.currentTimeMillis();
+            HeadsetBase headset = new HeadsetBase(mPowerManager, mAdapter,
+                                                  device, channel);
+
+            int result = waitForConnect(headset);
+
+            if (result != EINTERRUPT && result != 1) {
+                if (result == ECONNREFUSED && mDeviceSdpQuery == null) {
+                    // The rfcomm channel number might have changed, do SDP
+                    // query and try to connect again.
+                    mDeviceSdpQuery = getCurrentDevice();
+                    device.fetchUuidsWithSdp();
+                    mConnectThread = null;
+                    return;
+                } else {
+                    Log.i(TAG, "Trying to connect to rfcomm socket again after 1 sec");
+                    try {
+                      sleep(1000);  // 1 second
+                    } catch (InterruptedException e) {
+                      return;
+                    }
+                }
+                result = waitForConnect(headset);
+            }
+            mDeviceSdpQuery = null;
+            if (result == EINTERRUPT) return;
+
+            if (DBG) log("RFCOMM connection attempt took " +
+                  (System.currentTimeMillis() - timestamp) + " ms");
+            if (isInterrupted()) {
+                headset.disconnect();
+                return;
+            }
+            if (result < 0) {
+                Log.w(TAG, "headset.waitForAsyncConnect() error: " + result);
+                mConnectingStatusHandler.obtainMessage(RFCOMM_ERROR).sendToTarget();
+                return;
+            } else if (result == 0) {
+                mConnectingStatusHandler.obtainMessage(RFCOMM_ERROR).sendToTarget();
+                Log.w(TAG, "mHeadset.waitForAsyncConnect() error: " + result + "(timeout)");
+                return;
+            } else {
+                mConnectingStatusHandler.obtainMessage(RFCOMM_CONNECTED, headset).sendToTarget();
+            }
+        }
+    }
+
+    /**
+     * Receives events from mConnectThread back in the main thread.
+     */
+    private final Handler mConnectingStatusHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            BluetoothDevice device = getCurrentDevice();
+            if (device == null ||
+                mRemoteHeadsets.get(device).mState != BluetoothProfile.STATE_CONNECTING) {
+                return;  // stale events
+            }
+
+            switch (msg.what) {
+            case RFCOMM_ERROR:
+                if (DBG) log("Rfcomm error");
+                mConnectThread = null;
+                setState(device, BluetoothProfile.STATE_DISCONNECTED);
+                break;
+            case RFCOMM_CONNECTED:
+                if (DBG) log("Rfcomm connected");
+                mConnectThread = null;
+                HeadsetBase headset = (HeadsetBase)msg.obj;
+                setState(device, BluetoothProfile.STATE_CONNECTED);
+
+                mRemoteHeadsets.get(device).mHeadset = headset;
+                mBtHandsfree.connectHeadset(headset, mRemoteHeadsets.get(device).mHeadsetType);
+                break;
+            }
+        }
+    };
+
+    /**
+     * Receives events from a connected RFCOMM socket back in the main thread.
+     */
+    private final Handler mConnectedStatusHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case HeadsetBase.RFCOMM_DISCONNECTED:
+                mBtHandsfree.resetAtState();
+                mBtHandsfree.setVirtualCallInProgress(false);
+                BluetoothDevice device = getCurrentDevice();
+                if (device != null) {
+                    setState(device, BluetoothProfile.STATE_DISCONNECTED);
+                }
+                break;
+            }
+        }
+    };
+
+    private synchronized void setState(BluetoothDevice device, int state) {
+        int prevState = mRemoteHeadsets.get(device).mState;
+        if (state != prevState) {
+            if (DBG) log("Device: " + device +
+                " Headset  state" + prevState + " -> " + state);
+            if (prevState == BluetoothProfile.STATE_CONNECTED) {
+                // Headset is disconnecting, stop the parser.
+                mBtHandsfree.disconnectHeadset();
+            }
+            Intent intent = new Intent(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+            intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
+            intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            if (state == BluetoothProfile.STATE_DISCONNECTED) {
+                mRemoteHeadsets.get(device).mHeadset = null;
+                mRemoteHeadsets.get(device).mHeadsetType = BluetoothHandsfree.TYPE_UNKNOWN;
+            }
+
+            mRemoteHeadsets.get(device).mState = state;
+
+            sendBroadcast(intent, BLUETOOTH_PERM);
+            if (state == BluetoothHeadset.STATE_CONNECTED) {
+                // Set the priority to AUTO_CONNECT
+                setPriority(device, BluetoothHeadset.PRIORITY_AUTO_CONNECT);
+                adjustOtherHeadsetPriorities(device);
+            }
+            try {
+                mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.HEADSET,
+                                                            state, prevState);
+            } catch (RemoteException e) {
+                Log.e(TAG, "sendConnectionStateChange: exception");
+            }
+       }
+    }
+
+    private void adjustOtherHeadsetPriorities(BluetoothDevice connectedDevice) {
+       for (BluetoothDevice device : mAdapter.getBondedDevices()) {
+          if (getPriority(device) >= BluetoothHeadset.PRIORITY_AUTO_CONNECT &&
+              !device.equals(connectedDevice)) {
+              setPriority(device, BluetoothHeadset.PRIORITY_ON);
+          }
+       }
+    }
+
+    private void setPriority(BluetoothDevice device, int priority) {
+        try {
+            mBinder.setPriority(device, priority);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error while setting priority for: " + device);
+        }
+    }
+
+    private int getPriority(BluetoothDevice device) {
+        try {
+            return mBinder.getPriority(device);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error while getting priority for: " + device);
+        }
+        return BluetoothProfile.PRIORITY_UNDEFINED;
+    }
+
+    private synchronized void getSdpRecordsAndConnect(BluetoothDevice device) {
+        if (!device.equals(getCurrentDevice())) {
+            // stale
+            return;
+        }
+
+        // Check if incoming connection has already connected.
+        if (mRemoteHeadsets.get(device).mState == BluetoothProfile.STATE_CONNECTED) {
+            return;
+        }
+
+        ParcelUuid[] uuids = device.getUuids();
+        ParcelUuid[] localUuids = mAdapter.getUuids();
+        int type = BluetoothHandsfree.TYPE_UNKNOWN;
+        if (uuids != null) {
+            if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree) &&
+                BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG)) {
+                log("SDP UUID: TYPE_HANDSFREE");
+                type = BluetoothHandsfree.TYPE_HANDSFREE;
+                mRemoteHeadsets.get(device).mHeadsetType = type;
+                int channel = device.getServiceChannel(BluetoothUuid.Handsfree);
+                mConnectThread = new RfcommConnectThread(device, channel, type);
+                if (mAdapter.isDiscovering()) {
+                    mAdapter.cancelDiscovery();
+                }
+                mConnectThread.start();
+                if (getPriority(device) < BluetoothHeadset.PRIORITY_AUTO_CONNECT) {
+                    setPriority(device, BluetoothHeadset.PRIORITY_AUTO_CONNECT);
+                }
+                return;
+            } else if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP) &&
+                BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG)) {
+                log("SDP UUID: TYPE_HEADSET");
+                type = BluetoothHandsfree.TYPE_HEADSET;
+                mRemoteHeadsets.get(device).mHeadsetType = type;
+                int channel = device.getServiceChannel(BluetoothUuid.HSP);
+                mConnectThread = new RfcommConnectThread(device, channel, type);
+                if (mAdapter.isDiscovering()) {
+                    mAdapter.cancelDiscovery();
+                }
+                mConnectThread.start();
+                if (getPriority(device) < BluetoothHeadset.PRIORITY_AUTO_CONNECT) {
+                    setPriority(device, BluetoothHeadset.PRIORITY_AUTO_CONNECT);
+                }
+                return;
+            }
+        }
+        log("SDP UUID: TYPE_UNKNOWN");
+        mRemoteHeadsets.get(device).mHeadsetType = type;
+        setState(device, BluetoothProfile.STATE_DISCONNECTED);
+        return;
+    }
+
+    /**
+     * Handlers for incoming service calls
+     */
+    private final IBluetoothHeadset.Stub mBinder = new IBluetoothHeadset.Stub() {
+        public int getConnectionState(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            BluetoothRemoteHeadset headset = mRemoteHeadsets.get(device);
+            if (headset == null) {
+                return BluetoothProfile.STATE_DISCONNECTED;
+            }
+            return headset.mState;
+        }
+
+        public List<BluetoothDevice> getConnectedDevices() {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            return getDevicesMatchingConnectionStates(
+                new int[] {BluetoothProfile.STATE_CONNECTED});
+        }
+
+        public boolean connect(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                           "Need BLUETOOTH_ADMIN permission");
+            synchronized (BluetoothHeadsetService.this) {
+                BluetoothDevice currDevice = getCurrentDevice();
+
+                if (currDevice == device ||
+                    getPriority(device) == BluetoothProfile.PRIORITY_OFF) {
+                    return false;
+                }
+                if (currDevice != null) {
+                    disconnect(currDevice);
+                }
+                try {
+                    return mBluetoothService.connectHeadset(device.getAddress());
+                } catch (RemoteException e) {
+                    Log.e(TAG, "connectHeadset");
+                    return false;
+                }
+            }
+        }
+
+        public boolean disconnect(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                           "Need BLUETOOTH_ADMIN permission");
+            synchronized (BluetoothHeadsetService.this) {
+                BluetoothRemoteHeadset headset = mRemoteHeadsets.get(device);
+                if (headset == null ||
+                    headset.mState == BluetoothProfile.STATE_DISCONNECTED ||
+                    headset.mState == BluetoothProfile.STATE_DISCONNECTING) {
+                    return false;
+                }
+                try {
+                    return mBluetoothService.disconnectHeadset(device.getAddress());
+                } catch (RemoteException e) {
+                    Log.e(TAG, "disconnectHeadset");
+                    return false;
+                }
+            }
+        }
+
+        public synchronized boolean isAudioConnected(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            if (device.equals(mAudioConnectedDevice)) return true;
+            return false;
+        }
+
+        public synchronized List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            List<BluetoothDevice> headsets = new ArrayList<BluetoothDevice>();
+            for (BluetoothDevice device: mRemoteHeadsets.keySet()) {
+                int headsetState = getConnectionState(device);
+                for (int state : states) {
+                    if (state == headsetState) {
+                        headsets.add(device);
+                        break;
+                    }
+                }
+            }
+            return headsets;
+        }
+
+        public boolean startVoiceRecognition(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            synchronized (BluetoothHeadsetService.this) {
+                if (device == null ||
+                    mRemoteHeadsets.get(device) == null ||
+                    mRemoteHeadsets.get(device).mState != BluetoothProfile.STATE_CONNECTED) {
+                    return false;
+                }
+                return mBtHandsfree.startVoiceRecognition();
+            }
+        }
+
+        public boolean stopVoiceRecognition(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            synchronized (BluetoothHeadsetService.this) {
+                if (device == null ||
+                    mRemoteHeadsets.get(device) == null ||
+                    mRemoteHeadsets.get(device).mState != BluetoothProfile.STATE_CONNECTED) {
+                    return false;
+                }
+
+                return mBtHandsfree.stopVoiceRecognition();
+            }
+        }
+
+        public int getBatteryUsageHint(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+            return HeadsetBase.getAtInputCount();
+        }
+
+        public int getPriority(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                "Need BLUETOOTH_ADMIN permission");
+            synchronized (BluetoothHeadsetService.this) {
+                int priority = Settings.Global.getInt(getContentResolver(),
+                        Settings.Global.getBluetoothHeadsetPriorityKey(device.getAddress()),
+                        BluetoothProfile.PRIORITY_UNDEFINED);
+                return priority;
+            }
+        }
+
+        public boolean setPriority(BluetoothDevice device, int priority) {
+            enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                "Need BLUETOOTH_ADMIN permission");
+            synchronized (BluetoothHeadsetService.this) {
+                Settings.Global.putInt(getContentResolver(),
+                        Settings.Global.getBluetoothHeadsetPriorityKey(device.getAddress()),
+                        priority);
+                if (DBG) log("Saved priority " + device + " = " + priority);
+                return true;
+            }
+        }
+
+        public boolean createIncomingConnect(BluetoothDevice device) {
+            synchronized (BluetoothHeadsetService.this) {
+                HeadsetBase headset;
+                setState(device, BluetoothProfile.STATE_CONNECTING);
+
+                IncomingConnectionInfo info = mRemoteHeadsets.get(device).mIncomingInfo;
+                headset = new HeadsetBase(mPowerManager, mAdapter,
+                                          device,
+                                          info.mSocketFd, info.mRfcommChan,
+                                          mConnectedStatusHandler);
+
+                mRemoteHeadsets.get(device).mHeadset = headset;
+
+                mConnectingStatusHandler.obtainMessage(RFCOMM_CONNECTED, headset).sendToTarget();
+                return true;
+            }
+        }
+
+        public boolean startScoUsingVirtualVoiceCall(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            synchronized (BluetoothHeadsetService.this) {
+                if (device == null ||
+                    mRemoteHeadsets.get(device) == null ||
+                    mRemoteHeadsets.get(device).mState != BluetoothProfile.STATE_CONNECTED ||
+                    getAudioState(device) != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
+                    return false;
+                }
+                return mBtHandsfree.initiateScoUsingVirtualVoiceCall();
+            }
+        }
+
+        public boolean stopScoUsingVirtualVoiceCall(BluetoothDevice device) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            synchronized (BluetoothHeadsetService.this) {
+                if (device == null ||
+                    mRemoteHeadsets.get(device) == null ||
+                    mRemoteHeadsets.get(device).mState != BluetoothProfile.STATE_CONNECTED ||
+                    getAudioState(device) == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
+                    return false;
+                }
+                return mBtHandsfree.terminateScoUsingVirtualVoiceCall();
+            }
+        }
+
+        public boolean rejectIncomingConnect(BluetoothDevice device) {
+            synchronized (BluetoothHeadsetService.this) {
+                BluetoothRemoteHeadset headset = mRemoteHeadsets.get(device);
+                if (headset != null) {
+                    IncomingConnectionInfo info = headset.mIncomingInfo;
+                    rejectIncomingConnection(info);
+                } else {
+                    Log.e(TAG, "Error no record of remote headset");
+                }
+                return true;
+            }
+        }
+
+        public boolean acceptIncomingConnect(BluetoothDevice device) {
+            synchronized (BluetoothHeadsetService.this) {
+                HeadsetBase headset;
+                BluetoothRemoteHeadset cachedHeadset = mRemoteHeadsets.get(device);
+                if (cachedHeadset == null) {
+                    Log.e(TAG, "Cached Headset is Null in acceptIncomingConnect");
+                    return false;
+                }
+                IncomingConnectionInfo info = cachedHeadset.mIncomingInfo;
+                headset = new HeadsetBase(mPowerManager, mAdapter,
+                                          device,
+                                          info.mSocketFd, info.mRfcommChan,
+                                          mConnectedStatusHandler);
+
+                setState(device, BluetoothProfile.STATE_CONNECTED);
+
+                cachedHeadset.mHeadset = headset;
+                mBtHandsfree.connectHeadset(headset, cachedHeadset.mHeadsetType);
+
+                if (DBG) log("Successfully used incoming connection");
+                return true;
+            }
+        }
+
+        public  boolean cancelConnectThread() {
+            synchronized (BluetoothHeadsetService.this) {
+                if (mConnectThread != null) {
+                    // cancel the connection thread
+                    mConnectThread.interrupt();
+                    try {
+                        mConnectThread.join();
+                    } catch (InterruptedException e) {
+                        Log.e(TAG, "Connection cancelled twice?", e);
+                    }
+                    mConnectThread = null;
+                }
+                return true;
+            }
+        }
+
+        public boolean connectHeadsetInternal(BluetoothDevice device) {
+            synchronized (BluetoothHeadsetService.this) {
+                BluetoothDevice currDevice = getCurrentDevice();
+                if (currDevice == null) {
+                    BluetoothRemoteHeadset headset = new BluetoothRemoteHeadset();
+                    mRemoteHeadsets.put(device, headset);
+
+                    setState(device, BluetoothProfile.STATE_CONNECTING);
+                    if (device.getUuids() == null) {
+                        // We might not have got the UUID change notification from
+                        // Bluez yet, if we have just paired. Try after 1.5 secs.
+                        Message msg = new Message();
+                        msg.what = CONNECT_HEADSET_DELAYED;
+                        msg.obj = device;
+                        mHandler.sendMessageDelayed(msg, 1500);
+                    } else {
+                        getSdpRecordsAndConnect(device);
+                    }
+                    return true;
+                } else {
+                      Log.w(TAG, "connectHeadset(" + device + "): failed: already in state " +
+                            mRemoteHeadsets.get(currDevice).mState +
+                            " with headset " + currDevice);
+                }
+                return false;
+            }
+        }
+
+        public boolean disconnectHeadsetInternal(BluetoothDevice device) {
+            synchronized (BluetoothHeadsetService.this) {
+                BluetoothRemoteHeadset remoteHeadset = mRemoteHeadsets.get(device);
+                if (remoteHeadset == null) return false;
+
+                if (remoteHeadset.mState == BluetoothProfile.STATE_CONNECTED) {
+                    // Send a dummy battery level message to force headset
+                    // out of sniff mode so that it will immediately notice
+                    // the disconnection. We are currently sending it for
+                    // handsfree only.
+                    // TODO: Call hci_conn_enter_active_mode() from
+                    // rfcomm_send_disc() in the kernel instead.
+                    // See http://b/1716887
+                    setState(device, BluetoothProfile.STATE_DISCONNECTING);
+
+                    HeadsetBase headset = remoteHeadset.mHeadset;
+                    if (remoteHeadset.mHeadsetType == BluetoothHandsfree.TYPE_HANDSFREE) {
+                        headset.sendURC("+CIEV: 7,3");
+                    }
+
+                    if (headset != null) {
+                        headset.disconnect();
+                        headset = null;
+                    }
+                    setState(device, BluetoothProfile.STATE_DISCONNECTED);
+                    return true;
+                } else if (remoteHeadset.mState == BluetoothProfile.STATE_CONNECTING) {
+                    // The state machine would have canceled the connect thread.
+                    // Just set the state here.
+                    setState(device, BluetoothProfile.STATE_DISCONNECTED);
+                    return true;
+                }
+                return false;
+            }
+        }
+
+        public boolean setAudioState(BluetoothDevice device, int state) {
+            // mRemoteHeadsets handles put/get concurrency by itself
+            int prevState = mRemoteHeadsets.get(device).mAudioState;
+            mRemoteHeadsets.get(device).mAudioState = state;
+            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
+                mAudioConnectedDevice = device;
+            } else if (state == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
+                mAudioConnectedDevice = null;
+            }
+            Intent intent = new Intent(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
+            intent.putExtra(BluetoothHeadset.EXTRA_STATE, state);
+            intent.putExtra(BluetoothHeadset.EXTRA_PREVIOUS_STATE, prevState);
+            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+            sendBroadcast(intent, android.Manifest.permission.BLUETOOTH);
+            if (DBG) log("AudioStateIntent: " + device + " State: " + state
+                         + " PrevState: " + prevState);
+            return true;
+        }
+
+	public int getAudioState(BluetoothDevice device) {
+            // mRemoteHeadsets handles put/get concurrency by itself
+            BluetoothRemoteHeadset headset = mRemoteHeadsets.get(device);
+            if (headset == null) return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
+
+            return headset.mAudioState;
+	}
+    };
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        if (DBG) log("Stopping BluetoothHeadsetService");
+        unregisterReceiver(mBluetoothReceiver);
+        mBtHandsfree.onBluetoothDisabled();
+        mAg.stop();
+        sHasStarted = false;
+        BluetoothDevice device = getCurrentDevice();
+        if (device != null) {
+            setState(device, BluetoothProfile.STATE_DISCONNECTED);
+        }
+    }
+
+
+
+    private static void log(String msg) {
+        Log.d(TAG, msg);
+    }
+}
diff --git a/src/com/android/phone/BluetoothPhoneService.java b/src/com/android/phone/BluetoothPhoneService.java
deleted file mode 100755
index e2f48fd..0000000
--- a/src/com/android/phone/BluetoothPhoneService.java
+++ /dev/null
@@ -1,931 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.phone;
-
-import android.app.Service;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothHeadset;
-import android.bluetooth.BluetoothProfile;
-import android.bluetooth.IBluetoothHeadsetPhone;
-import android.content.Context;
-import android.content.Intent;
-import android.os.AsyncResult;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Message;
-import android.os.PowerManager;
-import android.os.PowerManager.WakeLock;
-import android.os.SystemProperties;
-import android.telephony.PhoneNumberUtils;
-import android.telephony.ServiceState;
-import android.util.Log;
-
-import com.android.internal.telephony.Call;
-import com.android.internal.telephony.Connection;
-import com.android.internal.telephony.Phone;
-import com.android.internal.telephony.PhoneConstants;
-import com.android.internal.telephony.TelephonyIntents;
-import com.android.internal.telephony.CallManager;
-
-import java.io.IOException;
-import java.util.LinkedList;
-import java.util.List;
-
-/**
- * Bluetooth headset manager for the Phone app.
- * @hide
- */
-public class BluetoothPhoneService extends Service {
-    private static final String TAG = "BluetoothPhoneService";
-    private static final boolean DBG = (PhoneGlobals.DBG_LEVEL >= 1)
-            && (SystemProperties.getInt("ro.debuggable", 0) == 1);
-    private static final boolean VDBG = (PhoneGlobals.DBG_LEVEL >= 2);  // even more logging
-
-    private static final String MODIFY_PHONE_STATE = android.Manifest.permission.MODIFY_PHONE_STATE;
-
-    private BluetoothAdapter mAdapter;
-    private CallManager mCM;
-
-    private BluetoothHeadset mBluetoothHeadset;
-
-    private PowerManager mPowerManager;
-
-    private WakeLock mStartCallWakeLock;  // held while waiting for the intent to start call
-
-    private PhoneConstants.State mPhoneState = PhoneConstants.State.IDLE;
-    CdmaPhoneCallState.PhoneCallState mCdmaThreeWayCallState =
-                                            CdmaPhoneCallState.PhoneCallState.IDLE;
-
-    private Call.State mForegroundCallState;
-    private Call.State mRingingCallState;
-    private CallNumber mRingNumber;
-    // number of active calls
-    int mNumActive;
-    // number of background (held) calls
-    int mNumHeld;
-
-    long mBgndEarliestConnectionTime = 0;
-
-    private boolean mRoam = false;
-
-    // CDMA specific flag used in context with BT devices having display capabilities
-    // to show which Caller is active. This state might not be always true as in CDMA
-    // networks if a caller drops off no update is provided to the Phone.
-    // This flag is just used as a toggle to provide a update to the BT device to specify
-    // which caller is active.
-    private boolean mCdmaIsSecondCallActive = false;
-    private boolean mCdmaCallsSwapped = false;
-
-    private long[] mClccTimestamps; // Timestamps associated with each clcc index
-    private boolean[] mClccUsed;     // Is this clcc index in use
-
-    private static final int GSM_MAX_CONNECTIONS = 6;  // Max connections allowed by GSM
-    private static final int CDMA_MAX_CONNECTIONS = 2;  // Max connections allowed by CDMA
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        mCM = CallManager.getInstance();
-        mAdapter = BluetoothAdapter.getDefaultAdapter();
-        if (mAdapter == null) {
-            if (VDBG) Log.d(TAG, "mAdapter null");
-            return;
-        }
-
-        mPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
-        mStartCallWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
-                                                       TAG + ":StartCall");
-        mStartCallWakeLock.setReferenceCounted(false);
-
-        mAdapter.getProfileProxy(this, mProfileListener, BluetoothProfile.HEADSET);
-
-        mForegroundCallState = Call.State.IDLE;
-        mRingingCallState = Call.State.IDLE;
-        mNumActive = 0;
-        mNumHeld = 0;
-        mRingNumber = new CallNumber("", 0);;
-        mRoam = false;
-
-        updateServiceState(mCM.getDefaultPhone().getServiceState());
-        handlePreciseCallStateChange(null);
-
-        if(VDBG) Log.d(TAG, "registerForServiceStateChanged");
-        // register for updates
-        // Use the service state of default phone as BT service state to
-        // avoid situation such as no cell or wifi connection but still
-        // reporting in service (since SipPhone always reports in service).
-        mCM.getDefaultPhone().registerForServiceStateChanged(mHandler,
-                                                             SERVICE_STATE_CHANGED, null);
-        mCM.registerForPreciseCallStateChanged(mHandler,
-                                               PRECISE_CALL_STATE_CHANGED, null);
-        mCM.registerForCallWaiting(mHandler,
-                                   PHONE_CDMA_CALL_WAITING, null);
-        // TODO(BT) registerForIncomingRing?
-        // TODO(BT) registerdisconnection?
-        mClccTimestamps = new long[GSM_MAX_CONNECTIONS];
-        mClccUsed = new boolean[GSM_MAX_CONNECTIONS];
-        for (int i = 0; i < GSM_MAX_CONNECTIONS; i++) {
-            mClccUsed[i] = false;
-        }
-    }
-
-    @Override
-    public void onStart(Intent intent, int startId) {
-        if (mAdapter == null) {
-            Log.w(TAG, "Stopping Bluetooth BluetoothPhoneService Service: device does not have BT");
-            stopSelf();
-        }
-        if (VDBG) Log.d(TAG, "BluetoothPhoneService started");
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        if (DBG) log("Stopping Bluetooth BluetoothPhoneService Service");
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return mBinder;
-    }
-
-    private static final int SERVICE_STATE_CHANGED = 1;
-    private static final int PRECISE_CALL_STATE_CHANGED = 2;
-    private static final int PHONE_CDMA_CALL_WAITING = 3;
-    private static final int LIST_CURRENT_CALLS = 4;
-    private static final int QUERY_PHONE_STATE = 5;
-    private static final int CDMA_SWAP_SECOND_CALL_STATE = 6;
-    private static final int CDMA_SET_SECOND_CALL_STATE = 7;
-
-    private Handler mHandler = new Handler() {
-        @Override
-        public void handleMessage(Message msg) {
-            if (VDBG) Log.d(TAG, "handleMessage: " + msg.what);
-            switch(msg.what) {
-                case SERVICE_STATE_CHANGED:
-                    ServiceState state = (ServiceState) ((AsyncResult) msg.obj).result;
-                    updateServiceState(state);
-                    break;
-                case PRECISE_CALL_STATE_CHANGED:
-                case PHONE_CDMA_CALL_WAITING:
-                    Connection connection = null;
-                    if (((AsyncResult) msg.obj).result instanceof Connection) {
-                        connection = (Connection) ((AsyncResult) msg.obj).result;
-                    }
-                    handlePreciseCallStateChange(connection);
-                    break;
-                case LIST_CURRENT_CALLS:
-                    handleListCurrentCalls();
-                    break;
-                case QUERY_PHONE_STATE:
-                    handleQueryPhoneState();
-                    break;
-                case CDMA_SWAP_SECOND_CALL_STATE:
-                    handleCdmaSwapSecondCallState();
-                    break;
-                case CDMA_SET_SECOND_CALL_STATE:
-                    handleCdmaSetSecondCallState((Boolean) msg.obj);
-                    break;
-            }
-        }
-    };
-
-    private void updateBtPhoneStateAfterRadioTechnologyChange() {
-        if(VDBG) Log.d(TAG, "updateBtPhoneStateAfterRadioTechnologyChange...");
-
-        //Unregister all events from the old obsolete phone
-        mCM.getDefaultPhone().unregisterForServiceStateChanged(mHandler);
-        mCM.unregisterForPreciseCallStateChanged(mHandler);
-        mCM.unregisterForCallWaiting(mHandler);
-
-        //Register all events new to the new active phone
-        mCM.getDefaultPhone().registerForServiceStateChanged(mHandler,
-                                                             SERVICE_STATE_CHANGED, null);
-        mCM.registerForPreciseCallStateChanged(mHandler,
-                                               PRECISE_CALL_STATE_CHANGED, null);
-        mCM.registerForCallWaiting(mHandler,
-                                   PHONE_CDMA_CALL_WAITING, null);
-    }
-
-    private void updateServiceState(ServiceState state) {
-        boolean roam = state.getRoaming();
-
-        if (roam != mRoam) {
-            mRoam = roam;
-            if (mBluetoothHeadset != null) {
-                mBluetoothHeadset.roamChanged(roam);
-            }
-        }
-    }
-
-    private void handlePreciseCallStateChange(Connection connection) {
-        // get foreground call state
-        int oldNumActive = mNumActive;
-        int oldNumHeld = mNumHeld;
-        Call.State oldRingingCallState = mRingingCallState;
-        Call.State oldForegroundCallState = mForegroundCallState;
-        CallNumber oldRingNumber = mRingNumber;
-
-        Call foregroundCall = mCM.getActiveFgCall();
-
-        if (VDBG)
-            Log.d(TAG, " handlePreciseCallStateChange: foreground: " + foregroundCall +
-                " background: " + mCM.getFirstActiveBgCall() + " ringing: " +
-                mCM.getFirstActiveRingingCall());
-
-        mForegroundCallState = foregroundCall.getState();
-        /* if in transition, do not update */
-        if (mForegroundCallState == Call.State.DISCONNECTING)
-        {
-            Log.d(TAG, "handlePreciseCallStateChange. Call disconnecting, wait before update");
-            return;
-        }
-        else
-            mNumActive = (mForegroundCallState == Call.State.ACTIVE) ? 1 : 0;
-
-        Call ringingCall = mCM.getFirstActiveRingingCall();
-        mRingingCallState = ringingCall.getState();
-        mRingNumber = getCallNumber(connection, ringingCall);
-
-        if (mCM.getDefaultPhone().getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
-            mNumHeld = getNumHeldCdma();
-            PhoneGlobals app = PhoneGlobals.getInstance();
-            if (app.cdmaPhoneCallState != null) {
-                CdmaPhoneCallState.PhoneCallState currCdmaThreeWayCallState =
-                        app.cdmaPhoneCallState.getCurrentCallState();
-                CdmaPhoneCallState.PhoneCallState prevCdmaThreeWayCallState =
-                    app.cdmaPhoneCallState.getPreviousCallState();
-
-                log("CDMA call state: " + currCdmaThreeWayCallState + " prev state:" +
-                    prevCdmaThreeWayCallState);
-
-                if ((mBluetoothHeadset != null) &&
-                    (mCdmaThreeWayCallState != currCdmaThreeWayCallState)) {
-                    // In CDMA, the network does not provide any feedback
-                    // to the phone when the 2nd MO call goes through the
-                    // stages of DIALING > ALERTING -> ACTIVE we fake the
-                    // sequence
-                    log("CDMA 3way call state change. mNumActive: " + mNumActive +
-                        " mNumHeld: " + mNumHeld + " IsThreeWayCallOrigStateDialing: " +
-                        app.cdmaPhoneCallState.IsThreeWayCallOrigStateDialing());
-                    if ((currCdmaThreeWayCallState ==
-                            CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE)
-                                && app.cdmaPhoneCallState.IsThreeWayCallOrigStateDialing()) {
-                        // Mimic dialing, put the call on hold, alerting
-                        mBluetoothHeadset.phoneStateChanged(0, mNumHeld,
-                            convertCallState(Call.State.IDLE, Call.State.DIALING),
-                            mRingNumber.mNumber, mRingNumber.mType);
-
-                        mBluetoothHeadset.phoneStateChanged(0, mNumHeld,
-                            convertCallState(Call.State.IDLE, Call.State.ALERTING),
-                            mRingNumber.mNumber, mRingNumber.mType);
-
-                    }
-
-                    // In CDMA, the network does not provide any feedback to
-                    // the phone when a user merges a 3way call or swaps
-                    // between two calls we need to send a CIEV response
-                    // indicating that a call state got changed which should
-                    // trigger a CLCC update request from the BT client.
-                    if (currCdmaThreeWayCallState ==
-                            CdmaPhoneCallState.PhoneCallState.CONF_CALL &&
-                            prevCdmaThreeWayCallState ==
-                              CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
-                        log("CDMA 3way conf call. mNumActive: " + mNumActive +
-                            " mNumHeld: " + mNumHeld);
-                        mBluetoothHeadset.phoneStateChanged(mNumActive, mNumHeld,
-                            convertCallState(Call.State.IDLE, mForegroundCallState),
-                            mRingNumber.mNumber, mRingNumber.mType);
-                    }
-                }
-                mCdmaThreeWayCallState = currCdmaThreeWayCallState;
-            }
-        } else {
-            mNumHeld = getNumHeldUmts();
-        }
-
-        boolean callsSwitched = false;
-        if (mCM.getDefaultPhone().getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA &&
-            mCdmaThreeWayCallState == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
-            callsSwitched = mCdmaCallsSwapped;
-        } else {
-            Call backgroundCall = mCM.getFirstActiveBgCall();
-            callsSwitched =
-                (mNumHeld == 1 && ! (backgroundCall.getEarliestConnectTime() ==
-                    mBgndEarliestConnectionTime));
-            mBgndEarliestConnectionTime = backgroundCall.getEarliestConnectTime();
-        }
-
-        if (mNumActive != oldNumActive || mNumHeld != oldNumHeld ||
-            mRingingCallState != oldRingingCallState ||
-            mForegroundCallState != oldForegroundCallState ||
-            !mRingNumber.equalTo(oldRingNumber) ||
-            callsSwitched) {
-            if (mBluetoothHeadset != null) {
-                mBluetoothHeadset.phoneStateChanged(mNumActive, mNumHeld,
-                    convertCallState(mRingingCallState, mForegroundCallState),
-                    mRingNumber.mNumber, mRingNumber.mType);
-            }
-        }
-    }
-
-    private void handleListCurrentCalls() {
-        Phone phone = mCM.getDefaultPhone();
-        int phoneType = phone.getPhoneType();
-
-        // TODO(BT) handle virtual call
-
-        if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
-            listCurrentCallsCdma();
-        } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
-            listCurrentCallsGsm();
-        } else {
-            Log.e(TAG, "Unexpected phone type: " + phoneType);
-        }
-        // end the result
-        // when index is 0, other parameter does not matter
-        mBluetoothHeadset.clccResponse(0, 0, 0, 0, false, "", 0);
-    }
-
-    private void handleQueryPhoneState() {
-        if (mBluetoothHeadset != null) {
-            mBluetoothHeadset.phoneStateChanged(mNumActive, mNumHeld,
-                convertCallState(mRingingCallState, mForegroundCallState),
-                mRingNumber.mNumber, mRingNumber.mType);
-        }
-    }
-
-    private int getNumHeldUmts() {
-        int countHeld = 0;
-        List<Call> heldCalls = mCM.getBackgroundCalls();
-
-        for (Call call : heldCalls) {
-            if (call.getState() == Call.State.HOLDING) {
-                countHeld++;
-            }
-        }
-        return countHeld;
-    }
-
-    private int getNumHeldCdma() {
-        int numHeld = 0;
-        PhoneGlobals app = PhoneGlobals.getInstance();
-        if (app.cdmaPhoneCallState != null) {
-            CdmaPhoneCallState.PhoneCallState curr3WayCallState =
-                app.cdmaPhoneCallState.getCurrentCallState();
-            CdmaPhoneCallState.PhoneCallState prev3WayCallState =
-                app.cdmaPhoneCallState.getPreviousCallState();
-
-            log("CDMA call state: " + curr3WayCallState + " prev state:" +
-                prev3WayCallState);
-            if (curr3WayCallState == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
-                if (prev3WayCallState == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
-                    numHeld = 0; //0: no calls held, as now *both* the caller are active
-                } else {
-                    numHeld = 1; //1: held call and active call, as on answering a
-                    // Call Waiting, one of the caller *is* put on hold
-                }
-            } else if (curr3WayCallState == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
-                numHeld = 1; //1: held call and active call, as on make a 3 Way Call
-                // the first caller *is* put on hold
-            } else {
-                numHeld = 0; //0: no calls held as this is a SINGLE_ACTIVE call
-            }
-        }
-        return numHeld;
-    }
-
-    private CallNumber getCallNumber(Connection connection, Call call) {
-        String number = null;
-        int type = 128;
-        // find phone number and type
-        if (connection == null) {
-            connection = call.getEarliestConnection();
-            if (connection == null) {
-                Log.e(TAG, "Could not get a handle on Connection object for the call");
-            }
-        }
-        if (connection != null) {
-            number = connection.getAddress();
-            if (number != null) {
-                type = PhoneNumberUtils.toaFromString(number);
-            }
-        }
-        if (number == null) {
-            number = "";
-        }
-        return new CallNumber(number, type);
-    }
-
-    private class CallNumber
-    {
-        private String mNumber = null;
-        private int mType = 0;
-
-        private CallNumber(String number, int type) {
-            mNumber = number;
-            mType = type;
-        }
-
-        private boolean equalTo(CallNumber callNumber) 
-        {
-            if (mType != callNumber.mType) return false;
-            
-            if (mNumber != null && mNumber.compareTo(callNumber.mNumber) == 0) {
-                return true;
-            }
-            return false;
-        }
-    }
-
-    private BluetoothProfile.ServiceListener mProfileListener =
-            new BluetoothProfile.ServiceListener() {
-        public void onServiceConnected(int profile, BluetoothProfile proxy) {
-            mBluetoothHeadset = (BluetoothHeadset) proxy;
-        }
-        public void onServiceDisconnected(int profile) {
-            mBluetoothHeadset = null;
-        }
-    };
-
-    private void listCurrentCallsGsm() {
-        // Collect all known connections
-        // clccConnections isindexed by CLCC index
-        Connection[] clccConnections = new Connection[GSM_MAX_CONNECTIONS];
-        LinkedList<Connection> newConnections = new LinkedList<Connection>();
-        LinkedList<Connection> connections = new LinkedList<Connection>();
-
-        Call foregroundCall = mCM.getActiveFgCall();
-        Call backgroundCall = mCM.getFirstActiveBgCall();
-        Call ringingCall = mCM.getFirstActiveRingingCall();
-
-        if (ringingCall.getState().isAlive()) {
-            connections.addAll(ringingCall.getConnections());
-        }
-        if (foregroundCall.getState().isAlive()) {
-            connections.addAll(foregroundCall.getConnections());
-        }
-        if (backgroundCall.getState().isAlive()) {
-            connections.addAll(backgroundCall.getConnections());
-        }
-
-        // Mark connections that we already known about
-        boolean clccUsed[] = new boolean[GSM_MAX_CONNECTIONS];
-        for (int i = 0; i < GSM_MAX_CONNECTIONS; i++) {
-            clccUsed[i] = mClccUsed[i];
-            mClccUsed[i] = false;
-        }
-        for (Connection c : connections) {
-            boolean found = false;
-            long timestamp = c.getCreateTime();
-            for (int i = 0; i < GSM_MAX_CONNECTIONS; i++) {
-                if (clccUsed[i] && timestamp == mClccTimestamps[i]) {
-                    mClccUsed[i] = true;
-                    found = true;
-                    clccConnections[i] = c;
-                    break;
-                }
-            }
-            if (!found) {
-                newConnections.add(c);
-            }
-        }
-
-        // Find a CLCC index for new connections
-        while (!newConnections.isEmpty()) {
-            // Find lowest empty index
-            int i = 0;
-            while (mClccUsed[i]) i++;
-            // Find earliest connection
-            long earliestTimestamp = newConnections.get(0).getCreateTime();
-            Connection earliestConnection = newConnections.get(0);
-            for (int j = 0; j < newConnections.size(); j++) {
-                long timestamp = newConnections.get(j).getCreateTime();
-                if (timestamp < earliestTimestamp) {
-                    earliestTimestamp = timestamp;
-                    earliestConnection = newConnections.get(j);
-                }
-            }
-
-            // update
-            mClccUsed[i] = true;
-            mClccTimestamps[i] = earliestTimestamp;
-            clccConnections[i] = earliestConnection;
-            newConnections.remove(earliestConnection);
-        }
-
-        // Send CLCC response to Bluetooth headset service
-        for (int i = 0; i < clccConnections.length; i++) {
-            if (mClccUsed[i]) {
-                sendClccResponseGsm(i, clccConnections[i]);
-            }
-        }
-    }
-
-    /** Convert a Connection object into a single +CLCC result */
-    private void sendClccResponseGsm(int index, Connection connection) {
-        int state = convertCallState(connection.getState());
-        boolean mpty = false;
-        Call call = connection.getCall();
-        if (call != null) {
-            mpty = call.isMultiparty();
-        }
-
-        int direction = connection.isIncoming() ? 1 : 0;
-
-        String number = connection.getAddress();
-        int type = -1;
-        if (number != null) {
-            type = PhoneNumberUtils.toaFromString(number);
-        }
-
-        mBluetoothHeadset.clccResponse(index + 1, direction, state, 0, mpty, number, type);
-    }
-
-    /** Build the +CLCC result for CDMA
-     *  The complexity arises from the fact that we need to maintain the same
-     *  CLCC index even as a call moves between states. */
-    private synchronized void listCurrentCallsCdma() {
-        // In CDMA at one time a user can have only two live/active connections
-        Connection[] clccConnections = new Connection[CDMA_MAX_CONNECTIONS];// indexed by CLCC index
-        Call foregroundCall = mCM.getActiveFgCall();
-        Call ringingCall = mCM.getFirstActiveRingingCall();
-
-        Call.State ringingCallState = ringingCall.getState();
-        // If the Ringing Call state is INCOMING, that means this is the very first call
-        // hence there should not be any Foreground Call
-        if (ringingCallState == Call.State.INCOMING) {
-            if (VDBG) log("Filling clccConnections[0] for INCOMING state");
-            clccConnections[0] = ringingCall.getLatestConnection();
-        } else if (foregroundCall.getState().isAlive()) {
-            // Getting Foreground Call connection based on Call state
-            if (ringingCall.isRinging()) {
-                if (VDBG) log("Filling clccConnections[0] & [1] for CALL WAITING state");
-                clccConnections[0] = foregroundCall.getEarliestConnection();
-                clccConnections[1] = ringingCall.getLatestConnection();
-            } else {
-                if (foregroundCall.getConnections().size() <= 1) {
-                    // Single call scenario
-                    if (VDBG) {
-                        log("Filling clccConnections[0] with ForgroundCall latest connection");
-                    }
-                    clccConnections[0] = foregroundCall.getLatestConnection();
-                } else {
-                    // Multiple Call scenario. This would be true for both
-                    // CONF_CALL and THRWAY_ACTIVE state
-                    if (VDBG) {
-                        log("Filling clccConnections[0] & [1] with ForgroundCall connections");
-                    }
-                    clccConnections[0] = foregroundCall.getEarliestConnection();
-                    clccConnections[1] = foregroundCall.getLatestConnection();
-                }
-            }
-        }
-
-        // Update the mCdmaIsSecondCallActive flag based on the Phone call state
-        if (PhoneGlobals.getInstance().cdmaPhoneCallState.getCurrentCallState()
-                == CdmaPhoneCallState.PhoneCallState.SINGLE_ACTIVE) {
-            Message msg = mHandler.obtainMessage(CDMA_SET_SECOND_CALL_STATE, false);
-            mHandler.sendMessage(msg);
-        } else if (PhoneGlobals.getInstance().cdmaPhoneCallState.getCurrentCallState()
-                == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
-            Message msg = mHandler.obtainMessage(CDMA_SET_SECOND_CALL_STATE, true);
-            mHandler.sendMessage(msg);
-        }
-
-        // send CLCC result
-        for (int i = 0; (i < clccConnections.length) && (clccConnections[i] != null); i++) {
-            sendClccResponseCdma(i, clccConnections[i]);
-        }
-    }
-
-    /** Send ClCC results for a Connection object for CDMA phone */
-    private void sendClccResponseCdma(int index, Connection connection) {
-        int state;
-        PhoneGlobals app = PhoneGlobals.getInstance();
-        CdmaPhoneCallState.PhoneCallState currCdmaCallState =
-                app.cdmaPhoneCallState.getCurrentCallState();
-        CdmaPhoneCallState.PhoneCallState prevCdmaCallState =
-                app.cdmaPhoneCallState.getPreviousCallState();
-
-        if ((prevCdmaCallState == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE)
-                && (currCdmaCallState == CdmaPhoneCallState.PhoneCallState.CONF_CALL)) {
-            // If the current state is reached after merging two calls
-            // we set the state of all the connections as ACTIVE
-            state = CALL_STATE_ACTIVE;
-        } else {
-            Call.State callState = connection.getState();
-            switch (callState) {
-            case ACTIVE:
-                // For CDMA since both the connections are set as active by FW after accepting
-                // a Call waiting or making a 3 way call, we need to set the state specifically
-                // to ACTIVE/HOLDING based on the mCdmaIsSecondCallActive flag. This way the
-                // CLCC result will allow BT devices to enable the swap or merge options
-                if (index == 0) { // For the 1st active connection
-                    state = mCdmaIsSecondCallActive ? CALL_STATE_HELD : CALL_STATE_ACTIVE;
-                } else { // for the 2nd active connection
-                    state = mCdmaIsSecondCallActive ? CALL_STATE_ACTIVE : CALL_STATE_HELD;
-                }
-                break;
-            case HOLDING:
-                state = CALL_STATE_HELD;
-                break;
-            case DIALING:
-                state = CALL_STATE_DIALING;
-                break;
-            case ALERTING:
-                state = CALL_STATE_ALERTING;
-                break;
-            case INCOMING:
-                state = CALL_STATE_INCOMING;
-                break;
-            case WAITING:
-                state = CALL_STATE_WAITING;
-                break;
-            default:
-                Log.e(TAG, "bad call state: " + callState);
-                return;
-            }
-        }
-
-        boolean mpty = false;
-        if (currCdmaCallState == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
-            if (prevCdmaCallState == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
-                // If the current state is reached after merging two calls
-                // we set the multiparty call true.
-                mpty = true;
-            } // else
-                // CALL_CONF state is not from merging two calls, but from
-                // accepting the second call. In this case first will be on
-                // hold in most cases but in some cases its already merged.
-                // However, we will follow the common case and the test case
-                // as per Bluetooth SIG PTS
-        }
-
-        int direction = connection.isIncoming() ? 1 : 0;
-
-        String number = connection.getAddress();
-        int type = -1;
-        if (number != null) {
-            type = PhoneNumberUtils.toaFromString(number);
-        } else {
-            number = "";
-        }
-
-        mBluetoothHeadset.clccResponse(index + 1, direction, state, 0, mpty, number, type);
-    }
-
-    private void handleCdmaSwapSecondCallState() {
-        if (VDBG) log("cdmaSwapSecondCallState: Toggling mCdmaIsSecondCallActive");
-        mCdmaIsSecondCallActive = !mCdmaIsSecondCallActive;
-        mCdmaCallsSwapped = true;
-    }
-
-    private void handleCdmaSetSecondCallState(boolean state) {
-        if (VDBG) log("cdmaSetSecondCallState: Setting mCdmaIsSecondCallActive to " + state);
-        mCdmaIsSecondCallActive = state;
-
-        if (!mCdmaIsSecondCallActive) {
-            mCdmaCallsSwapped = false;
-        }
-    }
-
-    private final IBluetoothHeadsetPhone.Stub mBinder = new IBluetoothHeadsetPhone.Stub() {
-        public boolean answerCall() {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            return PhoneUtils.answerCall(mCM.getFirstActiveRingingCall());
-        }
-
-        public boolean hangupCall() {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            if (mCM.hasActiveFgCall()) {
-                return PhoneUtils.hangupActiveCall(mCM.getActiveFgCall());
-            } else if (mCM.hasActiveRingingCall()) {
-                return PhoneUtils.hangupRingingCall(mCM.getFirstActiveRingingCall());
-            } else if (mCM.hasActiveBgCall()) {
-                return PhoneUtils.hangupHoldingCall(mCM.getFirstActiveBgCall());
-            }
-            // TODO(BT) handle virtual voice call
-            return false;
-        }
-
-        public boolean sendDtmf(int dtmf) {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            return mCM.sendDtmf((char) dtmf);
-        }
-
-        public boolean processChld(int chld) {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            Phone phone = mCM.getDefaultPhone();
-            int phoneType = phone.getPhoneType();
-            Call ringingCall = mCM.getFirstActiveRingingCall();
-            Call backgroundCall = mCM.getFirstActiveBgCall();
-
-            if (chld == CHLD_TYPE_RELEASEHELD) {
-                if (ringingCall.isRinging()) {
-                    return PhoneUtils.hangupRingingCall(ringingCall);
-                } else {
-                    return PhoneUtils.hangupHoldingCall(backgroundCall);
-                }
-            } else if (chld == CHLD_TYPE_RELEASEACTIVE_ACCEPTHELD) {
-                if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
-                    if (ringingCall.isRinging()) {
-                        // Hangup the active call and then answer call waiting call.
-                        if (VDBG) log("CHLD:1 Callwaiting Answer call");
-                        PhoneUtils.hangupRingingAndActive(phone);
-                    } else {
-                        // If there is no Call waiting then just hangup
-                        // the active call. In CDMA this mean that the complete
-                        // call session would be ended
-                        if (VDBG) log("CHLD:1 Hangup Call");
-                        PhoneUtils.hangup(PhoneGlobals.getInstance().mCM);
-                    }
-                    return true;
-                } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
-                    // Hangup active call, answer held call
-                    return PhoneUtils.answerAndEndActive(PhoneGlobals.getInstance().mCM, ringingCall);
-                } else {
-                    Log.e(TAG, "bad phone type: " + phoneType);
-                    return false;
-                }
-            } else if (chld == CHLD_TYPE_HOLDACTIVE_ACCEPTHELD) {
-                if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
-                    // For CDMA, the way we switch to a new incoming call is by
-                    // calling PhoneUtils.answerCall(). switchAndHoldActive() won't
-                    // properly update the call state within telephony.
-                    // If the Phone state is already in CONF_CALL then we simply send
-                    // a flash cmd by calling switchHoldingAndActive()
-                    if (ringingCall.isRinging()) {
-                        if (VDBG) log("CHLD:2 Callwaiting Answer call");
-                        PhoneUtils.answerCall(ringingCall);
-                        PhoneUtils.setMute(false);
-                        // Setting the second callers state flag to TRUE (i.e. active)
-                        cdmaSetSecondCallState(true);
-                        return true;
-                    } else if (PhoneGlobals.getInstance().cdmaPhoneCallState
-                               .getCurrentCallState()
-                               == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
-                        if (VDBG) log("CHLD:2 Swap Calls");
-                        PhoneUtils.switchHoldingAndActive(backgroundCall);
-                        // Toggle the second callers active state flag
-                        cdmaSwapSecondCallState();
-                        return true;
-                    }
-                    Log.e(TAG, "CDMA fail to do hold active and accept held");
-                    return false;
-                } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
-                    PhoneUtils.switchHoldingAndActive(backgroundCall);
-                    return true;
-                } else {
-                    Log.e(TAG, "Unexpected phone type: " + phoneType);
-                    return false;
-                }
-            } else if (chld == CHLD_TYPE_ADDHELDTOCONF) {
-                if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
-                    CdmaPhoneCallState.PhoneCallState state =
-                        PhoneGlobals.getInstance().cdmaPhoneCallState.getCurrentCallState();
-                    // For CDMA, we need to check if the call is in THRWAY_ACTIVE state
-                    if (state == CdmaPhoneCallState.PhoneCallState.THRWAY_ACTIVE) {
-                        if (VDBG) log("CHLD:3 Merge Calls");
-                        PhoneUtils.mergeCalls();
-                        return true;
-                    }   else if (state == CdmaPhoneCallState.PhoneCallState.CONF_CALL) {
-                        // State is CONF_CALL already and we are getting a merge call
-                        // This can happen when CONF_CALL was entered from a Call Waiting
-                        // TODO(BT)
-                        return false;
-                    }
-                    Log.e(TAG, "GSG no call to add conference");
-                    return false;
-                } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
-                    if (mCM.hasActiveFgCall() && mCM.hasActiveBgCall()) {
-                        PhoneUtils.mergeCalls();
-                        return true;
-                    } else {
-                        Log.e(TAG, "GSG no call to merge");
-                        return false;
-                    }
-                } else {
-                    Log.e(TAG, "Unexpected phone type: " + phoneType);
-                    return false;
-                }                
-            } else {
-                Log.e(TAG, "bad CHLD value: " + chld);
-                return false;
-            }
-        }
-
-        public String getNetworkOperator() {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            return mCM.getDefaultPhone().getServiceState().getOperatorAlphaLong();
-        }
-
-        public String getSubscriberNumber() {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            return mCM.getDefaultPhone().getLine1Number();
-        }
-
-        public boolean listCurrentCalls() {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            Message msg = Message.obtain(mHandler, LIST_CURRENT_CALLS);
-            mHandler.sendMessage(msg);
-            return true;
-        }
-
-        public boolean queryPhoneState() {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            Message msg = Message.obtain(mHandler, QUERY_PHONE_STATE);
-            mHandler.sendMessage(msg);
-            return true;
-        }
-
-        public void updateBtHandsfreeAfterRadioTechnologyChange() {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            if (VDBG) Log.d(TAG, "updateBtHandsfreeAfterRadioTechnologyChange...");
-            updateBtPhoneStateAfterRadioTechnologyChange();
-        }
-
-        public void cdmaSwapSecondCallState() {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            Message msg = Message.obtain(mHandler, CDMA_SWAP_SECOND_CALL_STATE);
-            mHandler.sendMessage(msg);
-        }
-
-        public void cdmaSetSecondCallState(boolean state) {
-            enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
-            Message msg = mHandler.obtainMessage(CDMA_SET_SECOND_CALL_STATE, state);
-            mHandler.sendMessage(msg);
-        }
-    };
-
-    // match up with bthf_call_state_t of bt_hf.h
-    final static int CALL_STATE_ACTIVE = 0;
-    final static int CALL_STATE_HELD = 1;
-    final static int CALL_STATE_DIALING = 2;
-    final static int CALL_STATE_ALERTING = 3;
-    final static int CALL_STATE_INCOMING = 4;
-    final static int CALL_STATE_WAITING = 5;
-    final static int CALL_STATE_IDLE = 6;
-
-    // match up with bthf_chld_type_t of bt_hf.h
-    final static int CHLD_TYPE_RELEASEHELD = 0;
-    final static int CHLD_TYPE_RELEASEACTIVE_ACCEPTHELD = 1;
-    final static int CHLD_TYPE_HOLDACTIVE_ACCEPTHELD = 2;
-    final static int CHLD_TYPE_ADDHELDTOCONF = 3;
-
-     /* Convert telephony phone call state into hf hal call state */
-    static int convertCallState(Call.State ringingState, Call.State foregroundState) {
-        if ((ringingState == Call.State.INCOMING) ||
-            (ringingState == Call.State.WAITING) )
-            return CALL_STATE_INCOMING;
-        else if (foregroundState == Call.State.DIALING)
-            return CALL_STATE_DIALING;
-        else if (foregroundState == Call.State.ALERTING)
-            return CALL_STATE_ALERTING;
-        else
-            return CALL_STATE_IDLE;
-    }
-
-    static int convertCallState(Call.State callState) {
-        switch (callState) {
-        case IDLE:
-        case DISCONNECTED:
-        case DISCONNECTING:
-            return CALL_STATE_IDLE;
-        case ACTIVE:
-            return CALL_STATE_ACTIVE;
-        case HOLDING:
-            return CALL_STATE_HELD;
-        case DIALING:
-            return CALL_STATE_DIALING;
-        case ALERTING:
-            return CALL_STATE_ALERTING;
-        case INCOMING:
-            return CALL_STATE_INCOMING;
-        case WAITING:
-            return CALL_STATE_WAITING;
-        default:
-            Log.e(TAG, "bad call state: " + callState);
-            return CALL_STATE_IDLE;
-        }
-    }
-
-    private static void log(String msg) {
-        Log.d(TAG, msg);
-    }
-}
diff --git a/src/com/android/phone/BluetoothSMSAccess.java b/src/com/android/phone/BluetoothSMSAccess.java
new file mode 100644
index 0000000..d739ae2
--- /dev/null
+++ b/src/com/android/phone/BluetoothSMSAccess.java
@@ -0,0 +1,875 @@
+/*
+ * Copyright (C) 2012 by Gary L Dezern
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.phone;
+
+import java.io.ByteArrayOutputStream;
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import com.android.internal.telephony.EncodeException;
+import com.android.internal.telephony.GsmAlphabet;
+import com.android.internal.util.HexDump;
+import android.bluetooth.AtCommandHandler;
+import android.bluetooth.AtCommandResult;
+import android.bluetooth.AtParser;
+import android.bluetooth.HeadsetBase;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsManager;
+import android.text.format.Time;
+import android.provider.Telephony.Sms;
+import android.util.Log;
+
+
+public class BluetoothSMSAccess {
+
+    private static final boolean DBG = false;
+
+    /** helper structure for passing around info about an sms message */
+    class SMSMsgInfo {
+        int _id;
+        int type;
+        int read;
+        // instead of using read/unread, use seen/unseen.  The reason is that
+        // the AT spec dictates a message pulled from the handset should be
+        // marked as read as soon as the radio (or whatever) pulls it.
+        // However, many modern devices pull the message only to see the header
+        // and might not even be capable of displaying the full message.
+        // using the 'seen' (or notification) flag gives a consistent way of
+        // having a secondary 'read' type flag and lets the radio or whatever
+        // BT device "notify" the user.  Having a msg marked on the phone as
+        // unread when it was read on the radio is a better solution than
+        // having a message marked as read on the phone when it was never read.
+        int seen;
+        String SMSCAddress;
+        String OriginAddress;
+        long date;
+        String body;
+    };
+
+    /** constants for CMS errors */
+    public static final int CMS_ME_FAILURE = 300;
+    public static final int CMS_SERVICE_RESERVED = 301;
+    public static final int CMS_OP_NOT_ALLOWED = 302;
+    public static final int CMS_OP_NOT_SUPPORTED = 303;
+    public static final int CMS_INVALID_PDU_PARAM = 304;
+    public static final int CMS_INVALID_TEXT_PARAM = 305;
+    public static final int CMS_SIM_NOT_INSERTED = 310;
+    public static final int CMS_SIM_FAILURE = 313;
+    public static final int CMS_INVALID_INDEX = 321;
+    public static final int CMS_SMSC_ADDR_UNKNOWN = 330;
+    public static final int CMS_NO_NETWORK_SERVICE = 331;
+    public static final int CMS_NETWORK_TIMEOUT = 332;
+    public static final int CMS_UNKNOWN_ERROR = 500;
+
+    /** specific 4 char sequence to prompt CMGS sender to stream PDU (CR, LF, GreaterThan, Space) */
+    private static final String CMGS_PDU_PROMPT = "\r\n> ";
+
+    // TODO:  does it make sense to re-factor these mNMI_ variables into a local class?
+    private int mNMI_mode;
+    private int mNMI_mt;
+    private int mNMI_bfr;
+    private int mNMI_bm;
+    private int mNMI_ds;
+
+    private String mServiceCenterAddress;
+    private int mServiceCenterType;
+
+    // dummy service center number used to satisfy GSM requirements when we don't
+    // have access to the actual service center number
+    public static final String DUMMY_SERVICE_CENTER = "0000";
+
+    private static final String TAG = "BluetoothSMSAccess";
+
+    private final Context mContext;
+    private final BluetoothHandsfree mHandsfree;
+
+    // android messaging hooks
+    private SmsContentObserverClass smsContentObserver = new SmsContentObserverClass();
+
+    // the highest seen message date (used to determine what messages are newly received)
+    private long mLastSeenSMSDate = 0;
+
+
+    public BluetoothSMSAccess(Context context, BluetoothHandsfree handsfree) {
+        mContext = context;
+        mHandsfree = handsfree;
+
+        mNMI_mode = 0;
+        mNMI_mt = 0;
+        mNMI_bm = mNMI_ds = 0;
+        mNMI_bfr = 1;
+
+        mServiceCenterAddress = DUMMY_SERVICE_CENTER;
+        mServiceCenterType = 129;
+
+    }
+
+    /** registers SMS specific AT command parsers */
+    public void register(AtParser parser) {
+
+        // +CMFG: (0)
+        parser.register("+CMGF", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (DBG) Log.d(TAG, "IN: +CMGF= " + Arrays.toString(args));
+
+                if ((1 == args.length) && (args[0].equals(0))) {
+                    return new AtCommandResult(AtCommandResult.OK);
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+CMFG: (0)");
+            }
+            @Override
+            public AtCommandResult handleReadCommand() {
+                return new AtCommandResult("+CPMS: 0");
+            }
+        });
+
+        // +CNMI: (0-2),(0-1),(0),(0),(0-1)
+        parser.register("+CNMI", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (DBG) Log.d(TAG, "IN: +CNMI= " + Arrays.toString(args));
+
+                if ((5 == args.length) &&
+                        (args[0] instanceof Integer) &&
+                        (args[1] instanceof Integer) &&
+                        (args[2] instanceof Integer) &&
+                        (args[3] instanceof Integer) &&
+                        (args[4] instanceof Integer)) {
+                    // validate the parameters so "OK" can be sent before initializing
+                    // NMI - so that any notifications sent as a result of bfr=0 are
+                    // sent AFTER the "OK" final result code.
+                    if (((Integer)args[0] >= 0) && ((Integer)args[0] <= 2) &&
+                            ((Integer)args[1] >= 0) && ((Integer)args[1] <= 1) &&
+                            args[2].equals(0) && args[3].equals(0) &&
+                            ((Integer)args[4] >= 0) && ((Integer)args[4] <= 1)) {
+                        // return OK before actually initializing!
+                        mHandsfree.sendURC("OK");
+                        InitializeNMI((Integer)args[0], (Integer)args[1], 0, 0, (Integer)args[4]);
+                        return new AtCommandResult(AtCommandResult.UNSOLICITED);
+                    } else {
+                        return reportCmsError(CMS_OP_NOT_SUPPORTED);
+                    }
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+CNMI: (0-2),(0-1),(0),(0),(0-1)");
+            }
+            @Override
+            public AtCommandResult handleReadCommand() {
+                return new AtCommandResult("+CNMI: " +
+                        mNMI_mode + "," +
+                        mNMI_mt + "," +
+                        mNMI_bm + "," +
+                        mNMI_ds + "," +
+                        mNMI_bfr);
+            }
+        });
+
+        // +CPMS: ("ME"),("ME"),("ME")
+        parser.register("+CPMS", new AtCommandHandler() {
+            // order of storage spaces.
+            //  1.  storage area used when reading or deleting SMS messages
+            //  2.  storage area used when sending or writing SMS messages
+            //  3.  preferred storage area for storing newly rcvd SMS messages
+
+            // storage area "ME" means the primary message storage.  We don't support
+            // any other storage areas, so returns errors if they are seen.
+            // The parameters are "# msgs" and "total # msg slots".  Being that
+            // there are essentially an unlimited number of message "slots", just
+            // return the current msg count + 10 so it always looks like there is
+            // more room available.
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (DBG) Log.d(TAG, "IN: +CPMS= " + Arrays.toString(args));
+
+                if ((1 <= args.length) && (3 >= args.length)) {
+                    // if any args are passed, they each must be "\"ME\""
+                    if (args[0].equals("\"ME\"") &&
+                            ((2 > args.length) || args[1].equals("\"ME\"")) &&
+                            ((3 > args.length) || args[2].equals("\"ME\""))
+                            ) {
+                        int msgCount = getMessageVirtualCount();
+                        return new AtCommandResult("+CPMS: " + msgCount + "," + (msgCount + 10) +
+                                "," + msgCount + "," + (msgCount + 10) +
+                                "," + msgCount + "," + (msgCount + 10));
+                    } else {
+                        return reportCmsError(CMS_OP_NOT_ALLOWED);
+                    }
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+CPMS: (\"ME\"),(\"ME\"),(\"ME\")");
+            }
+            @Override
+            public AtCommandResult handleReadCommand() {
+                int msgCount = getMessageVirtualCount();
+                return new AtCommandResult("+CPMS: \"ME\"," + msgCount + "," + (msgCount + 10) +
+                        ",\"ME\"," + msgCount + "," + (msgCount + 10) +
+                        ",\"ME\"," + msgCount + "," + (msgCount + 10));
+            }
+        });
+
+        // +CSMS: <service>, <mt>, <mo>, <bm>
+        parser.register("+CSMS", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (DBG) Log.d(TAG, "IN: +CSMS= " + Arrays.toString(args));
+                // only service '0' is supported
+                if ((1 == args.length) && (args[0] instanceof Integer)) {
+                    if (args[0].equals(0))
+                        return new AtCommandResult("+CSMS: 1,1,0");
+                    else
+                        return reportCmsError(CMS_OP_NOT_SUPPORTED);
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+            @Override
+            public AtCommandResult handleReadCommand() {
+                // service 0, mt (mobile term msgs) support, mo (mobile origin msgs) support,
+                // bm (broadcast type not support)
+                return new AtCommandResult("+CSMS: 0,1,1,0");
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+CSMS: (0)");
+            }
+
+        });
+
+        // +CSCA: (setting the service center)
+        parser.register("+CSCA", new AtCommandHandler() {
+            // NOTE:  it doesn't appear possible to set/override the service center address
+            // with android devices.  However, support of +CSCA is required in the gsm spec.
+            // Therefore, fake it.
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (DBG) Log.d(TAG, "IN: +CSCA= " + Arrays.toString(args));
+
+                if ((1 <= args.length) && (2 >= args.length)) {
+                    mServiceCenterAddress = args[0].toString();
+                    if (2 == args.length)
+                        mServiceCenterType = (Integer)args[1];
+                    return new AtCommandResult(AtCommandResult.OK);
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+            @Override
+            public AtCommandResult handleReadCommand() {
+                return new AtCommandResult("+CSCA: " + mServiceCenterAddress + "," + mServiceCenterType);
+            }
+        });
+
+        // TODO:  implement +CMGL (list messages)
+
+        // +CMGS (send message)
+        parser.register("+CMGS", new AtCommandHandler() {
+            // NOTE:  Implementing this command requires a deviation from the the
+            // pre-existing bluetooth line-based communication.  All other AT+ style
+            // commands communicate line-based with CR line terminators. However,
+            // +CMGS requires that the TE (radio, headset, etc) sends two lines: the
+            // first terminated by CR and the second terminated by either ESC or
+            // Ctrl-Z.  That required some low level modifications...
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (DBG) Log.d(TAG, "IN: +CMGS= " + Arrays.toString(args));
+
+                if ((1 == args.length) && (args[0] instanceof Integer)) {
+                    // record the parameter (should be the length of TPDU)
+                    final int parameter = (Integer)args[0];
+                    // a very specific string of chars should be sent to "prompt" the PDU stream
+
+                    mHandsfree.setSpecialPDUInputHandler(CMGS_PDU_PROMPT,
+                            new HeadsetBase.SpecialPDUInputHandler() {
+                        @Override
+                        public void handleInput(String input) {
+                            // clear the special handler
+                            mHandsfree.setSpecialPDUInputHandler(null, null);
+                            if (DBG) {
+                                Log.d(TAG, "InputHandler param: " + parameter);
+                                Log.d(TAG, "InputHandler input: " + input);
+                            }
+                            // parsing the PDU is annoying, and must block
+                            // the BT channel until a response.  This
+                            // function should send any response(s) back.
+                            HandleSMSSubmitInput(parameter, input);
+                        }
+                    });
+                    // the setSpecialInputHandler call will send the CMGS_PDU_PROMPT, so
+                    // do nothing here.
+                    return new AtCommandResult(AtCommandResult.UNSOLICITED);
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+        });
+
+        // +CMGR
+        parser.register("+CMGR", new AtCommandHandler() {
+            @Override
+            public AtCommandResult handleSetCommand(Object[] args) {
+                if (DBG) Log.d(TAG, "IN: +CMGR= " + Arrays.toString(args));
+
+                if ((1 == args.length) && (args[0] instanceof Integer)) {
+                    SMSMsgInfo smsInfo = new SMSMsgInfo();
+                    // gather the sms message info
+                    int iRet = getMessageAtIndex((Integer) args[0], smsInfo, true);
+                    if (iRet < 0) {    // unknown error
+                        return new AtCommandResult(AtCommandResult.ERROR);
+                    } else if (iRet > 0) {    // specific CMS error
+                        return reportCmsError(iRet);
+                    }
+                    // create the response with PDU stream
+                    return CreatePDUResponse(smsInfo);
+                } else {
+                    return new AtCommandResult(AtCommandResult.ERROR);
+                }
+            }
+            @Override
+            public AtCommandResult handleTestCommand() {
+                return new AtCommandResult("+CMGR: (1-" + getMessageVirtualCount() + ")");
+            }
+        });
+    }
+
+    /** called on disconnected bluetooth */
+    synchronized void resetAtState() {
+        TurnOffNMI();
+    }
+
+    /** helper similar to Integer.parseInt(string, 16), but specialized for PDU processing */
+    private static int CharToByte(char c)
+    {
+        if (c >= '0' && c <= '9') return (c - '0');
+        if (c >= 'A' && c <= 'F') return (c - 'A' + 10);
+        if (c >= 'a' && c <= 'f') return (c - 'a' + 10);
+        throw new RuntimeException ("Invalid hex char '" + c + "'");
+    }
+
+    /** helper that uses CharToByte to generate pdu octets */
+    private static byte TwoCharToByte(char firstC, char secondC)
+    {
+        return (byte)((CharToByte(firstC) << 4) | CharToByte(secondC));
+    }
+
+    /** handles the PDU stream when creating/sending an SMS message */
+    private void HandleSMSSubmitInput(int cmdParameter, String input)
+    {
+        AtCommandResult result = null;
+        // first, validate the data from the TE before trying to parse
+        // much of it.
+        if ((1 == input.length()) && (27 == (int)input.charAt(0))) {
+            result = new AtCommandResult(AtCommandResult.OK);
+        } else if (2 > input.length()) {
+            if (DBG) Log.d(TAG, "handleInput: <2 length input");
+            result = new AtCommandResult(AtCommandResult.ERROR);
+        } else  {
+            // might be valid... do a bit more checking.
+
+            // NOTE:  Some TE's (kenwood head units) are buggy in that they
+            // may embed invalid characters in the destination address of the
+            // PDU stream.  In particular, it won't strip invalid characters
+            // from a destination phone number before shoving it into the PDU
+            // stream.  Instead of "1234567890" in the stream, I'll get other
+            // punctuation such as "(123) 456-7890".  For that reason, the entire
+            // pdu stream can't be converted to a byte array at one time.
+
+            boolean bError = false;
+            String scAddress = null;
+            String destAddress = null;
+            String msgBody = null;
+
+            char[] inputArray = input.toCharArray();
+            int curInputChar = 0;  // where in "input" currently parsing
+
+            int msgRefNum = 99;
+
+            if (DBG) Log.d(TAG, "input stream: " + input);
+
+            // first byte (pair of chars) should be the length of the SC address
+            try {
+                int scAddressLen = TwoCharToByte(inputArray[curInputChar++], inputArray[curInputChar++]);
+                // ensure the input length is long enough for the scAddresslen, scaddress, and
+                // at least 3 more pairs. (first octet, msg ref, dest addr len)
+                if (((4 + scAddressLen) * 2) >= input.length()) {
+                    // input too short
+                    Log.e(TAG, "Input too short after SC Length");
+                    result = reportCmsError(CMS_INVALID_PDU_PARAM);
+                    bError = true;
+                } else {
+                    if (DBG) Log.d(TAG, "Parsing Status A:  curInputChar=" + curInputChar + ", scAddressLen=" + scAddressLen);
+
+                    // actually extract the scAddress along with the 2 next bytes/pairs
+                    byte[] pdu = new byte[scAddressLen + 2];
+                    for (int i = 0; i <  (scAddressLen + 2); i++)
+                    {
+                        pdu[i] = TwoCharToByte(inputArray[curInputChar++], inputArray[curInputChar++]);
+                    }
+                    if (0 != scAddressLen) {
+                        scAddress = PhoneNumberUtils.calledPartyBCDToString(pdu, 0, scAddressLen);
+                    }
+                    // next byte is the "first octet" flags - most ignored, but
+                    // make sure bits 0-1 are set to 0x1
+                    if (1 != (pdu[scAddressLen] & 0x3)) {
+                        Log.e(TAG, "Invalid TP-Message-Type-Indicator flag");
+                        result = reportCmsError(CMS_OP_NOT_SUPPORTED);
+                        bError = true;
+                    }
+                    // the next byte (TP-Message-Reference) is completely ignored
+                }
+            }
+            catch (RuntimeException ex) {
+                Log.e(TAG, "Invalid SC Address");
+                // fall through for CMS unknown err
+                bError = true;
+            }
+
+            if (!bError) {
+                try {
+                    if (DBG) Log.d(TAG, "Parsing Status B:  curInputChar=" + curInputChar);
+                    // curInputChar should point to the length of the destination address now...
+                    int destAddrLen = TwoCharToByte(inputArray[curInputChar++], inputArray[curInputChar++]);
+                    int destAddrBytes = (((destAddrLen + 1) / 2));
+                    // ensure there's still enough input space for the destination address
+                    // and 4 more pairs (destAddrType, protocol ID, data coding scheme, length of user data)
+                    if (((4 + destAddrBytes) * 2) >= (input.length() - curInputChar)) {
+                        // input too short
+                        Log.e(TAG, "Input too short after Destination Address Length");
+                        bError = true;
+                    } else {
+                        if (DBG) Log.d(TAG, "Parsing Status C:  curInputChar=" + curInputChar + ", destAddrLen=" + destAddrLen);
+
+                        curInputChar += 2; // skip the dest address type.
+
+                        // actually work to pull out the destination phone number.
+                        StringBuilder sb = new StringBuilder(destAddrLen + 1);
+
+                        for (int i = 0; i < destAddrBytes; i++) {
+                            // get two characters and swap them
+                            sb.append(inputArray[curInputChar + 1]);
+                            sb.append(inputArray[curInputChar]);
+                            curInputChar += 2;
+                        }
+                        destAddress = sb.substring(0, destAddrLen);
+
+                        if (DBG) Log.d(TAG, "Parsing Status D:  curInputChar=" + curInputChar + ", destAddress=" + destAddress);
+
+                        // the next byte contains the protocol identifier.  enforce this being 0
+                        if (!bError && (0 != TwoCharToByte(inputArray[curInputChar++], inputArray[curInputChar++]))) {
+                            Log.e(TAG, "Invalid TP-Protocol-Identifer");
+                            result = reportCmsError(CMS_OP_NOT_SUPPORTED);
+                            bError = true;
+                        }
+                        // next is a data coding scheme.  Handle any scheme the user wants, as
+                        // long as they want 7bit GSM with no special features.
+                        if (!bError && (0 != TwoCharToByte(inputArray[curInputChar++], inputArray[curInputChar++]))) {
+                            Log.e(TAG, "Unsupported TP-Data-Coding-Scheme");
+                            result = reportCmsError(CMS_OP_NOT_SUPPORTED);
+                            bError = true;
+                        }
+                        // TP-Validy-Period bits not set, so don't try to read the period
+                    }
+                }
+                catch (RuntimeException ex) {
+                    Log.e(TAG, "Invalid Destination Address");
+                    // fall through to result being cms unknown
+                    bError = true;
+                }
+            }
+            if (!bError) {
+                try {
+                    // only thing left is the user data length and actual user data...
+                    int userDataLen = TwoCharToByte(inputArray[curInputChar++], inputArray[curInputChar++]);
+
+                    msgBody = GsmAlphabet.gsm7BitPackedToString(
+                            HexDump.hexStringToByteArray(input.substring(curInputChar)),
+                            0, userDataLen);
+                }
+                catch (RuntimeException ex) {
+                    Log.e(TAG, "Invalid Message Body");
+                    // fall through to result being cms unknown
+                    bError = true;
+                }
+            }
+
+            if (!bError) {
+                // send the message
+                if (DBG) {
+                    Log.d(TAG, "To: " + destAddress);
+                    Log.d(TAG, "Body: " + msgBody);
+                }
+                SmsManager.getDefault().sendTextMessage(destAddress, scAddress, msgBody, null, null);
+
+                // according to the spec, the code should block until the message sends or fails..
+                //  not sure how to deal with that here.
+
+                // some debugging code to allow testing for TE response to errors.
+                if (DBG && (-1 != msgBody.toUpperCase().indexOf("CMSERROR"))) {
+                    Log.d(TAG, "Forced CMS error final result");
+                    result = reportCmsError(CMS_NO_NETWORK_SERVICE);
+                }
+                else if (DBG && (-1 != msgBody.toUpperCase().indexOf("ERROR"))) {
+                    Log.d(TAG, "Forced non-CMS error final result");
+                    result = new AtCommandResult(AtCommandResult.ERROR);
+                } else {
+                    if (DBG) Log.d(TAG, "OUT: +CMGS: " + msgRefNum);
+                    mHandsfree.sendURC("+CMGS: " + msgRefNum);
+                    result = new AtCommandResult(AtCommandResult.OK);
+                }
+            }
+            if (null == result)
+            {
+                result = reportCmsError(CMS_UNKNOWN_ERROR);
+            }
+        }
+        if (null == result)
+            result = new AtCommandResult(AtCommandResult.OK);
+
+        if (DBG) Log.d(TAG, "OUT: " + result.toString());
+        mHandsfree.sendURC(result.toString());
+    }
+
+    /** generate +CMS ERROR: final responses. */
+    private AtCommandResult reportCmsError(int error) {
+        AtCommandResult result = new AtCommandResult(AtCommandResult.UNSOLICITED);
+        result.addResponse("+CMS ERROR: " + error);
+        return result;
+    }
+
+    /** helper function for creating PDU response */
+    private static int swapBCDForTime( int inbyte )
+    {
+        inbyte = inbyte & 0xFF;
+
+        int high = inbyte / 10;
+        return ((inbyte - (high * 10)) << 4) | high;
+    }
+
+    /** given an smsInfo, creates +CMGR response including PDU stream */
+    private AtCommandResult CreatePDUResponse(SMSMsgInfo smsInfo) {
+        // Format of response:
+
+        // +CMGR: <stat>,[<alpha>],<length><cr><lf><pdu>
+        //        <stat> = 0 (incoming unread)
+        //                 1 (incoming read)
+        //                 2 (stored/unsent)
+        //                 3 (stored/sent)
+        //        <alpha> - string type alphanumeric representation of TP-Destination address or TP-originating address corresponding to the entry found in the phonebook
+        //        <length> - length of the actual TP data unit in octets (bytes) (the SMSC address octets are not counted in the length)
+        //        <pdu> - SC address followed by the TPDU in hex format
+
+        ByteArrayOutputStream bo = new ByteArrayOutputStream(300);
+
+        byte[] scData = PhoneNumberUtils.networkPortionToCalledPartyBCDWithLength("0000");
+        bo.write(scData, 0, scData.length);
+        bo.write(4);    // flags
+
+        byte[] destData = PhoneNumberUtils.networkPortionToCalledPartyBCD(smsInfo.OriginAddress);
+        if( destData == null )
+            return new AtCommandResult(AtCommandResult.ERROR);
+
+        int destLength = ((destData.length - 1) * 2
+                - ((destData[destData.length - 1] & 0xf0) == 0xf0 ? 1 : 0));
+
+        bo.write(destLength);
+        bo.write(destData, 0, destData.length);
+        bo.write(0);    // protocol ID
+        bo.write(0);    // data coding scheme
+
+        Time msgTime = new Time(Time.TIMEZONE_UTC);
+        msgTime.set(smsInfo.date); // this is a UTC date!!
+        msgTime.switchTimezone(Time.getCurrentTimezone()); // now its a local time
+
+        bo.write(swapBCDForTime(msgTime.year % 100));
+        bo.write(swapBCDForTime(msgTime.month + 1));
+        bo.write(swapBCDForTime(msgTime.monthDay));
+        bo.write(swapBCDForTime(msgTime.hour));
+        bo.write(swapBCDForTime(msgTime.minute));
+        if (msgTime.second > 59) msgTime.second = 59;
+        bo.write(swapBCDForTime(msgTime.second));
+        // tzoffset... measured in quarter hours with a plus/minus bit
+        long tzOffset = (msgTime.gmtoff) / (60 * 15);
+        // tzOffset is now the number of 15 minute intervals between UTC and local
+        bo.write(swapBCDForTime((int) (tzOffset < 0 ? 128 - tzOffset : tzOffset)));
+
+        if (smsInfo.body.length() >= 160)
+            smsInfo.body = smsInfo.body.substring(0, 159);
+        byte[] userData = {};
+        try {
+            userData = GsmAlphabet.stringToGsm7BitPacked(smsInfo.body, 0, false, 0, 0);
+            bo.write(userData, 0, userData.length);
+        }
+        catch (EncodeException ex)
+        {
+            return new AtCommandResult(AtCommandResult.ERROR);
+        }
+        // the length of the PDU is bo size minus the scData length
+        int pduSize = bo.size() - scData.length;
+
+        int stat = 2; // outgoing unsent default
+        if (Sms.MESSAGE_TYPE_SENT == smsInfo.type) {
+            stat = 3;    // out/sent
+        } else if (Sms.MESSAGE_TYPE_INBOX == smsInfo.type) {
+            // see comment about 'seen' at the declaration of SMSMsgInfo
+            stat = (0 == smsInfo.seen) ? 0 : 1;
+        }
+        return new AtCommandResult("+CMGR: " + stat + ",," + pduSize + "\r\n" +
+                HexDump.toHexString(bo.toByteArray()));
+    }
+
+    /** shortcut to turn off new message indicators */
+    private void TurnOffNMI() {
+        InitializeNMI(0, 0, 0, 0, 1);
+    }
+
+    /** handles turning on/off new message indicator mode(s) */
+    private void InitializeNMI(int mode, int mt, int bm, int ds, int bfr) {
+        mNMI_mt = mt;    // only 0/1/2 supported
+        mNMI_bm = bm;    // only 0 supported
+        mNMI_ds = ds;    // only 0 supported
+        mNMI_bfr = bfr;
+
+        if (0 == mode) {
+            // only unregister the observer if it exists to begin with
+            if (0 != mNMI_mode) {
+                mContext.getContentResolver().unregisterContentObserver(smsContentObserver);
+                mNMI_mode = 0;
+            }
+        } else {
+            // modes 1 thru 3 are all the same the BT connection as there isn't ever
+            // any type of "reserved" mode (no DUN shares the link)
+
+            // for the purpose of bfr, consider any message that is not "seen" to be buffered.
+
+            mNMI_mode = mode;
+            // oddly, mt=0 will result in no messages being sent, but still hook the content
+            // observer for the purposes of future support of cell broadcast and/or delivery
+            // reports.  Setting a non-0 mode and leaving bm/ds/mt all at zero is silly.
+
+            Cursor sms = mContext.getContentResolver().query(Sms.CONTENT_URI,
+                    new String[] {"_id", Sms.DATE},
+                    Sms.TYPE + " + " + Sms.MESSAGE_TYPE_INBOX,
+                    null, Sms.DATE + " desc, _id desc");
+            if (null != sms) {
+                int dateColumn = sms.getColumnIndex(Sms.DATE);
+                mLastSeenSMSDate = 0;
+                if (sms.moveToFirst()) {
+                    mLastSeenSMSDate = sms.getLong(dateColumn);
+                }
+                sms.close();
+            }
+
+            // if bfr 0, anything marked as NOT SEEN should be notified (based on mt).
+            // In theory, only the newest will be unseen, so try to optimize things
+            // for that theory...  If I'm wrong, this will be out of spec.
+            if (0 == mNMI_bfr)
+            {
+                sms = mContext.getContentResolver().query(Sms.CONTENT_URI,
+                        new String[] {"_id", Sms.SEEN, Sms.TYPE},
+                        /* no filter - it'll mess up the index */
+                        null, null, Sms.DATE + " desc, _id desc");
+                if (null != sms) {
+                    int seenColumn = sms.getColumnIndex(Sms.SEEN);
+                    int typeColumn = sms.getColumnIndex(Sms.TYPE);
+                    int idColumn = sms.getColumnIndex("_id");
+
+                    int curMsgIdx = sms.getCount();
+                    if ((0 != curMsgIdx) && sms.moveToFirst()) {
+                        do {
+                            if (Sms.MESSAGE_TYPE_INBOX == sms.getLong(typeColumn)) {
+                                if (0 == sms.getLong(seenColumn)) {
+                                    // send notification
+                                    SendNMINofitication(sms.getInt(idColumn), curMsgIdx);
+                                    curMsgIdx--;
+                                } else {
+                                    // on the first seen message, break from the loop
+                                    break;
+                                }
+                            }
+                        } while (sms.moveToPrevious());
+                    }
+                    sms.close();
+                }
+            } // if 0 bfr
+
+            // registering on Sms.Inbox should be more efficient than on the entire SMS db, but
+            // it doesn't seem to get change notices when new SMS messages come in.
+            mContext.getContentResolver().registerContentObserver(Sms.CONTENT_URI, true, smsContentObserver);
+        }
+    }
+
+    /** gets a message count */
+    private int getMessageVirtualCount() {
+        int iRet = 0;
+        Cursor smsCursor =
+                mContext.getContentResolver().query(Sms.CONTENT_URI,
+                        new String[] {"_id"},
+                        null, null, null);
+        if (null != smsCursor)
+        {
+            iRet = smsCursor.getCount();
+            smsCursor.close();
+        }
+        return iRet;
+    }
+
+    /** find msg at a virtual index and populates smsInfo. Optionally marks msg as seen */
+    private int getMessageAtIndex(int index, SMSMsgInfo smsInfo, boolean bMarkAsSeen) {
+
+        int iRet = -1;
+
+        // cursor is 0 based, but the 'index' parameter is 1 based.
+        index--;
+
+        Cursor smsCursor =
+                mContext.getContentResolver().query(Sms.CONTENT_URI,
+                        new String[] {"_id", Sms.BODY, Sms.DATE, Sms.ADDRESS, Sms.SERVICE_CENTER, Sms.TYPE, Sms.READ, Sms.SEEN },
+                        null, null, Sms.DATE + " asc"); // in date ascending order for counting
+        if (null != smsCursor) {
+            if ((index < smsCursor.getCount()) && (smsCursor.moveToPosition(index))) {
+                int smsID = smsCursor.getInt(smsCursor.getColumnIndex("_id"));
+                smsInfo._id = smsID;
+                smsInfo.body = smsCursor.getString(smsCursor.getColumnIndex(Sms.BODY));
+                smsInfo.date = smsCursor.getLong(smsCursor.getColumnIndex(Sms.DATE));
+                smsInfo.OriginAddress = smsCursor.getString(smsCursor.getColumnIndex(Sms.ADDRESS));
+                smsInfo.SMSCAddress = smsCursor.getString(smsCursor.getColumnIndex(Sms.SERVICE_CENTER));
+                smsInfo.type = smsCursor.getInt(smsCursor.getColumnIndex(Sms.TYPE));
+                smsInfo.read = smsCursor.getInt(smsCursor.getColumnIndex(Sms.READ));
+                smsInfo.seen = smsCursor.getInt(smsCursor.getColumnIndex(Sms.SEEN));
+
+                //does java do ordered AND's?
+                if (null != smsInfo.SMSCAddress)
+                    if (smsInfo.SMSCAddress.trim().isEmpty())
+                        smsInfo.SMSCAddress = null;
+
+                iRet = 0; // success
+
+                if (bMarkAsSeen && (0 == smsCursor.getLong(smsCursor.getColumnIndex(Sms.SEEN)))) {
+                    if (DBG) Log.d(TAG, "Marking SMS record id " + smsInfo._id + " as seen.");
+                    ContentValues updateSeen = new ContentValues();
+                    updateSeen.put(Sms.SEEN, 1);
+                    mContext.getContentResolver().update(Sms.CONTENT_URI, updateSeen,
+                            "_id = " + smsInfo._id, null);
+                }
+
+            } else {
+                iRet = CMS_INVALID_INDEX;
+            }
+            smsCursor.close();
+        }
+        return iRet;
+    }
+
+    /** Actually sends the unsolicited response indicating a new incoming SMS */
+    private void SendNMINofitication(int _id, int index) {
+        if (1 == mNMI_mt) {
+            if (DBG) Log.d(TAG, "OUT: +CMTI: \"ME\"," + index);
+            mHandsfree.sendURC("+CMTI: \"ME\"," + index);
+        }
+        // if mt > 1, this might be a +CMT response with the actual message included.
+    }
+
+    /** ContentObserver for watching the sms content db (specifically for new records */
+    private class SmsContentObserverClass extends ContentObserver {
+        public SmsContentObserverClass() {
+            super(null);
+        }
+        @Override
+        public void onChange(boolean selfChange) {
+
+            // try to make things faster by first checking for new messages.  Only
+            // do the full query if there are messages since mLastSeenSMSDate that are
+            // also in the INBOX.  Funny how a content observer on Sms.Inbox.CONTENT_URI
+            // doesn't send a notification on a new message, but this query (on the same
+            // URI) will find it.
+            Cursor sms = mContext.getContentResolver().query(Sms.Inbox.CONTENT_URI,
+                    new String[] {"_id", Sms.DATE },
+                    Sms.DATE + " > " + mLastSeenSMSDate,
+                    null, null);
+
+            int nNewCount = sms.getCount();
+            if (DBG) Log.d(TAG, "content on change, new count = " + nNewCount);
+            sms.close();
+
+            if (nNewCount > 0) {
+                // there is at least one new message since LastSeenSMSDate.  In order
+                // to get the message index, the entire sms db has to be in a cursor
+                // for the count.  (msg idx 'N' is the Nth message in a list sorted by date)
+
+                sms = mContext.getContentResolver().query(Sms.CONTENT_URI,
+                        new String[] {"_id", Sms.DATE, Sms.TYPE },
+                        null, null, Sms.DATE + " desc, _id desc");
+
+                int nCurMsgIdx = sms.getCount(); // the latest dated message has this index
+
+                int dateColumn = sms.getColumnIndex(Sms.DATE);
+                int typeColumn = sms.getColumnIndex(Sms.TYPE);
+                int idColumn = sms.getColumnIndex("_id");
+
+                // record the largest date seen while looping
+                long nLatestDate = mLastSeenSMSDate;
+                long nMsgDate;
+
+                // this moveToFirst() should always succeed... but be paranoid
+                if (sms.moveToFirst()) {
+                    // the first seen will have the newest date stamp, so hang on to that
+                    // for updating mLastSeenSMSDate later on
+                    nMsgDate = nLatestDate = sms.getLong(dateColumn);
+
+                    // walk the cursor from the newest message to the oldest (desc sort order)
+                    while (nMsgDate > mLastSeenSMSDate) {
+                        // only concerned about stuff in the INBOX
+                        if (Sms.MESSAGE_TYPE_INBOX == sms.getLong(typeColumn)) {
+                            SendNMINofitication(sms.getInt(idColumn), nCurMsgIdx);
+                        }
+                        // get the previous message (next cursor row)
+                        if (sms.moveToPrevious()) {
+                            nCurMsgIdx--;
+                            // check if the date
+                            nMsgDate = sms.getLong(dateColumn);
+                        } else {
+                            // if moveToPrevious fails, there are no earlier msgs - so
+                            // a msg date of 0 actually makes sense (and results in the
+                            // loop terminating.)
+                            nMsgDate = 0;
+                        }
+                    }
+                    if (nLatestDate > mLastSeenSMSDate)
+                        mLastSeenSMSDate = nLatestDate;
+                } // if moveToFirst
+                sms.close();
+            } // if newCount > 0
+        }
+    }
+}
diff --git a/src/com/android/phone/CallCard.java b/src/com/android/phone/CallCard.java
index b830fd2..6587de3 100644
--- a/src/com/android/phone/CallCard.java
+++ b/src/com/android/phone/CallCard.java
@@ -1427,6 +1427,7 @@ public class CallCard extends LinearLayout
 
         // Other text fields:
         updateCallTypeLabel(call);
+	setGeoDescription(info);
         // updateSocialStatus(socialStatusText, socialStatusBadge, call);  // Currently unused
     }
 
@@ -1617,6 +1618,27 @@ public class CallCard extends LinearLayout
         }
     }
 
+    private void setGeoDescription(CallerInfo paramCallerInfo)
+    {
+
+        if (paramCallerInfo != null){
+            if (this.mCallTypeLabel.getVisibility() == View.GONE){
+                if (TextUtils.isEmpty(paramCallerInfo.geoDescription)){
+                    paramCallerInfo.updateGeoDescription(this.getContext(),paramCallerInfo.phoneNumber);
+                }
+                if (!TextUtils.isEmpty(paramCallerInfo.geoDescription)){
+                    this.mCallTypeLabel.setVisibility(View.VISIBLE);
+                    this.mCallTypeLabel.setText(paramCallerInfo.geoDescription);
+                    this.mCallTypeLabel.setTextColor(this.mTextColorCallTypeSip);
+                    if (paramCallerInfo.geoDescription.equals(this.mPhoneNumber.getText())){
+                        this.mPhoneNumber.setVisibility(View.GONE);
+                    }
+                }
+            }
+        }
+        return;
+    }
+
     /**
      * Try to display the cached image from the callerinfo object.
      *
diff --git a/src/com/android/phone/CallNotifier.java b/src/com/android/phone/CallNotifier.java
index 7901718..b0a3f12 100755
--- a/src/com/android/phone/CallNotifier.java
+++ b/src/com/android/phone/CallNotifier.java
@@ -37,9 +37,6 @@ import android.app.ActivityManagerNative;
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothHeadset;
-import android.bluetooth.BluetoothProfile;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
@@ -170,7 +167,7 @@ public class CallNotifier extends Handler
     private PhoneGlobals mApplication;
     private CallManager mCM;
     private Ringer mRinger;
-    private BluetoothHeadset mBluetoothHeadset;
+    private BluetoothHandsfree mBluetoothHandsfree;
     private CallLogAsync mCallLog;
     private boolean mSilentRingerRequested;
 
@@ -211,10 +208,10 @@ public class CallNotifier extends Handler
      * This is only done once, at startup, from PhoneApp.onCreate().
      */
     /* package */ static CallNotifier init(PhoneGlobals app, Phone phone, Ringer ringer,
-                                           CallLogAsync callLog) {
+                                           BluetoothHandsfree btMgr, CallLogAsync callLog) {
         synchronized (CallNotifier.class) {
             if (sInstance == null) {
-                sInstance = new CallNotifier(app, phone, ringer, callLog);
+                sInstance = new CallNotifier(app, phone, ringer, btMgr, callLog);
             } else {
                 Log.wtf(LOG_TAG, "init() called multiple times!  sInstance = " + sInstance);
             }
@@ -223,7 +220,7 @@ public class CallNotifier extends Handler
     }
 
     /** Private constructor; @see init() */
-    private CallNotifier(PhoneGlobals app, Phone phone, Ringer ringer, CallLogAsync callLog) {
+    private CallNotifier(PhoneGlobals app, Phone phone, Ringer ringer, BluetoothHandsfree btMgr, CallLogAsync callLog) {
         mApplication = app;
         mCM = app.mCM;
         mCallLog = callLog;
@@ -239,12 +236,7 @@ public class CallNotifier extends Handler
         createSignalInfoToneGenerator();
 
         mRinger = ringer;
-        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-        if (adapter != null) {
-            adapter.getProfileProxy(mApplication.getApplicationContext(),
-                                    mBluetoothProfileServiceListener,
-                                    BluetoothProfile.HEADSET);
-        }
+        mBluetoothHandsfree = btMgr;
 
         TelephonyManager telephonyManager = (TelephonyManager)app.getSystemService(
                 Context.TELEPHONY_SERVICE);
@@ -1443,8 +1435,8 @@ public class CallNotifier extends Handler
     private void resetAudioStateAfterDisconnect() {
         if (VDBG) log("resetAudioStateAfterDisconnect()...");
 
-        if (mBluetoothHeadset != null) {
-            mBluetoothHeadset.disconnectAudio();
+        if (mBluetoothHandsfree != null) {
+            mBluetoothHandsfree.audioOff();
         }
 
         // call turnOnSpeaker() with state=false and store=true even if speaker
@@ -1689,8 +1681,8 @@ public class CallNotifier extends Handler
             ToneGenerator toneGenerator;
             try {
                 int stream;
-                if (mBluetoothHeadset != null) {
-                    stream = mBluetoothHeadset.isAudioOn() ? AudioManager.STREAM_BLUETOOTH_SCO:
+                if (mBluetoothHandsfree != null) {
+                    stream = mBluetoothHandsfree.isAudioOn() ? AudioManager.STREAM_BLUETOOTH_SCO:
                         AudioManager.STREAM_VOICE_CALL;
                 } else {
                     stream = AudioManager.STREAM_VOICE_CALL;
@@ -2156,18 +2148,6 @@ public class CallNotifier extends Handler
         }
     }
 
-     private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
-        new BluetoothProfile.ServiceListener() {
-        public void onServiceConnected(int profile, BluetoothProfile proxy) {
-            mBluetoothHeadset = (BluetoothHeadset) proxy;
-            if (VDBG) log("- Got BluetoothHeadset: " + mBluetoothHeadset);
-        }
-
-        public void onServiceDisconnected(int profile) {
-            mBluetoothHeadset = null;
-        }
-    };
-
     private void onRingbackTone(AsyncResult r) {
         boolean playTone = (Boolean)(r.result);
 
diff --git a/src/com/android/phone/InCallScreen.java b/src/com/android/phone/InCallScreen.java
index 7a65bbe..42cce51 100755
--- a/src/com/android/phone/InCallScreen.java
+++ b/src/com/android/phone/InCallScreen.java
@@ -25,7 +25,6 @@ import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothHeadset;
 import android.bluetooth.BluetoothProfile;
-import android.bluetooth.IBluetoothHeadsetPhone;
 import android.content.ActivityNotFoundException;
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -295,6 +294,7 @@ public class InCallScreen extends Activity
     // based on the current foreground Call.)
     private Phone mPhone;
 
+    private BluetoothHandsfree mBluetoothHandsfree;
     private BluetoothHeadset mBluetoothHeadset;
     private BluetoothAdapter mBluetoothAdapter;
     private boolean mBluetoothConnectionPending;
@@ -586,10 +586,17 @@ public class InCallScreen extends Activity
         mCM =  mApp.mCM;
         log("- onCreate: phone state = " + mCM.getState());
 
-        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
-        if (mBluetoothAdapter != null) {
+        mBluetoothHandsfree = mApp.getBluetoothHandsfree();
+        if (VDBG) log("- mBluetoothHandsfree: " + mBluetoothHandsfree);
+
+        if (mBluetoothHandsfree != null) {
+            // The PhoneApp only creates a BluetoothHandsfree instance in the
+            // first place if BluetoothAdapter.getDefaultAdapter()
+            // succeeds.  So at this point we know the device is BT-capable.
+            mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
             mBluetoothAdapter.getProfileProxy(getApplicationContext(), mBluetoothProfileServiceListener,
                                     BluetoothProfile.HEADSET);
+
         }
 
         requestWindowFeature(Window.FEATURE_NO_TITLE);
@@ -2991,6 +2998,14 @@ public class InCallScreen extends Activity
         updateInCallTouchUi();
     }
 
+    public void resetSpeaker() {
+        if (! isBluetoothAvailable() || ! isBluetoothAudioConnected()) {
+            disconnectBluetoothAudio();
+	    PhoneUtils.turnOnSpeaker(this, PhoneUtils.isSpeakerOn(this), true);
+	    updateInCallTouchUi();
+        }
+    }
+
     /*
      * onMuteClick is called only when there is a foreground call
      */
@@ -3861,15 +3876,11 @@ public class InCallScreen extends Activity
 
         // If we have a valid BluetoothPhoneService then since CDMA network or
         // Telephony FW does not send us information on which caller got swapped
-        // we need to update the second call active state in BluetoothPhoneService internally
+        // we need to update the second call active state in BluetoothHandsfree internally
         if (mCM.getBgPhone().getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
-            IBluetoothHeadsetPhone btPhone = mApp.getBluetoothPhoneService();
-            if (btPhone != null) {
-                try {
-                    btPhone.cdmaSwapSecondCallState();
-                } catch (RemoteException e) {
-                    Log.e(LOG_TAG, Log.getStackTraceString(new Throwable()));
-                }
+            BluetoothHandsfree bthf = mApp.getBluetoothHandsfree();
+            if (bthf != null) {
+                bthf.cdmaSwapSecondCallState();
             }
         }
 
@@ -4280,6 +4291,13 @@ public class InCallScreen extends Activity
     //   headset (which we don't do from the Phone UI!) but also lets you
     //   get the address of the currently active headset and see whether
     //   it's currently connected.
+    //
+    // - BluetoothHandsfree is the API to control the audio connection to
+    //   a bluetooth headset. We use this API to switch the headset on and
+    //   off when the user presses the "Bluetooth" button.
+    //   Our BluetoothHandsfree instance (mBluetoothHandsfree) is created
+    //   by the PhoneApp and will be null if the device is not BT capable.
+    //
 
     /**
      * @return true if the Bluetooth on/off switch in the UI should be
@@ -4288,6 +4306,11 @@ public class InCallScreen extends Activity
      */
     /* package */ boolean isBluetoothAvailable() {
         if (VDBG) log("isBluetoothAvailable()...");
+        if (mBluetoothHandsfree == null) {
+            // Device is not BT capable.
+            if (VDBG) log("  ==> FALSE (not BT capable)");
+            return false;
+        }
 
         // There's no need to ask the Bluetooth system service if BT is enabled:
         //
@@ -4327,17 +4350,11 @@ public class InCallScreen extends Activity
      * @return true if a BT Headset is available, and its audio is currently connected.
      */
     /* package */ boolean isBluetoothAudioConnected() {
-        if (mBluetoothHeadset == null) {
-            if (VDBG) log("isBluetoothAudioConnected: ==> FALSE (null mBluetoothHeadset)");
-            return false;
-        }
-        List<BluetoothDevice> deviceList = mBluetoothHeadset.getConnectedDevices();
-
-        if (deviceList.isEmpty()) {
+        if (mBluetoothHandsfree == null) {
+            if (VDBG) log("isBluetoothAudioConnected: ==> FALSE (null mBluetoothHandsfree)");
             return false;
         }
-        BluetoothDevice device = deviceList.get(0);
-        boolean isAudioOn = mBluetoothHeadset.isAudioConnected(device);
+        boolean isAudioOn = mBluetoothHandsfree.isAudioOn();
         if (VDBG) log("isBluetoothAudioConnected: ==> isAudioOn = " + isAudioOn);
         return isAudioOn;
     }
@@ -4347,7 +4364,7 @@ public class InCallScreen extends Activity
      * see InCallControlState.bluetoothIndicatorOn.
      *
      * @return true if a BT device is available and its audio is currently connected,
-     *              <b>or</b> if we issued a BluetoothHeadset.connectAudio()
+     *              <b>or</b> if we issued a BluetoothHandsfree.userWantsAudioOn()
      *              call within the last 5 seconds (which presumably means
      *              that the BT audio connection is currently being set
      *              up, and will be connected soon.)
@@ -4401,7 +4418,8 @@ public class InCallScreen extends Activity
         log("= PhoneApp.showBluetoothIndication: "
             + mApp.showBluetoothIndication());
         log("=");
-        if (mBluetoothAdapter != null) {
+        if (mBluetoothHandsfree != null) {
+            log("= BluetoothHandsfree.isAudioOn: " + mBluetoothHandsfree.isAudioOn());
             if (mBluetoothHeadset != null) {
                 List<BluetoothDevice> deviceList = mBluetoothHeadset.getConnectedDevices();
 
@@ -4417,15 +4435,14 @@ public class InCallScreen extends Activity
                 log("= mBluetoothHeadset is null");
             }
         } else {
-            log("= mBluetoothAdapter is null; device is not BT capable");
+            log("= mBluetoothHandsfree is null; device is not BT capable");
         }
     }
 
     /* package */ void connectBluetoothAudio() {
         if (VDBG) log("connectBluetoothAudio()...");
-        if (mBluetoothHeadset != null) {
-            // TODO(BT) check return
-            mBluetoothHeadset.connectAudio();
+        if (mBluetoothHandsfree != null) {
+            mBluetoothHandsfree.userWantsAudioOn();
         }
 
         // Watch out: The bluetooth connection doesn't happen instantly;
@@ -4439,8 +4456,8 @@ public class InCallScreen extends Activity
 
     /* package */ void disconnectBluetoothAudio() {
         if (VDBG) log("disconnectBluetoothAudio()...");
-        if (mBluetoothHeadset != null) {
-            mBluetoothHeadset.disconnectAudio();
+        if (mBluetoothHandsfree != null) {
+            mBluetoothHandsfree.userWantsAudioOff();
         }
         mBluetoothConnectionPending = false;
     }
diff --git a/src/com/android/phone/PhoneGlobals.java b/src/com/android/phone/PhoneGlobals.java
index 671a1db..128d201 100644
--- a/src/com/android/phone/PhoneGlobals.java
+++ b/src/com/android/phone/PhoneGlobals.java
@@ -25,7 +25,9 @@ import android.app.ProgressDialog;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothHeadset;
 import android.bluetooth.BluetoothProfile;
-import android.bluetooth.IBluetoothHeadsetPhone;
+//vukvuk
+import android.net.ConnectivityManager;
+
 import android.content.ActivityNotFoundException;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -172,7 +174,7 @@ public class PhoneGlobals extends ContextWrapper
     NotificationMgr notificationMgr;
     Ringer ringer;
     Blacklist blackList;
-    IBluetoothHeadsetPhone mBluetoothPhone;
+    BluetoothHandsfree mBluetoothPhone;
     PhoneInterfaceManager phoneMgr;
     CallManager mCM;
     int mBluetoothHeadsetState = BluetoothProfile.STATE_DISCONNECTED;
@@ -348,14 +350,16 @@ public class PhoneGlobals extends ContextWrapper
 
                     phoneState = mCM.getState();
                     // Do not change speaker state if phone is not off hook
-                    if (phoneState == PhoneConstants.State.OFFHOOK && !isBluetoothHeadsetAudioOn()) {
-                        if (!isHeadsetPlugged()) {
-                            // if the state is "not connected", restore the speaker state.
-                            PhoneUtils.restoreSpeakerMode(getApplicationContext());
-                        } else {
-                            // if the state is "connected", force the speaker off without
-                            // storing the state.
-                            PhoneUtils.turnOnSpeaker(getApplicationContext(), false, false);
+                    if (phoneState == PhoneConstants.State.OFFHOOK) {
+                        if (mBluetoothPhone == null || !mBluetoothPhone.isAudioOn()) {
+                            if (!isHeadsetPlugged()) {
+                                // if the state is "not connected", restore the speaker state.
+                                PhoneUtils.restoreSpeakerMode(getApplicationContext());
+                            } else {
+                                // if the state is "connected", force the speaker off without
+                                // storing the state.
+                                PhoneUtils.turnOnSpeaker(getApplicationContext(), false, false);
+                            }
                         }
                     }
                     // Update the Proximity sensor based on headset state
@@ -402,7 +406,8 @@ public class PhoneGlobals extends ContextWrapper
 
                     phoneState = mCM.getState();
                     if (phoneState == PhoneConstants.State.OFFHOOK &&
-                        !isHeadsetPlugged() && !isBluetoothHeadsetAudioOn()) {
+                        !isHeadsetPlugged() &&
+                        !(mBluetoothPhone != null && mBluetoothPhone.isAudioOn())) {
                         PhoneUtils.turnOnSpeaker(getApplicationContext(), inDockMode, true);
                         updateInCallScreen();  // Has no effect if the InCallScreen isn't visible
                     }
@@ -481,11 +486,10 @@ public class PhoneGlobals extends ContextWrapper
             }
 
             if (BluetoothAdapter.getDefaultAdapter() != null) {
-                // Start BluetoothPhoneService even if device is not voice capable.
+                // Start BluetoothHandsfree even if device is not voice capable.
                 // The device can still support VOIP.
-                startService(new Intent(this, BluetoothPhoneService.class));
-                bindService(new Intent(this, BluetoothPhoneService.class),
-                            mBluetoothPhoneConnection, 0);
+                mBluetoothPhone = BluetoothHandsfree.init(this, mCM);
+                startService(new Intent(this, BluetoothHeadsetService.class));
             } else {
                 // Device is not bluetooth capable
                 mBluetoothPhone = null;
@@ -545,7 +549,7 @@ public class PhoneGlobals extends ContextWrapper
             // asynchronous events from the telephony layer (like
             // launching the incoming-call UI when an incoming call comes
             // in.)
-            notifier = CallNotifier.init(this, phone, ringer, new CallLogAsync());
+            notifier = CallNotifier.init(this, phone, ringer, mBluetoothPhone, new CallLogAsync());
 
             // register for ICC status
             IccCard sim = phone.getIccCard();
@@ -692,7 +696,7 @@ public class PhoneGlobals extends ContextWrapper
         return ringer;
     }
 
-    IBluetoothHeadsetPhone getBluetoothPhoneService() {
+    BluetoothHandsfree getBluetoothHandsfree() {
         return mBluetoothPhone;
     }
 
@@ -1164,7 +1168,7 @@ public class PhoneGlobals extends ContextWrapper
                 // is being held in a horizontal position.
                 boolean screenOnImmediately = (isHeadsetPlugged()
                                                || PhoneUtils.isSpeakerOn(this)
-                                               || isBluetoothHeadsetAudioOn()
+                                               || ((mBluetoothPhone != null) && mBluetoothPhone.isAudioOn())
                                                || mIsHardKeyboardOpen);
 
                 // We do not keep the screen off when the user is outside in-call screen and we are
@@ -1339,11 +1343,7 @@ public class PhoneGlobals extends ContextWrapper
         ringer.updateRingerContextAfterRadioTechnologyChange(this.phone);
         notifier.updateCallNotifierRegistrationsAfterRadioTechnologyChange();
         if (mBluetoothPhone != null) {
-            try {
-                mBluetoothPhone.updateBtHandsfreeAfterRadioTechnologyChange();
-            } catch (RemoteException e) {
-                Log.e(LOG_TAG, Log.getStackTraceString(new Throwable()));
-            }
+            mBluetoothPhone.updateBtHandsfreeAfterRadioTechnologyChange();
         }
         if (mInCallScreen != null) {
             mInCallScreen.updateAfterRadioTechnologyChange();
@@ -1465,7 +1465,17 @@ public class PhoneGlobals extends ContextWrapper
             if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
                 boolean enabled = System.getInt(getContentResolver(),
                         System.AIRPLANE_MODE_ON, 0) == 0;
+
+                ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
+
                 phone.setRadioPower(enabled);
+                //vukvuk toggle mobile data to run on radio
+                if(enabled){
+                    boolean dmode = cm.getMobileDataEnabled();
+                    cm.setMobileDataEnabled(false);
+                    cm.setMobileDataEnabled(true);
+                    cm.setMobileDataEnabled(dmode);
+                }
             } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
                 mBluetoothHeadsetState = intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,
                                                           BluetoothHeadset.STATE_DISCONNECTED);
@@ -1879,20 +1889,4 @@ public class PhoneGlobals extends ContextWrapper
             return PhoneGlobals.createCallLogIntent();
         }
     }
-
-    /** Service connection */
-    private final ServiceConnection mBluetoothPhoneConnection = new ServiceConnection() {
-
-        /** Handle the task of binding the local object to the service */
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            Log.i(LOG_TAG, "Headset phone created, binding local service.");
-            mBluetoothPhone = IBluetoothHeadsetPhone.Stub.asInterface(service);
-        }
-
-        /** Handle the task of cleaning up the local binding */
-        public void onServiceDisconnected(ComponentName className) {
-            Log.i(LOG_TAG, "Headset phone disconnected, cleaning local binding.");
-            mBluetoothPhone = null;
-        }
-    };
 }
diff --git a/src/com/android/phone/PhoneUtils.java b/src/com/android/phone/PhoneUtils.java
index f1e8cb4..0f37ecb 100644
--- a/src/com/android/phone/PhoneUtils.java
+++ b/src/com/android/phone/PhoneUtils.java
@@ -20,7 +20,6 @@ package com.android.phone;
 import android.app.AlertDialog;
 import android.app.Dialog;
 import android.app.ProgressDialog;
-import android.bluetooth.IBluetoothHeadsetPhone;
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -235,7 +234,7 @@ public class PhoneUtils {
         final Phone phone = ringingCall.getPhone();
         final boolean phoneIsCdma = (phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA);
         boolean answered = false;
-        IBluetoothHeadsetPhone btPhone = null;
+        BluetoothHandsfree bluetoothHandsfree = null;
 
         // enable noise suppression
         turnOnNoiseSuppression(app.getApplicationContext(), true);
@@ -267,16 +266,12 @@ public class PhoneUtils {
                         // drops off
                         app.cdmaPhoneCallState.setAddCallMenuStateAfterCallWaiting(true);
 
-                        // If a BluetoothPhoneService is valid we need to set the second call state
+                        // If a BluetoothHandsfree is valid we need to set the second call state
                         // so that the Bluetooth client can update the Call state correctly when
                         // a call waiting is answered from the Phone.
-                        btPhone = app.getBluetoothPhoneService();
-                        if (btPhone != null) {
-                            try {
-                                btPhone.cdmaSetSecondCallState(true);
-                            } catch (RemoteException e) {
-                                Log.e(LOG_TAG, Log.getStackTraceString(new Throwable()));
-                            }
+                        bluetoothHandsfree = app.getBluetoothHandsfree();
+                        if (bluetoothHandsfree != null) {
+                            bluetoothHandsfree.cdmaSetSecondCallState(true);
                         }
                   }
                 }
@@ -304,7 +299,7 @@ public class PhoneUtils {
                 // - we did not activate speaker by ourselves during the process above, and
                 // - Bluetooth headset is not in use.
                 if (isRealIncomingCall && !speakerActivated && isSpeakerOn(app)
-                        && !app.isBluetoothHeadsetAudioOn()) {
+                        && !(bluetoothHandsfree != null && bluetoothHandsfree.isAudioOn())) {
                     // This is not an error but might cause users' confusion. Add log just in case.
                     Log.i(LOG_TAG, "Forcing speaker off due to new incoming call...");
                     turnOnSpeaker(app, false, true);
@@ -313,15 +308,11 @@ public class PhoneUtils {
                 Log.w(LOG_TAG, "answerCall: caught " + ex, ex);
 
                 if (phoneIsCdma) {
-                    // restore the cdmaPhoneCallState and btPhone.cdmaSetSecondCallState:
+                    // restore the cdmaPhoneCallState and bthf.cdmaSetSecondCallState:
                     app.cdmaPhoneCallState.setCurrentCallState(
                             app.cdmaPhoneCallState.getPreviousCallState());
-                    if (btPhone != null) {
-                        try {
-                            btPhone.cdmaSetSecondCallState(false);
-                        } catch (RemoteException e) {
-                            Log.e(LOG_TAG, Log.getStackTraceString(new Throwable()));
-                        }
+                    if (bluetoothHandsfree != null) {
+                        bluetoothHandsfree.cdmaSetSecondCallState(false);
                     }
                 }
             }
@@ -824,8 +815,9 @@ public class PhoneUtils {
             final boolean speakerActivated = activateSpeakerIfDocked(phone);
 
             // See also similar logic in answerCall().
+            final BluetoothHandsfree bluetoothHandsfree = app.getBluetoothHandsfree();
             if (initiallyIdle && !speakerActivated && isSpeakerOn(app)
-                    && !app.isBluetoothHeadsetAudioOn()) {
+                    && !(bluetoothHandsfree != null && bluetoothHandsfree.isAudioOn())) {
                 // This is not an error but might cause users' confusion. Add log just in case.
                 Log.i(LOG_TAG, "Forcing speaker off when initiating a new outgoing call...");
                 PhoneUtils.turnOnSpeaker(app, false, true);
@@ -2551,8 +2543,9 @@ public class PhoneUtils {
         if (PhoneGlobals.mDockState != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
             if (DBG) log("activateSpeakerIfDocked(): In a dock -> may need to turn on speaker.");
             PhoneGlobals app = PhoneGlobals.getInstance();
+            BluetoothHandsfree bthf = app.getBluetoothHandsfree();
 
-            if (!app.isHeadsetPlugged() && !app.isBluetoothHeadsetAudioOn()) {
+            if (!app.isHeadsetPlugged() && !(bthf != null && bthf.isAudioOn())) {
                 turnOnSpeaker(phone.getContext(), true, true);
                 activated = true;
             }
